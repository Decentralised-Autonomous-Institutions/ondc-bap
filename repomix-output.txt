This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.cargo/
  config.toml
.claude/
  settings.local.json
docs/
  architecture.mermaid
  dev-environment-setup.md
  Onboarding of Participants.md
  status.md
  technical.md
ondc-bap/
  config/
    production.toml
    staging.toml
  src/
    bin/
      main.rs
    config/
      app_config.rs
      environment.rs
      mod.rs
      ondc_config.rs
    error/
      mod.rs
    infrastructure/
      mod.rs
    presentation/
      handlers/
        admin.rs
        health.rs
        mod.rs
        ondc.rs
      middleware/
        cors.rs
        error_handling.rs
        logging.rs
        mod.rs
        rate_limiting.rs
        security.rs
      mod.rs
      routes.rs
      server.rs
    services/
      challenge_service.rs
      key_management_service.rs
      mod.rs
      registry_client.rs
      site_verification_service.rs
    lib.rs
  .env
  Cargo.toml
  README.md
ondc-crypto-algorithms/
  src/
    aes.rs
    blake2.rs
    ed25519.rs
    lib.rs
    x25519.rs
  Cargo.toml
ondc-crypto-cli/
  examples/
    ci-test-example.sh
    demo.sh
    README.md
    test-challenge.sh
  src/
    main.rs
  Cargo.toml
  README.md
ondc-crypto-formats/
  src/
    base64.rs
    key_formats.rs
    lib.rs
  Cargo.toml
ondc-crypto-traits/
  src/
    error.rs
    lib.rs
    traits.rs
    types.rs
  Cargo.toml
.clippy.toml
.gitignore
.pre-commit-config.yaml
Cargo.toml
CLAUDE.md
ecosystem.config.js
Makefile
README.md
rust-toolchain.toml
rustfmt.toml

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(cargo check:*)"
    ],
    "deny": []
  }
}

================
File: .cargo/config.toml
================
[build]
# Enable incremental compilation for faster builds
incremental = true

[target.x86_64-unknown-linux-gnu]
# Enable link-time optimization for release builds
# rustflags = ["-C", "link-arg=-fuse-ld=lld"]

[target.x86_64-apple-darwin]
# Enable link-time optimization for release builds
# rustflags = ["-C", "link-arg=-fuse-ld=/usr/bin/ld64.lld"]

[target.x86_64-pc-windows-msvc]
# Enable link-time optimization for release builds
# rustflags = ["-C", "link-arg=/OPT:REF", "-C", "link-arg=/OPT:ICF"]

[lints.rust]
# Enable all lints by default
unsafe_code = "forbid"
missing_docs = "warn"
missing_debug_implementations = "warn"
missing_copy_implementations = "warn"
trivial_casts = "warn"
trivial_numeric_casts = "warn"
unused_extern_crates = "warn"
unused_import_braces = "warn"
unused_qualifications = "warn"
unused_results = "warn"
variant_size_differences = "warn"

[lints.clippy]
# Clippy lints for security and code quality
all = "warn"
pedantic = "warn"
nursery = "warn"
cargo = "warn"
complexity = "warn"
correctness = "warn"
perf = "warn"
style = "warn"
suspicious = "warn"

# Security-focused lints
unsafe_derive_deserialize = "warn"
unsafe_removed_from_name = "warn"
unsafe_under_const = "warn"

# Performance lints
large_enum_variant = "warn"
large_stack_arrays = "warn"
large_types_passed_by_value = "warn"
too_many_arguments = "warn"
too_many_lines = "warn"

# Code quality lints
cognitive_complexity = "warn"
cyclomatic_complexity = "warn"
missing_const_for_fn = "warn"
missing_errors_doc = "warn"
missing_panics_doc = "warn"
must_use_candidate = "warn"
needless_pass_by_value = "warn"
non_ascii_literal = "warn"
unseparated_literal_suffix = "warn"

# Allow some lints that are too strict for this project
allow_attributes_without_reason = "allow"
as_conversions = "allow"
cast_possible_truncation = "allow"
cast_possible_wrap = "allow"
cast_precision_loss = "allow"
cast_sign_loss = "allow"
doc_markdown = "allow"
exhaustive_enums = "allow"
exhaustive_structs = "allow"
float_cmp = "allow"
if_not_else = "allow"
indexing_slicing = "allow"
integer_division = "allow"
items_after_statements = "allow"
let_underscore_drop = "allow"
let_underscore_lock = "allow"
let_underscore_must_use = "allow"
manual_assert = "allow"
manual_instant_elapsed = "allow"
manual_string_new = "allow"
map_err_ignore = "allow"
match_bool = "allow"
match_on_vec_items = "allow"
match_same_arms = "allow"
match_wild_err_arm = "allow"
missing_inline_in_public_items = "allow"
module_inception = "allow"
module_name_repetitions = "allow"
multiple_crate_versions = "allow"
must_use_unit = "allow"
needless_borrow = "allow"
needless_collect = "allow"
needless_question_mark = "allow"
needless_return = "allow"
non_ascii_idents = "allow"
option_if_let_else = "allow"
or_fun_call = "allow"
path_buf_push_overwrite = "allow"
pattern_type_mismatch = "allow"
ptr_as_ptr = "allow"
redundant_clone = "allow"
redundant_else = "allow"
redundant_feature_names = "allow"
redundant_static_lifetimes = "allow"
ref_binding_to_reference = "allow"
ref_option_ref = "allow"
same_functions_in_if_blocks = "allow"
self_named_module_files = "allow"
similar_names = "allow"
single_char_lifetime_names = "allow"
string_lit_as_bytes = "allow"
string_to_string = "allow"
todo = "allow"
trivial_regex = "allow"
type_repetition_in_bounds = "allow"
unnecessary_join = "allow"
unnecessary_lazy_evaluations = "allow"
unnecessary_struct_initialization = "allow"
unnecessary_wraps = "allow"
unused_async = "allow"
unused_self = "allow"
use_debug = "allow"
wildcard_dependencies = "allow"

================
File: docs/dev-environment-setup.md
================
# ONDC Crypto SDK - Development Environment Setup

## Overview

This document describes the development environment configuration for the ONDC Crypto SDK project. Task 1.1.2 has been completed with the following components:

## Configuration Files Created

### 1. `rust-toolchain.toml`
**Purpose**: Ensures consistent Rust toolchain across all development environments and CI/CD systems.

**Configuration**:
- Uses stable Rust channel
- Includes essential components: `rustfmt`, `clippy`, `rust-docs`, `rust-analyzer`
- Targets multiple platforms: Linux, macOS, Windows

**Usage**:
```bash
# The toolchain will be automatically installed when you run any cargo command
cargo build
cargo test
```

### 2. `.cargo/config.toml`
**Purpose**: Configures Cargo build system with optimizations and linting rules.

**Key Features**:
- **Build Optimizations**: Incremental compilation, parallel jobs, link-time optimization
- **Platform-Specific Settings**: Optimized flags for Linux, macOS, and Windows
- **Linting Configuration**: Comprehensive Rust and Clippy lint rules
- **Security Focus**: Forbids unsafe code, warns about security issues

**Usage**:
```bash
# All cargo commands automatically use these settings
cargo build --release  # Uses LTO and optimizations
cargo clippy          # Uses configured lint rules
```

### 3. `.pre-commit-config.yaml`
**Purpose**: Automated code quality checks that run before each commit.

**Hooks Included**:
- **Rust Formatting**: `cargo fmt --all`
- **Rust Linting**: `cargo clippy --all-targets --all-features -- -D warnings`
- **Compilation Check**: `cargo check --all-targets --all-features`
- **General File Checks**: Trailing whitespace, file endings, YAML/TOML syntax
- **Security Checks**: Secret detection

**Setup and Usage**:
```bash
# Install pre-commit hooks
make install-hooks
# or manually:
pre-commit install
pre-commit install --hook-type commit-msg

# Run hooks manually
pre-commit run --all-files

# Run specific hook
pre-commit run rustfmt
```

### 4. `rustfmt.toml`
**Purpose**: Configures code formatting rules for consistent style across the project.

**Key Settings**:
- **Line Width**: 100 characters
- **Indentation**: 4 spaces
- **Edition**: 2021
- **Documentation**: Formats code in doc comments

**Usage**:
```bash
# Format all code
cargo fmt --all
# or
make fmt

# Check formatting without changing files
cargo fmt --all -- --check
# or
make fmt-check
```

### 5. `.clippy.toml`
**Purpose**: Customizes Clippy linting rules for cryptographic code.

**Configuration**:
- **Security Lints**: Enabled for unsafe code detection
- **Performance Lints**: Warns about inefficient patterns
- **Code Quality**: Enforces documentation and best practices
- **Crypto-Specific**: Allows necessary patterns for cryptographic operations

**Usage**:
```bash
# Run clippy with configured rules
cargo clippy --all-targets --all-features -- -D warnings
# or
make clippy
```

### 6. `Makefile`
**Purpose**: Provides convenient commands for common development tasks.

**Available Commands**:
```bash
# Show all available commands
make help

# Build commands
make build          # Release build
make build-dev      # Debug build
make check          # Compilation check

# Testing commands
make test           # Run all tests
make test-release   # Release mode tests
make test-coverage  # Coverage reporting

# Code quality commands
make fmt            # Format code
make fmt-check      # Check formatting
make clippy         # Run linter
make audit          # Security audit

# Documentation commands
make doc            # Generate docs
make doc-open       # Generate and open docs

# Setup commands
make install-hooks  # Install pre-commit hooks
make clean          # Clean build artifacts

# Workflow commands
make dev-setup      # Complete setup
make pre-commit     # Run pre-commit checks
make ci             # Run CI checks
make dev            # Quick development cycle
```

## Development Workflow

### Initial Setup
```bash
# 1. Clone the repository
git clone <repository-url>
cd ondc-crypto

# 2. Install pre-commit hooks
make install-hooks

# 3. Verify setup
make check
make test
```

### Daily Development Workflow
```bash
# 1. Start development session
make build-dev

# 2. Make code changes...

# 3. Run quality checks
make dev  # This runs: fmt, clippy, test

# 4. Commit changes (pre-commit hooks run automatically)
git add .
git commit -m "Your commit message"
```

### Pre-Release Checklist
```bash
# Run complete release preparation
make release-prep
# This runs: clean, build, test-release, doc, audit
```

## IDE Integration

### VS Code
Recommended extensions:
- `rust-analyzer` - Rust language support
- `crates` - Cargo.toml dependency management
- `even-better-toml` - TOML file support
- `markdown-all-in-one` - Markdown support

### IntelliJ IDEA / CLion
- Install Rust plugin
- Configure to use the project's `rust-toolchain.toml`

## Troubleshooting

### Common Issues

1. **Pre-commit hooks fail**:
   ```bash
   # Reinstall hooks
   make install-hooks
   
   # Run manually to see detailed errors
   pre-commit run --all-files
   ```

2. **Clippy warnings**:
   ```bash
   # See specific warnings
   cargo clippy --all-targets --all-features
   
   # Fix automatically where possible
   cargo clippy --fix --all-targets --all-features
   ```

3. **Formatting issues**:
   ```bash
   # Format all code
   make fmt
   
   # Check what would be formatted
   make fmt-check
   ```

4. **Toolchain issues**:
   ```bash
   # Update toolchain
   rustup update
   
   # Verify toolchain
   rustup show
   ```

### Performance Tips

1. **Faster builds**:
   ```bash
   # Use incremental compilation (already enabled)
   cargo build --release
   
   # Use parallel compilation (already enabled)
   cargo build -j $(nproc)
   ```

2. **Faster tests**:
   ```bash
   # Run tests in parallel
   cargo test --jobs $(nproc)
   
   # Run specific test
   cargo test test_name
   ```

## Security Considerations

The development environment is configured with security in mind:

1. **Unsafe Code**: Forbidden by default in `.cargo/config.toml`
2. **Secret Detection**: Pre-commit hooks scan for accidentally committed secrets
3. **Dependency Auditing**: `cargo audit` integrated into workflow
4. **Security Lints**: Clippy configured to warn about security issues

## Next Steps

With Task 1.1.2 completed, you can now proceed to:

1. **Task 1.1.3**: Set up CI/CD pipeline
2. **Phase 2**: Begin core crate development
3. **Start Implementation**: Begin working on the actual cryptographic functionality

## Verification

To verify that everything is working correctly:

```bash
# Run the complete verification suite
make ci

# This should run without errors and show:
# - Code formatting is correct
# - No clippy warnings
# - All tests pass
# - No security vulnerabilities
```

The development environment is now ready for productive work on the ONDC Crypto SDK!

================
File: docs/Onboarding of Participants.md
================
# Onboarding Network Participants

To join the ONDC network, Network Participants (NPs) must be registered in the ONDC registry. Follow these prerequisites and steps to complete your onboarding for Staging, Pre-Production, and Production environments:

## Prerequisites

1. **Domain Name**: Ensure your Network Participant (NP) has a valid Fully Qualified Domain Name (FQDN/DNS) that will be included in your subscriber ID (subscriber_id).  
   ```
   e.g., prod.ondcapp.com
   ```

2. **SSL Certificate**: Obtain a valid SSL certificate for your domain. This certificate is used for Online Certificate Status Protocol (OCSP) validation.

3. **Whitelisting**: Get approval for your Staging, Pre-Production, and Production subscriber_id by submitting a request on the Network Participant Portal:
   1. Sign up on the Network Participant Portal [here](https://portal.ondc.org) and submit your request.
   2. Complete your profile 100% after signing up.
   3. From the home menu, find and raise a request for whitelisting under "environment access request." Approval may take 6 to 48 hours.

4. **System Configuration**: Configure your system with the domain name and SSL certificate. All communications with the ONDC Network must occur through this domain.

## Steps

### Steps 1 and 2: Key Generation

You can use the utility [here](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification) to perform these steps. Choose from the following technologies for generating key pairs:

   - [Java](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/on_subscibe-service/java)
   - [Python](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification/python)
   - [GoLang](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification/golang)
   - [NodeJS](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification/node)
   - [PHP](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification/php)

1. **Generate Signing Key Pair**: Create a Signing Key Pair using the Ed25519 Algorithm. This will include a `signing_public_key` and a `signing_private_key` (both base64 encoded).

2. **Generate Encryption Key Pair**: Create an Encryption Key Pair using the X25519 Algorithm. This includes an `encryption_public_key` (in ASN.1 DER format -> base64 encoded) and an `encryption_private_key` (base64 encoded).
   - **Note**: Use the [Libsodium library](https://libsodium.gitbook.io/doc/bindings_for_other_languages) for key pair generation. For NodeJS, use the inbuilt Crypto library instead of Libsodium. Ensure the encryption public key is in ASN.1 DER format. Refer to the key format and generation documentation [here](./key-format-generation.md).

### Steps 3 to 7: Endpoint Setup

You can perform these steps using the utility [here](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/on_subscibe-service). If a utility is not available for your tech stack, you may create one following the outlined steps.

3. **Generate Unique Request ID**: Create a unique Request ID (`request_id`). This ID must be unique for each network participant and can be any format (e.g., UUID, number, or alphanumeric).

4. **Generate SIGNED_UNIQUE_REQ_ID**: Sign the `request_id` using the `signing_private_key` from Step 1. The signature should be created using the Ed25519 algorithm without hashing. The [on_subscribe utility](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/on_subscibe-service) can help with this.

5. **Create `ondc-site-verification.html`**: Place this file at the subscriber_id path and include the `SIGNED_UNIQUE_REQ_ID` generated in Step 4. The registry will check for this file at:
   `https://<subscriber_id>/ondc-site-verification.html`
   ```
   <!-- Contents of ondc-site-verification.html -->
   <!-- Replace SIGNED_UNIQUE_REQ_ID with the actual value -->
   <html>
       <head>
           <meta name='ondc-site-verification' content='SIGNED_UNIQUE_REQ_ID' />
       </head>
       <body>
           ONDC Site Verification Page
       </body>
   </html>
   ```

6. **Configure `/on_subscribe` Endpoint**: Create the encryption shared key using the `encryption_private_key` (from Step 2) and the ONDC public key to decrypt the `challenge_string` received in the `/on_subscribe` call using the AES algorithm.

   ```
   ONDC public key (prod) = "MCowBQYDK2VuAyEAvVEyZY91O2yV8w8/CAwVDAnqIZDJJUPdLUUKwLo3K0M="
   ONDC public key (pre-prod) = "MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q="
   ONDC public key (staging) = "MCowBQYDK2VuAyEAduMuZgmtpjdCuxv+Nc49K0cB6tL/Dj3HZetvVN7ZekM="
   ```

7. **Host `/on_subscribe` Post Endpoint**: Deploy the `/on_subscribe` endpoint at:
   `https://<subscriber_id>/<callback_url>/on_subscribe`
   
   Use the (Node.JS, JAVA, Node, PHP) [utility](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/on_subscibe-service) to implement this endpoint.

**8. Refer to the SwaggerHub document and FAQs for `/subscribe` API**

> - **SwaggerHub Documentation**: [Request Body and Response](https://app.swaggerhub.com/apis-docs/ONDC/ONDC-Registry-Onboarding/2.0.5#/ONDC%20Network%20Participant%20Onboarding/post_subscriber_url_on_subscribe)
> - **FAQs for Subscribe Payload**: [FAQs Document](https://docs.google.com/document/d/15Dpy02lqtcU9tslyMqaI4UtnD2rtwnjAbn1narO0364/edit#heading=h.69ojsi3hg052)

---

> ### Supported Registrations
>
> 1. ops_no : 1 - Buyer App Registration
> 2. ops_no : 2 - Seller App Registration
> 4. ops_no : 4 - Buyer & Seller App Registration
>
> Note: ops_no 3 & 5 is deprecated as feature of Seller On Record (SOR) in registry is obsolete. 

9. Create /subscribe request as follows:

```
1.subscriber_id= YOUR SUBSCRIBER ID (abc.ondcapp.com)
2.callback_url= Relative path to on_subscribe implementation
3.subscriber_url = Relative path to the subscriber_id
4.signing_public_key= <value of sign_public_key generated in step 1>
5.encryption_public_key= <value of enc_dec_public_key generated in step 2>
6.unique_key_id= <generate a unique number for tracking key pairs>
7.For other fields, please refer below swaggerhub link and examples mentioned under heading as ops_no_1, ops_no_2, ops_no_3, ops_no_4 and ops_no_5
https://app.swaggerhub.com/apis-docs/ONDC/ONDC-Registry-Onboarding/2.0.5
```

10. Send created request to URL for /subscribe as below

```
# For Staging Onboarding
https://staging.registry.ondc.org/subscribe

# For PreProd Onboarding
https://preprod.registry.ondc.org/ondc/subscribe

# For Prod Onboarding
https://prod.registry.ondc.org/subscribe

```

11. The call is received by the respective registry and following operations are performed:

> 1. /subscribe payload schema is verified
> 2. OCSP Check: SSL Certificate is verified
> 3. Domain Verification: ondc-site-verification.html is verified;
 > - should be hosted on `https://<subscriber_id>/ondc-site-verification.html`
 > - request_id should be signed using the signing private key (without hashing)  
> 4. /on_susbcribe is called by the registry with a challenge string hosted on the callback_url
>      `https://<subscriber_id>/<callback_url>/on_subscribe`
> ```json
> {
>   "subscriber_id": "abc.com",
>  "challenge": "encrypted_challenge_string"
> }
> ```
> 5. The challenge string should be decrypted using the shared key (generated in step 6) and answer should be provided as a sync response.
> ```json
> {
>   "answer": "decrypted_challange_string"
> }
> ```

12. Verify whether you have received a successful response. If a success response is not received, refer to the section listing possible errors. If the issue persists, kindly reach out to our support desk using the details provided in step 14 below.

```json
{
    "message": {
        "ack": {
            "status": "ACK"
        }
    },
    "error": {
        "type": null,
        "code": null,
        "path": null,
        "message": null
    }
}
```

13. Check your record in registry lookup

> 1. **/v2.0/lookup** (Recommended)

```
# For Staging
https://staging.registry.ondc.org/v2.0/lookup

# For Pre-Prod
https://preprod.registry.ondc.org/v2.0/lookup

# For PROD
https://prod.registry.ondc.org/v2.0/lookup
```

The new version supports secure access using Authorization headers.

```
curl --location 'https://prod.registry.ondc.org/v2.0/lookup' \
--header 'Content-Type: application/json' \
--header 'Authorization: Signature keyId="example-bap.com|bap1234|ed25519", algorithm="ed25519", created="<timestamp>", expires="<timestamp>", headers="(created)(expires)digest", signature="<signature>"' \
--data '{
  "country": "IND",
  "domain": "ONDC:RET10"
}'
```

### Useful References

- [Signing & Verification Process](https://github.com/ONDC-Official/developer-docs/blob/main/registry/signing-verification.md)
- [Reference Utility - Signing & Lookup](https://github.com/ONDC-Official/reference-implementations/tree/main/utilities/signing_and_verification)
- [SwaggerHub - Registry Lookup API](https://app.swaggerhub.com/apis/ONDC/ONDC-Registry-Onboarding/2.1.0#/ONDC%20Network%20Participant%20Onboarding/post_v2_lookup)

> 2. **/lookup** (Deprecated)

```
# For Staging
https://staging.registry.ondc.org/lookup

# For Pre-prod
https://preprod.registry.ondc.org/ondc/lookup

# For PROD
https://prod.registry.ondc.org/lookup
```

> 3. **/vlookup** (Deprecated)

```
# For Staging
https://staging.registry.ondc.org/vlookup

# For Pre-prod
https://preprod.registry.ondc.org/ondc/vlookup

# For PROD
https://prod.registry.ondc.org/vlookup
```
```
	curl --location 'https://preprod.registry.ondc.org/ondc/vlookup' \
		--header 'Content-Type: application/json' \
		--data '{
		    "sender_subscriber_id": "your_sub_id",
		    "request_id": "27baa06d-f90a-486c-85e5-cc621b787f04",
		    "timestamp": "2022-09-13T20:45:07.060Z",
		    "signature": "UNC7Wy8WZ5iQYNBUnHu1wsCtRhZ0P+I4NO5CpP03cNZ+jYuVtXyeMKQs1coU9Q9fpXIJupB8uRVJ5KPbl/x3Bg==",
		    "search_parameters": {
			"country": "IND",
			"domain": "ONDC:RET10",
			"type": "sellerApp",
			"city":"std:080",
			"subscriber_id": "counter_party_sub_id"
		    }
		}'

- sender_subscriber_id: subscriber id of request initiator
- request_id: unique identifier for request
- timestamp: current timestamp in RFC3339 format
- signature: search_parameters signed using private key of request initiator: sign(country|domain|type|city|subscriber_id) => - sign(IND|ONDC:RET10|sellerApp|std:080|ondc.org)
- type: enums are "buyerApp", "sellerApp", "gateway"

```

Note: If the API rate limit is exceeded, you may receive HTTP 429 responses. Recommended registry limits:

| Endpoint                | Limit     |
|-------------------------|-----------|
| `/subscribe`            | 10 RPM    |
| `/lookup`               | 7600 RPM  |
| `/vlookup`              | 2100 RPM  |
| `/search`               | 2100 RPM  |
| `/v2.0/lookup`          | TBD       |

Ensure that your systems are rate-limit aware and gracefully handle retries.

```
14. In case you are not able to find your record in lookup and vlookup, please report to techsupport@ondc.org

```
	Please mention below details in email:
	   # Name : XXXXXXX
	   # Contact Number : XXXXXXXXXXX
	   # Subscriber ID : XXX.XX
	   # Error occurred : Error Code
	   # Error Description : Error Description received after calling subscriber id.
	   # Issue or clarification at which step # : Prerequisites or Steps ?
   	   # Issue / Clarification required : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

## Listing of possible errors

### Subscriber ID not whitelisted by ONDC

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "Subscriber Id is not whitelisted"
    }
}
```

Resolution:

Please connect with ONDC (techsupport@ondc.org) and get your subscriber ID whitelisted

### Timestamp is invalid

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },

    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "Timestamp is invalid"
    }

}
```

Resolution:

Need to put timestamp within the stipulated timegap defined by ONDC.

### Domain Verification Failed

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },

    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "Domain verification is failed"
    }

}
```

Resolution:

The signature generated with signing private key and request id should be put into ondc-site-verification.html (signed using ed25519 algorithm without hashing)

### Subscriber ID already exists

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "Subscriber id already exists"
    }
}
```

Resolution:

If the subscriber ID is already registered with ONDC, this error will be thrown.

### OCSP Failed

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "OCSP failed"
    }
}
```

Resolution:

Need to get a valid SSL certificate for the purchased domain.

#### Encryption Verification Failed

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": "https://pilot-gateway-1.beckn.nsdl.co.in/option1/test/on_subscribe : Encryption verification is failed"
    }
}
```

Resolution:

Utilize the encrypted private key and ONDC public key, then process the challenge received in the on_subscribe callback. Respond synchronously by providing the decrypted value.

### Incorrect Network participant details provided

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "POLICY-ERROR",
        "code": "132",
        "path": null,
        "message": " Please provide valid Network Participant [0] Type "
    }
}
```


Resolution:

Incorrect JSON Type Specification: For example, in Option 1, if the Network Participant is registering and the type is set to sellerApp, the aforementioned error will occur. The value should align with the specified options.
Option 3 Flag Misalignment: Instead of setting MSN to true, it has been incorrectly set as false, and vice versa for non-MSN cases where the flag is inaccurately set to true.

### Network participant's ondc-site-verification.html's encrypted signature verification failed

```json
{
    "message": {
        "ack": {
            "status": "NACK"
        }
    },
    "error": {
        "type": "DOMAIN-ERROR",
        "code": "129",
        "path": null,
        "message": "https://{{netowrk_participant_subsctiber_id}} : Domain verification is failed "
    }
}
```


Resolution:

Utilize Plain Request_ID: Network Participants are advised to use the request_id as is, without applying any hashing, when generating the signature.
Maintain Consistent Request_ID: Network Participants should ensure the request_id in the request body matches the one used during signature generation to guarantee successful validation.
Verify Signing Public Key: Network Participants should include the same signing public key in the request body that corresponds to the signing private key used during the signing process.

================
File: ondc-bap/README.md
================
# ONDC BAP Server

A production-ready ONDC BAP (Beckn Application Platform) server implementation in Rust that handles ONDC network participant onboarding and provides required endpoints for registry integration.

## Features

- **ONDC Protocol Compliance**: Full implementation of ONDC registry APIs
- **Cryptographic Security**: Built on secure crypto foundation using Ed25519 and X25519
- **Production Ready**: Comprehensive logging, monitoring, and error handling
- **Layered Architecture**: Clean separation of concerns with Axum web framework
- **Configuration Management**: Environment-specific configuration with validation
- **Security First**: TLS/HTTPS support, rate limiting, and input validation

## Quick Start

### Prerequisites

- Rust 1.70 or later
- Valid ONDC cryptographic keys (Ed25519 signing, X25519 encryption)

### Installation

```bash
# Clone the repository
git clone <repository-url>
cd ondc-crypto

# Build the BAP server
cargo build --package ondc-bap

# Run the server
cargo run --package ondc-bap
```

### Configuration

1. Copy the configuration template:
```bash
cp ondc-bap/config/staging.toml ondc-bap/config/your-env.toml
```

2. Update the configuration with your settings:
```toml
[ondc]
subscriber_id = "your-domain.com"

[keys]
signing_private_key = "your-base64-encoded-signing-key"
encryption_private_key = "your-base64-encoded-encryption-key"
unique_key_id = "your-key-id"
```

3. Set the environment:
```bash
export ONDC_ENV=your-env
```

### Usage

```rust
use ondc_bap::BAPServer;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server = BAPServer::new().await?;
    server.run().await?;
    Ok(())
}
```

## Architecture

The BAP server follows a layered architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Presentation Layer        â”‚
â”‚         (Axum HTTP Server)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Services Layer            â”‚
â”‚    (Onboarding, Key Management)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Domain Layer              â”‚
â”‚      (Business Entities & Rules)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        Infrastructure Layer         â”‚
â”‚     (HTTP Client, File Storage)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Crypto Foundation           â”‚
â”‚    (Ed25519, X25519, Base64)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## API Endpoints

### ONDC Protocol Endpoints

- `GET /ondc-site-verification.html` - Site verification page
- `POST /on_subscribe` - Challenge-response endpoint

### Administrative Endpoints

- `POST /admin/register` - Initiate registration
- `GET /admin/status` - Check registration status
- `GET /health` - Health check

## Development

### Building

```bash
# Build all crates
cargo build

# Build only BAP server
cargo build --package ondc-bap

# Build with optimizations
cargo build --release --package ondc-bap
```

### Testing

```bash
# Run all tests
cargo test

# Run BAP server tests
cargo test --package ondc-bap

# Run integration tests
cargo test --test integration_tests
```

### Documentation

```bash
# Generate documentation
cargo doc --package ondc-bap --open
```

## Configuration Reference

### Server Configuration

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `host` | String | "0.0.0.0" | Server host address |
| `port` | u16 | 8080 | Server port |
| `tls` | Optional | None | TLS configuration |
| `request_timeout_secs` | u64 | 30 | Request timeout |
| `max_connections` | usize | 1000 | Max concurrent connections |

### ONDC Configuration

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `environment` | Environment | staging | ONDC environment |
| `registry_base_url` | String | - | Registry API URL |
| `subscriber_id` | String | - | Your domain/subscriber ID |
| `callback_url` | String | "/" | Callback URL path |
| `request_timeout_secs` | u64 | 30 | Registry request timeout |
| `max_retries` | usize | 3 | Max retry attempts |

### Key Configuration

| Field | Type | Description |
|-------|------|-------------|
| `signing_private_key` | String | Base64 encoded Ed25519 private key |
| `encryption_private_key` | String | Base64 encoded X25519 private key |
| `unique_key_id` | String | Unique identifier for the key pair |

## Security Considerations

- All private keys are automatically zeroized when dropped
- TLS/HTTPS is required for production deployments
- Rate limiting is enabled by default
- Input validation is performed on all endpoints
- Cryptographic operations use constant-time algorithms

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## License

This project is licensed under either of

- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or https://www.apache.org/licenses/LICENSE-2.0)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or https://opensource.org/licenses/MIT)

at your option.

================
File: ondc-crypto-algorithms/src/aes.rs
================
//! AES-256-ECB decryption implementation for ONDC challenge processing.
//!
//! This module provides AES-256-ECB decryption functionality required for
//! processing ONDC onboarding challenges. It uses the aes and cipher
//! crates for secure cryptographic operations.
//!
//! # Security Features
//!
//! - Constant-time decryption operations
//! - Proper error handling without information leakage
//! - Input validation for all operations
//! - Memory-safe key handling
//!
//! # Examples
//!
//! ```rust
//! use ondc_crypto_algorithms::decrypt_aes256_ecb;
//!
//! let encrypted_data = [0u8; 32]; // In practice, this would be encrypted data
//! let key = [0u8; 32]; // 256-bit key
//! let decrypted = decrypt_aes256_ecb(&encrypted_data, &key).unwrap();
//! ```

use aes::Aes256;
use cipher::{BlockDecrypt, BlockEncrypt, KeyInit, generic_array::GenericArray};
use ondc_crypto_traits::ONDCCryptoError;

/// Decrypt data using AES-256-ECB mode.
///
/// This function decrypts data that was encrypted using AES-256-ECB mode.
/// It's specifically designed for ONDC challenge processing where the
/// challenge is encrypted using this mode.
///
/// # Arguments
///
/// * `encrypted_data` - The encrypted data to decrypt
/// * `key` - The 256-bit (32-byte) decryption key
///
/// # Returns
///
/// Returns the decrypted data as a byte vector, or an error if decryption fails.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes (256 bits)
/// - The encrypted data length is not a multiple of 16 bytes (AES block size)
/// - The decryption operation fails
///
/// # Security Notes
///
/// - ECB mode is generally not recommended for new applications due to
///   its lack of semantic security. However, it's required for ONDC
///   compatibility.
/// - The key should be handled securely and zeroized after use
/// - This function does not perform any key validation beyond length checking
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_algorithms::decrypt_aes256_ecb;
///
/// let encrypted_data = [0u8; 32]; // In practice, this would be encrypted data
/// let key = [0u8; 32]; // 256-bit key
/// let decrypted = decrypt_aes256_ecb(&encrypted_data, &key).unwrap();
/// ```
pub fn decrypt_aes256_ecb(
    encrypted_data: &[u8],
    key: &[u8],
) -> Result<Vec<u8>, ONDCCryptoError> {
    // Validate key length (AES-256 requires 32 bytes)
    if key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: key.len(),
        });
    }

    // Validate encrypted data length (must be multiple of AES block size)
    if encrypted_data.len() % 16 != 0 {
        return Err(ONDCCryptoError::ConfigError(format!(
            "Invalid encrypted data length: expected multiple of 16, got {}",
            encrypted_data.len()
        )));
    }

    // Create AES-256 cipher
    let cipher = Aes256::new_from_slice(key).map_err(|e| {
        ONDCCryptoError::ConfigError(format!("AES-256 setup failed: {}", e))
    })?;

    // Decrypt the data block by block (ECB mode)
    let mut decrypted = Vec::with_capacity(encrypted_data.len());

    for chunk in encrypted_data.chunks(16) {
        if chunk.len() != 16 {
            return Err(ONDCCryptoError::ConfigError(
                "Invalid block size in encrypted data".to_string(),
            ));
        }

        let mut block = GenericArray::clone_from_slice(chunk);
        cipher.decrypt_block(&mut block);
        decrypted.extend_from_slice(block.as_slice());
    }

    Ok(decrypted)
}

/// Encrypt data using AES-256-ECB mode.
///
/// This function encrypts data using AES-256-ECB mode.
/// It's specifically designed for generating test challenges for ONDC testing.
///
/// # Arguments
///
/// * `data` - The data to encrypt
/// * `key` - The 256-bit (32-byte) encryption key
///
/// # Returns
///
/// Returns the encrypted data as a byte vector, or an error if encryption fails.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes (256 bits)
/// - The encryption operation fails
///
/// # Security Notes
///
/// - ECB mode is generally not recommended for new applications due to
///   its lack of semantic security. However, it's required for ONDC
///   compatibility.
/// - The key should be handled securely and zeroized after use
/// - This function is primarily intended for testing purposes
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_algorithms::encrypt_aes256_ecb;
///
/// let data = b"test challenge data";
/// let key = [0u8; 32]; // 256-bit key
/// let encrypted = encrypt_aes256_ecb(data, &key).unwrap();
/// ```
pub fn encrypt_aes256_ecb(
    data: &[u8],
    key: &[u8],
) -> Result<Vec<u8>, ONDCCryptoError> {
    // Validate key length (AES-256 requires 32 bytes)
    if key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: key.len(),
        });
    }

    // Create AES-256 cipher
    let cipher = Aes256::new_from_slice(key).map_err(|e| {
        ONDCCryptoError::ConfigError(format!("AES-256 setup failed: {}", e))
    })?;

    // Pad data to be multiple of 16 bytes (AES block size)
    let mut padded_data = data.to_vec();
    let padding_needed = (16 - (padded_data.len() % 16)) % 16;
    if padding_needed > 0 {
        padded_data.extend(std::iter::repeat(padding_needed as u8).take(padding_needed));
    }

    // Encrypt the data block by block (ECB mode)
    let mut encrypted = Vec::with_capacity(padded_data.len());

    for chunk in padded_data.chunks(16) {
        if chunk.len() != 16 {
            return Err(ONDCCryptoError::ConfigError(
                "Invalid block size in data".to_string(),
            ));
        }

        let mut block = GenericArray::clone_from_slice(chunk);
        cipher.encrypt_block(&mut block);
        encrypted.extend_from_slice(block.as_slice());
    }

    Ok(encrypted)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_aes256_ecb_decryption() {
        // Test with known key and data
        let key = [0u8; 32];
        let encrypted_data = [0u8; 32]; // This would be actual encrypted data in practice
        
        let result = decrypt_aes256_ecb(&encrypted_data, &key);
        assert!(result.is_ok());
    }

    #[test]
    fn test_invalid_key_length() {
        let key = [0u8; 16]; // Wrong length
        let encrypted_data = [0u8; 32];
        
        let result = decrypt_aes256_ecb(&encrypted_data, &key);
        assert!(result.is_err());
    }

    #[test]
    fn test_invalid_data_length() {
        let key = [0u8; 32];
        let encrypted_data = [0u8; 31]; // Not multiple of 16
        
        let result = decrypt_aes256_ecb(&encrypted_data, &key);
        assert!(result.is_err());
    }
}

================
File: ondc-crypto-cli/examples/ci-test-example.sh
================
#!/bin/bash

# CI/CD Example: Automated ONDC Challenge Testing
# This script demonstrates how to integrate challenge testing into CI/CD pipelines

set -e

echo "=== CI/CD Challenge Testing Example ==="
echo

# Configuration (in CI, these would be environment variables)
X25519_PRIVATE_KEY="${X25519_PRIVATE_KEY:-}"
BAP_SERVER_URL="${BAP_SERVER_URL:-http://localhost:8080}"
SUBSCRIBER_ID="${SUBSCRIBER_ID:-test.example.com}"
ENVIRONMENT="${ENVIRONMENT:-staging}"

# Validate required environment variables
if [ -z "$X25519_PRIVATE_KEY" ]; then
    echo "âŒ X25519_PRIVATE_KEY environment variable is required"
    echo "   Set it in your CI/CD environment or export it locally"
    exit 1
fi

echo "Configuration:"
echo "  BAP Server: $BAP_SERVER_URL"
echo "  Subscriber ID: $SUBSCRIBER_ID"
echo "  Environment: $ENVIRONMENT"
echo "  Private Key: ${X25519_PRIVATE_KEY:0:20}..."
echo

# Generate unique test data
TEST_DATA="CI-Test-$(date +%s)-$(openssl rand -hex 8)"

echo "ðŸ”§ Step 1: Generating test challenge..."
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "$X25519_PRIVATE_KEY" \
  --data "$TEST_DATA" \
  --environment "$ENVIRONMENT" \
  --json > challenge.json

CHALLENGE_B64=$(jq -r .encrypted_challenge challenge.json)
echo "âœ… Challenge generated: ${CHALLENGE_B64:0:20}..."

echo
echo "ðŸ”§ Step 2: Testing BAP server endpoint..."

# Prepare test payload
JSON_PAYLOAD=$(cat <<EOF
{
  "subscriber_id": "$SUBSCRIBER_ID",
  "challenge": "$CHALLENGE_B64"
}
EOF
)

# Test the endpoint with timeout
if timeout 30s curl -s -X POST "$BAP_SERVER_URL/on_subscribe" \
  -H "Content-Type: application/json" \
  -d "$JSON_PAYLOAD" > response.json; then
    
    echo "âœ… Request completed successfully"
    
    # Validate response
    if jq -e '.answer' response.json > /dev/null 2>&1; then
        ANSWER=$(jq -r '.answer' response.json)
        
        if [ "$ANSWER" = "$TEST_DATA" ]; then
            echo "âœ… Challenge/response validation PASSED"
            echo "   Expected: $TEST_DATA"
            echo "   Received: $ANSWER"
            exit 0
        else
            echo "âŒ Challenge/response validation FAILED"
            echo "   Expected: $TEST_DATA"
            echo "   Received: $ANSWER"
            exit 1
        fi
    else
        echo "âŒ Invalid response format"
        echo "Response:"
        cat response.json
        exit 1
    fi
else
    echo "âŒ BAP server test FAILED"
    echo "   Server not responding or timeout reached"
    exit 1
fi

================
File: ondc-crypto-cli/examples/README.md
================
# ONDC Crypto CLI Examples

This directory contains examples demonstrating how to use the ONDC Crypto CLI for various cryptographic operations, including the new challenge generation capabilities for testing ONDC BAP servers.

## Quick Start

Run the complete demo to see all features in action:

```bash
cd examples
chmod +x demo.sh
./demo.sh
```

## Available Scripts

### 1. `demo.sh` - Complete Feature Demo
Demonstrates all CLI features including key generation, signing, verification, and challenge generation.

### 2. `test-challenge.sh` - Interactive Challenge Testing
Interactive script for testing challenge generation and BAP server integration with colored output and detailed feedback.

### 3. `ci-test-example.sh` - CI/CD Integration Example
Example script showing how to integrate challenge testing into CI/CD pipelines with environment variables.

## Challenge Generation Examples

### 1. Basic Challenge Generation

Generate a test challenge using default test data:

```bash
# First, generate an X25519 key pair
cargo run --package ondc-crypto-cli -- generate x25519

# Use the private key to generate a challenge
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --environment staging
```

### 2. Custom Challenge Data

Generate a challenge with custom data:

```bash
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --data "Custom challenge data for testing" \
  --environment staging
```

### 3. JSON Output Format

Generate challenge with structured JSON output:

```bash
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --data "JSON test challenge" \
  --environment staging \
  --json
```

Example JSON output:
```json
{
  "encrypted_challenge": "OEWkbQV71HButW404pt3WFoz5fcJYtJpJFOQqYm+FZQ=",
  "environment": "staging",
  "original_data": "JSON test challenge"
}
```

### 4. Different ONDC Environments

Test with different ONDC environments:

```bash
# Staging environment
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --environment staging

# Pre-production environment
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --environment pre-prod

# Production environment
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "YOUR_X25519_PRIVATE_KEY" \
  --environment production
```

## Testing BAP Server with Generated Challenges

### Interactive Testing

Use the interactive test script for comprehensive testing:

```bash
chmod +x test-challenge.sh
./test-challenge.sh
```

This script will:
- Generate X25519 key pairs
- Create test challenges
- Check BAP server health
- Test the `/on_subscribe` endpoint
- Validate challenge/response matching
- Provide manual testing commands

### Complete Testing Workflow

1. **Generate X25519 Key Pair**:
   ```bash
   cargo run --package ondc-crypto-cli -- generate x25519 --json > x25519.keys.json
   ```

2. **Generate Test Challenge**:
   ```bash
   PRIVATE_KEY=$(jq -r .private_key x25519.keys.json)
   cargo run --package ondc-crypto-cli -- challenge \
     --private-key "$PRIVATE_KEY" \
     --data "Test challenge for BAP server" \
     --environment staging \
     --json > challenge.json
   ```

3. **Extract Challenge for Testing**:
   ```bash
   CHALLENGE_B64=$(jq -r .encrypted_challenge challenge.json)
   ```

4. **Test BAP Server Endpoint**:
   ```bash
   curl -X POST http://localhost:8080/on_subscribe \
     -H "Content-Type: application/json" \
     -d "{
       \"subscriber_id\": \"test.example.com\",
       \"challenge\": \"$CHALLENGE_B64\"
     }"
   ```

### Expected Response

If the BAP server is working correctly, you should receive:

```json
{
  "answer": "Test challenge for BAP server"
}
```

## CI/CD Integration

### Automated Testing

Use the CI/CD example script for automated testing:

```bash
# Set environment variables
export X25519_PRIVATE_KEY="your-base64-encoded-private-key"
export BAP_SERVER_URL="http://your-bap-server:8080"
export SUBSCRIBER_ID="your.subscriber.id"
export ENVIRONMENT="staging"

# Run automated test
chmod +x ci-test-example.sh
./ci-test-example.sh
```

### GitHub Actions Example

```yaml
name: ONDC Challenge Testing

on: [push, pull_request]

jobs:
  test-challenge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Generate and test challenge
        env:
          X25519_PRIVATE_KEY: ${{ secrets.X25519_PRIVATE_KEY }}
          BAP_SERVER_URL: ${{ secrets.BAP_SERVER_URL }}
          SUBSCRIBER_ID: ${{ secrets.SUBSCRIBER_ID }}
          ENVIRONMENT: staging
        run: |
          cd ondc-crypto-cli/examples
          chmod +x ci-test-example.sh
          ./ci-test-example.sh
```

## Automated Testing Script

The `demo.sh` script demonstrates a complete workflow:

1. **Key Generation**: Creates Ed25519 and X25519 key pairs
2. **Signature Operations**: Signs and verifies messages
3. **Challenge Generation**: Creates test challenges for all environments
4. **Testing Setup**: Prepares curl commands for BAP server testing

### Running the Demo

```bash
# Make the script executable
chmod +x demo.sh

# Run the complete demo
./demo.sh
```

## Challenge Generation Details

### How It Works

1. **X25519 Key Exchange**: 
   - Uses your private key and ONDC's public key
   - Generates a shared secret using Diffie-Hellman key exchange

2. **AES-256-ECB Encryption**:
   - Encrypts challenge data using the shared secret as the key
   - Uses AES-256-ECB mode as required by ONDC specification
   - Automatically pads data to 16-byte blocks

3. **Base64 Encoding**:
   - Outputs encrypted challenge in base64 format
   - Ready for HTTP transmission to BAP server

### ONDC Public Keys

The CLI uses the official ONDC public keys for each environment:

- **Staging**: `MCowBQYDK2VuAyEAduMuZgmtpjdCuxv+Nc49K0cB6tL/Dj3HZetvVN7ZekM=`
- **Pre-Production**: `MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=`
- **Production**: `MCowBQYDK2VuAyEAvVEyZY91O2yV8w8/CAwVDAnqIZDJJUPdLUUKwLo3K0M=`

### Security Notes

- **Key Management**: Keep your private keys secure and never share them
- **Environment Testing**: Use staging environment for development and testing
- **Challenge Uniqueness**: Each challenge should be unique for proper testing
- **Server Configuration**: Ensure your BAP server uses the same X25519 private key

## Troubleshooting

### Common Issues

1. **Invalid Private Key Format**:
   - Ensure the private key is base64-encoded
   - X25519 private keys must be exactly 32 bytes when decoded

2. **Environment Mismatch**:
   - Use the same environment (staging/preprod/prod) for both challenge generation and BAP server configuration

3. **BAP Server Not Responding**:
   - Ensure the BAP server is running on the expected port
   - Check that the subscriber_id matches your configuration

4. **Decryption Failures**:
   - Verify that the BAP server uses the same X25519 private key
   - Ensure the challenge was generated for the correct environment

### Debug Mode

For debugging, you can use the JSON output to inspect the challenge details:

```bash
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "$PRIVATE_KEY" \
  --data "Debug test" \
  --environment staging \
  --json | jq .
```

This will show you the encrypted challenge, environment, and original data for verification.

## Prerequisites

- **Rust**: Latest stable version
- **jq**: For JSON processing in scripts
- **curl**: For HTTP testing
- **BAP Server**: Running instance for endpoint testing

### Installation

```bash
# Install jq (Ubuntu/Debian)
sudo apt-get install jq

# Install jq (macOS)
brew install jq

# Install jq (CentOS/RHEL)
sudo yum install jq
```

================
File: ondc-crypto-cli/examples/test-challenge.sh
================
#!/bin/bash

# ONDC Challenge Testing Script
# This script demonstrates how to generate and test ONDC challenges with a BAP server

set -e  # Exit on any error

echo "=== ONDC Challenge Testing Script ==="
echo

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    print_error "jq is required but not installed. Please install jq first."
    exit 1
fi

# Configuration
BAP_SERVER_URL="http://localhost:8080"
SUBSCRIBER_ID="test.example.com"
ENVIRONMENT="staging"
TEST_DATA="ONDC Challenge Test $(date +%s)"

print_status "Configuration:"
echo "  BAP Server URL: $BAP_SERVER_URL"
echo "  Subscriber ID: $SUBSCRIBER_ID"
echo "  Environment: $ENVIRONMENT"
echo "  Test Data: $TEST_DATA"
echo

# Step 1: Generate X25519 key pair
print_status "Step 1: Generating X25519 key pair..."
cargo run --package ondc-crypto-cli -- generate x25519 --json > x25519.keys.json
X25519_PRIVATE_KEY=$(jq -r .private_key x25519.keys.json)
X25519_PUBLIC_KEY=$(jq -r .public_key x25519.keys.json)
print_success "X25519 key pair generated"
echo "  Private Key: ${X25519_PRIVATE_KEY:0:20}..."
echo "  Public Key:  ${X25519_PUBLIC_KEY:0:20}..."
echo

# Step 2: Generate test challenge
print_status "Step 2: Generating test challenge..."
cargo run --package ondc-crypto-cli -- challenge \
  --private-key "$X25519_PRIVATE_KEY" \
  --data "$TEST_DATA" \
  --environment "$ENVIRONMENT" \
  --json > challenge.json

CHALLENGE_B64=$(jq -r .encrypted_challenge challenge.json)
ORIGINAL_DATA=$(jq -r .original_data challenge.json)
print_success "Challenge generated"
echo "  Encrypted Challenge: ${CHALLENGE_B64:0:20}..."
echo "  Original Data: $ORIGINAL_DATA"
echo

# Step 3: Test BAP server health
print_status "Step 3: Checking BAP server health..."
if curl -s "$BAP_SERVER_URL/health" > /dev/null; then
    print_success "BAP server is running"
else
    print_warning "BAP server is not responding at $BAP_SERVER_URL"
    print_warning "Make sure the BAP server is running with:"
    echo "  cd ../ondc-bap"
    echo "  ONDC_ENV=staging cargo run"
    echo
    print_warning "Continuing with challenge generation only..."
    echo
fi

# Step 4: Test on_subscribe endpoint
print_status "Step 4: Testing /on_subscribe endpoint..."

# Prepare the JSON payload
JSON_PAYLOAD=$(cat <<EOF
{
  "subscriber_id": "$SUBSCRIBER_ID",
  "challenge": "$CHALLENGE_B64"
}
EOF
)

# Test the endpoint
if curl -s -X POST "$BAP_SERVER_URL/on_subscribe" \
  -H "Content-Type: application/json" \
  -d "$JSON_PAYLOAD" > response.json; then
    
    print_success "Request sent successfully"
    
    # Check if response contains expected data
    if jq -e '.answer' response.json > /dev/null 2>&1; then
        ANSWER=$(jq -r '.answer' response.json)
        print_success "Challenge decrypted successfully!"
        echo "  Expected: $ORIGINAL_DATA"
        echo "  Received: $ANSWER"
        
        if [ "$ANSWER" = "$ORIGINAL_DATA" ]; then
            print_success "âœ… Challenge/response match perfectly!"
        else
            print_error "âŒ Challenge/response mismatch!"
            echo "  Expected: $ORIGINAL_DATA"
            echo "  Received: $ANSWER"
        fi
    else
        print_error "âŒ Invalid response format"
        echo "Response:"
        cat response.json
    fi
else
    print_error "âŒ Failed to connect to BAP server"
    print_warning "Make sure the BAP server is running and accessible"
fi

echo

# Step 5: Generate curl command for manual testing
print_status "Step 5: Manual testing command..."
echo "You can manually test the challenge using this curl command:"
echo
echo "curl -X POST $BAP_SERVER_URL/on_subscribe \\"
echo "  -H \"Content-Type: application/json\" \\"
echo "  -d '{"
echo "    \"subscriber_id\": \"$SUBSCRIBER_ID\","
echo "    \"challenge\": \"$CHALLENGE_B64\""
echo "  }'"
echo

# Step 6: Cleanup
print_status "Step 6: Cleaning up temporary files..."
rm -f x25519.keys.json challenge.json response.json
print_success "Temporary files cleaned up"

echo
print_success "=== Challenge Testing Complete ==="
echo
print_status "Summary:"
echo "  âœ… X25519 key pair generated"
echo "  âœ… Challenge encrypted with ONDC public key"
echo "  âœ… Challenge ready for BAP server testing"
echo
print_status "Next steps:"
echo "  1. Start your BAP server with the same X25519 private key"
echo "  2. Use the generated challenge to test the /on_subscribe endpoint"
echo "  3. Verify that the server can decrypt and return the original data"

================
File: ondc-crypto-cli/Cargo.toml
================
[package]
name = "ondc-crypto-cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
description = "ONDC cryptographic CLI utilities"
keywords = ["ondc", "crypto", "cli", "keys", "signing"]
categories = ["command-line-utilities", "cryptography"]

[dependencies]
# Internal workspace dependencies
ondc-crypto-algorithms = { path = "../ondc-crypto-algorithms" }
ondc-crypto-formats = { path = "../ondc-crypto-formats" }
ondc-crypto-traits = { path = "../ondc-crypto-traits" }

# CLI framework
clap = { version = "4.0", features = ["derive"] }

# Error handling
anyhow.workspace = true
thiserror.workspace = true

# Random number generation
rand.workspace = true

# Output formatting
serde_json.workspace = true
serde.workspace = true
base64.workspace = true
hex.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

[[bin]]
name = "ondc-crypto"
path = "src/main.rs"

[features]
default = []
dev-deps = []

================
File: ondc-crypto-cli/README.md
================
# ONDC Crypto CLI

A command-line interface for ONDC cryptographic operations.

## Features

- Generate Ed25519 and X25519 key pairs
- Sign data with Ed25519
- Verify Ed25519 signatures
- Hash data with BLAKE2
- Multiple output formats (Base64, Hex, Raw)
- JSON output support

## Usage

### Generate Keys
```bash
ondc-crypto generate ed25519
ondc-crypto generate x25519 --format hex --json
```

### Sign Data
```bash
ondc-crypto sign --private-key <key> --data "Hello World"
```

### Verify Signatures
```bash
ondc-crypto verify --public-key <key> --signature <sig> --data "Hello World"
```

### Hash Data
```bash
ondc-crypto hash --data "Hello World"
```

================
File: .clippy.toml
================
# Clippy configuration for ONDC Crypto SDK
# Security-focused linting configuration

# Allow some lints that are too strict for cryptographic code
allow = [
    "as_conversions",           # Sometimes needed for crypto operations
    "cast_possible_truncation", # Common in crypto when converting between types
    "cast_possible_wrap",       # Common in crypto when converting between types
    "cast_precision_loss",      # Common in crypto when converting between types
    "cast_sign_loss",           # Common in crypto when converting between types
    "doc_markdown",             # Allow markdown in documentation
    "exhaustive_enums",         # Too strict for large enums
    "exhaustive_structs",       # Too strict for large structs
    "float_cmp",                # Sometimes needed for test comparisons
    "if_not_else",              # Sometimes more readable
    "indexing_slicing",         # Sometimes needed for performance
    "integer_division",         # Sometimes intended behavior
    "items_after_statements",   # Sometimes needed for clarity
    "let_underscore_drop",      # Sometimes needed for side effects
    "let_underscore_lock",      # Sometimes needed for side effects
    "let_underscore_must_use",  # Sometimes needed for side effects
    "manual_assert",            # Sometimes more explicit
    "manual_instant_elapsed",   # Sometimes more explicit
    "manual_string_new",        # Sometimes more explicit
    "map_err_ignore",           # Sometimes needed for error conversion
    "match_bool",               # Sometimes more readable
    "match_on_vec_items",       # Sometimes needed for performance
    "match_same_arms",          # Sometimes needed for clarity
    "match_wild_err_arm",       # Sometimes needed for error handling
    "missing_inline_in_public_items", # Sometimes not needed
    "module_inception",         # Sometimes needed for organization
    "module_name_repetitions",  # Sometimes needed for clarity
    "multiple_crate_versions",  # Sometimes needed for compatibility
    "must_use_unit",            # Sometimes not needed
    "needless_borrow",          # Sometimes needed for clarity
    "needless_collect",         # Sometimes needed for performance
    "needless_question_mark",   # Sometimes more readable
    "needless_return",          # Sometimes more readable
    "non_ascii_idents",         # Sometimes needed for internationalization
    "option_if_let_else",       # Sometimes more readable
    "or_fun_call",              # Sometimes more readable
    "path_buf_push_overwrite",  # Sometimes intended behavior
    "pattern_type_mismatch",    # Sometimes needed for type safety
    "ptr_as_ptr",               # Sometimes needed for FFI
    "redundant_clone",          # Sometimes needed for ownership
    "redundant_else",           # Sometimes more readable
    "redundant_feature_names",  # Sometimes needed for clarity
    "redundant_static_lifetimes", # Sometimes needed for clarity
    "ref_binding_to_reference", # Sometimes needed for borrowing
    "ref_option_ref",           # Sometimes needed for borrowing
    "same_functions_in_if_blocks", # Sometimes needed for clarity
    "self_named_module_files",  # Sometimes needed for organization
    "similar_names",            # Sometimes needed for clarity
    "single_char_lifetime_names", # Sometimes needed for brevity
    "string_lit_as_bytes",      # Sometimes needed for performance
    "string_to_string",         # Sometimes needed for ownership
    "todo",                     # Allow TODO comments for development
    "trivial_regex",            # Sometimes needed for clarity
    "type_repetition_in_bounds", # Sometimes needed for clarity
    "unnecessary_join",         # Sometimes needed for clarity
    "unnecessary_lazy_evaluations", # Sometimes needed for performance
    "unnecessary_struct_initialization", # Sometimes needed for clarity
    "unnecessary_wraps",        # Sometimes needed for type safety
    "unused_async",             # Sometimes needed for trait implementations
    "unused_self",              # Sometimes needed for clarity
    "use_debug",                # Sometimes needed for debugging
    "wildcard_dependencies",    # Sometimes needed for compatibility
]

# Disable some lints that are not applicable to crypto code
disallow = [
    "unsafe_code",              # Forbid unsafe code by default
]

# Set specific lint levels
warn = [
    "clippy::all",              # Enable all clippy lints
    "clippy::pedantic",         # Enable pedantic lints
    "clippy::nursery",          # Enable nursery lints
    "clippy::cargo",            # Enable cargo lints
    "clippy::complexity",       # Enable complexity lints
    "clippy::correctness",      # Enable correctness lints
    "clippy::perf",             # Enable performance lints
    "clippy::style",            # Enable style lints
    "clippy::suspicious",       # Enable suspicious lints
    # Security-focused lints
    "clippy::unsafe_derive_deserialize",
    "clippy::unsafe_removed_from_name",
    "clippy::unsafe_under_const",
    # Performance lints
    "clippy::large_enum_variant",
    "clippy::large_stack_arrays",
    "clippy::large_types_passed_by_value",
    "clippy::too_many_arguments",
    "clippy::too_many_lines",
    # Code quality lints
    "clippy::cognitive_complexity",
    "clippy::cyclomatic_complexity",
    "clippy::missing_const_for_fn",
    "clippy::missing_errors_doc",
    "clippy::missing_panics_doc",
    "clippy::must_use_candidate",
    "clippy::needless_pass_by_value",
    "clippy::non_ascii_literal",
    "clippy::unseparated_literal_suffix",
]

================
File: .pre-commit-config.yaml
================
repos:
  # Rust formatting and linting
  - repo: https://github.com/doublify/pre-commit-rust
    rev: v1.0
    hooks:
      - id: fmt
        name: rustfmt
        description: Format Rust code
        entry: cargo fmt --all
        language: system
        types: [rust]
        pass_filenames: false
        
      - id: clippy
        name: clippy
        description: Lint Rust code
        entry: cargo clippy --all-targets --all-features -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false
        
      - id: check
        name: cargo check
        description: Check Rust code compiles
        entry: cargo check --all-targets --all-features
        language: system
        types: [rust]
        pass_filenames: false

  # General file checks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
        description: Remove trailing whitespace
      - id: end-of-file-fixer
        description: Ensure files end with a newline
      - id: check-yaml
        description: Check YAML syntax
      - id: check-toml
        description: Check TOML syntax
      - id: check-merge-conflict
        description: Check for merge conflict markers
      - id: check-added-large-files
        description: Prevent large files from being committed
        args: ['--maxkb=1000']
      - id: check-case-conflict
        description: Check for files that would conflict in case-insensitive filesystems
      - id: check-json
        description: Check JSON syntax
      - id: check-merge-conflict
        description: Check for merge conflict markers

  # Security checks
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
        description: Detect secrets in code
        args: ['--baseline', '.secrets.baseline']
        exclude: |
          (?x)^(
              \.git/|
              \.cargo/|
              target/|
              docs/|
              \.secrets\.baseline
          )$

================
File: CLAUDE.md
================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an ONDC (Open Network for Digital Commerce) BAP (Beckn Application Platform) server implementation in Rust. The project provides a production-ready server for onboarding as a Network Participant in the ONDC ecosystem, handling cryptographic operations, site verification, and challenge-response authentication.

## Build and Development Commands

### Primary Build Commands
```bash
# Build all crates in release mode
make build
# or
cargo build --release --all-targets --all-features

# Build in debug mode
make build-dev
# or
cargo build --all-targets --all-features

# Check compilation
make check
# or
cargo check --all-targets --all-features
```

### Testing Commands
```bash
# Run all tests
make test
# or
cargo test --all-targets --all-features

# Run tests in release mode
make test-release
# or
cargo test --release --all-targets --all-features

# Run tests with coverage
make test-coverage
```

### Code Quality Commands
```bash
# Format code
make fmt
# or
cargo fmt --all

# Check formatting
make fmt-check
# or
cargo fmt --all -- --check

# Run linter
make clippy
# or
cargo clippy --all-targets --all-features -- -D warnings

# Security audit
make audit
# or
cargo audit
```

### Development Workflow
```bash
# Quick development cycle
make dev  # runs fmt, clippy, test

# Pre-commit checks
make pre-commit  # runs fmt, clippy, test

# CI checks
make ci  # runs fmt-check, clippy, test, audit
```

### Running the Server
```bash
# Run with staging configuration
make run-staging
# or
cd ondc-bap && ONDC_ENV=staging cargo run

# Run with production configuration
make run-production
# or
cd ondc-bap && ONDC_ENV=production cargo run
```

## Architecture Overview

This is a Rust workspace with 5 crates following a layered architecture:

### Crate Structure
- **`ondc-bap/`**: Main BAP server application (Axum web server)
- **`ondc-crypto-traits/`**: Core traits and error types for cryptographic operations
- **`ondc-crypto-algorithms/`**: Cryptographic implementations (Ed25519, X25519, AES-256-ECB, Blake2)
- **`ondc-crypto-formats/`**: Encoding utilities (Base64, key format conversions)
- **`ondc-crypto-cli/`**: Command-line utilities for key generation and testing

### Main Application Architecture (ondc-bap)
- **Presentation Layer**: Axum HTTP server with comprehensive middleware stack
  - Routes: Health checks, ONDC protocol endpoints, administrative endpoints
  - Middleware: CORS, security headers, rate limiting, logging, error handling
- **Services Layer**: Business logic for ONDC operations
  - `ChallengeService`: Challenge-response authentication
  - `KeyManagementService`: Cryptographic key management
  - `RegistryClient`: ONDC registry API integration
  - `SiteVerificationService`: Site verification page generation
- **Infrastructure Layer**: Configuration, logging, external integrations
- **Config Layer**: Environment-specific configuration management

### Key Endpoints
- `/health`, `/ready`, `/live`: Health and readiness checks
- `/ondc-site-verification.html`: ONDC site verification with Ed25519 signatures
- `/on_subscribe`: Challenge-response authentication endpoint
- `/admin/register`: Administrative registration endpoint
- `/admin/subscribe`: Registry subscription endpoint

## Development Guidelines

### Mandatory File Reads Before Code Changes
Always read these files before making any changes:
1. `docs/architecture.mermaid`: System architecture and data flows
2. `docs/technical.md`: Technical specifications and security requirements
3. `docs/status.md`: Current implementation progress
4. `Cargo.toml`: Dependencies and workspace configuration

### Security-First Development
- Use `Result<T, E>` for all fallible operations
- Apply `#[derive(Zeroize)]` for sensitive data structures
- Use `subtle` crate for constant-time operations
- Implement comprehensive error handling with `thiserror`
- Use `zeroize::Zeroizing` for temporary sensitive data

### Code Quality Standards
- Follow trait-based design patterns
- Use type safety to prevent misuse (newtypes)
- Write comprehensive tests (unit, integration, property-based with `proptest`)
- Maintain rustdoc documentation with security warnings
- Zero compiler warnings and clippy issues

### Configuration Management
- Environment-specific configs in `ondc-bap/config/`
- Use `ONDC_ENV` environment variable for config selection
- Support for staging and production environments
- Figment-based configuration with TOML and environment variable support

### Task Management Workflow
1. Check `docs/status.md` for current progress and pending tasks
2. Verify architectural compliance with `docs/architecture.mermaid`
3. Follow security patterns from `docs/technical.md`
4. Update `docs/status.md` after completing tasks
5. Run full test suite before considering tasks complete

## Important Notes

- This is a cryptographic security project requiring careful attention to security best practices
- All cryptographic operations must be constant-time and resistant to timing attacks
- The project implements ONDC protocol compliance with specific requirements for Ed25519 signing and X25519 key exchange
- Configuration files contain sensitive cryptographic keys and should be handled securely
- The server supports TLS and includes comprehensive middleware for production deployment

## Key Dependencies

- **Web Framework**: Axum with Tower middleware
- **Cryptography**: ed25519-dalek, x25519-dalek, aes, blake2b_simd
- **Async Runtime**: Tokio
- **Configuration**: Figment with TOML support
- **Error Handling**: thiserror, anyhow
- **Security**: zeroize, subtle
- **Testing**: proptest for property-based testing

## Documentation

Comprehensive documentation is available in the `docs/` directory:
- Technical implementation details
- System architecture diagrams
- ONDC onboarding procedures
- Development environment setup

================
File: ecosystem.config.js
================
module.exports = {
  apps: [
    {
      name: 'ondc-bap-server',
      script: './target/release/ondc-bap',
      // Set working directory to project root so config/ is found
      cwd: './',
      env: {
        ONDC_ENV: 'staging',
        RUST_LOG: 'ondc_bap=info,tower_http=debug'
      },
      env_production: {
        ONDC_ENV: 'production',
        RUST_LOG: 'ondc_bap=info'
      },
      instances: 1,
      exec_mode: 'fork',
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      error_file: './logs/err.log',
      out_file: './logs/out.log',
      log_file: './logs/combined.log',
      time: true
    }
  ]
};

================
File: rust-toolchain.toml
================
[toolchain]
channel = "stable"
components = [
    "rustfmt",
    "clippy",
    "rust-docs",
    "rust-analyzer",
]
targets = [
    "x86_64-unknown-linux-gnu",
    "x86_64-apple-darwin",
    "x86_64-pc-windows-msvc",
]

================
File: rustfmt.toml
================
# Rustfmt configuration for ONDC Crypto SDK
# Based on Rust community standards and security best practices

# Code style
edition = "2021"
max_width = 100
tab_spaces = 4
newline_style = "Unix"
use_small_heuristics = "Default"

# Formatting options
format_code_in_doc_comments = true
format_strings = true
format_macro_matchers = true
format_macro_bodies = true
empty_item_single_line = true
brace_style = "SameLineWhere"
control_brace_style = "AlwaysSameLine"
remove_nested_parens = true
combine_control_expr = true
overflow_delimited_expr = false
struct_field_align_threshold = 0
enum_discrim_align_threshold = 0
match_arm_blocks = true
force_multiline_blocks = false
fn_call_width = 60
where_single_line = false
where_pred_indent = "Block"
type_punctuation_density = "Wide"
space_before_colon = false
space_after_colon = true
spaces_around_ranges = false
binop_separator = "Front"
remove_trailing_whitespace = true
trailing_comma = "Vertical"
trailing_semicolon = true
match_arm_leading_pipes = "Never"
merge_derives = true
use_try_shorthand = true
use_field_init_shorthand = true
force_explicit_abi = true
condense_wildcard_suffixes = false
color = "Auto"
required_version = "1.4.38"

# Documentation formatting
doc_comment_code_block_width = 100

================
File: ondc-bap/src/infrastructure/mod.rs
================
//! Infrastructure layer for ONDC BAP Server

// TODO: Implement infrastructure modules
// - HTTP client
// - File storage
// - Logging configuration

================
File: ondc-bap/src/presentation/handlers/health.rs
================
//! Health check handlers for ONDC BAP Server

use axum::{http::StatusCode, response::Json};
use serde::Serialize;
use tracing::info;

/// Health check response
#[derive(Serialize)]
pub struct HealthResponse {
    pub status: String,
    pub timestamp: String,
    pub version: String,
    pub uptime_seconds: u64,
}

/// Basic health check endpoint
pub async fn health_check() -> Json<HealthResponse> {
    info!("Health check requested");

    Json(HealthResponse {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        version: env!("CARGO_PKG_VERSION").to_string(),
        uptime_seconds: 0, // TODO: Implement uptime tracking
    })
}

/// Readiness probe endpoint
pub async fn readiness_check() -> StatusCode {
    // TODO: Implement readiness checks (database, external services, etc.)
    StatusCode::OK
}

/// Liveness probe endpoint
pub async fn liveness_check() -> StatusCode {
    // TODO: Implement liveness checks
    StatusCode::OK
}

================
File: ondc-bap/src/presentation/middleware/cors.rs
================
//! CORS middleware for ONDC BAP Server

use axum::{
    extract::Request,
    http::{HeaderValue, Method},
    middleware::Next,
    response::Response,
};
use tower_http::cors::{Any, CorsLayer};

/// CORS middleware configuration
pub fn cors_middleware() -> CorsLayer {
    CorsLayer::new()
        .allow_origin(Any)
        .allow_methods([
            Method::GET,
            Method::POST,
            Method::PUT,
            Method::DELETE,
            Method::OPTIONS,
        ])
        .allow_headers(Any)
        .max_age(std::time::Duration::from_secs(3600))
}

/// Simple CORS middleware for development
pub async fn cors_middleware_simple(request: Request, next: Next) -> Response {
    let mut response = next.run(request).await;

    // Add CORS headers
    let headers = response.headers_mut();
    headers.insert("Access-Control-Allow-Origin", HeaderValue::from_static("*"));
    headers.insert(
        "Access-Control-Allow-Methods",
        HeaderValue::from_static("GET, POST, PUT, DELETE, OPTIONS"),
    );
    headers.insert(
        "Access-Control-Allow-Headers",
        HeaderValue::from_static("Content-Type, Authorization"),
    );
    headers.insert("Access-Control-Max-Age", HeaderValue::from_static("3600"));

    response
}

================
File: ondc-bap/src/presentation/middleware/error_handling.rs
================
//! Error handling middleware for ONDC BAP Server

use axum::{
    extract::Request,
    http::StatusCode,
    middleware::Next,
    response::{Json, Response},
};
use serde::Serialize;
use tracing::error;

/// Error response structure
#[derive(Serialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub status_code: u16,
}

/// Error handling middleware
pub async fn error_handling_middleware(request: Request, next: Next) -> Response {
    let response = next.run(request).await;

    // If the response is already an error, return it as is
    if response.status().is_client_error() || response.status().is_server_error() {
        return response;
    }

    response
}

/// Convert internal errors to HTTP responses
pub fn handle_error(
    err: Box<dyn std::error::Error + Send + Sync>,
) -> (StatusCode, Json<ErrorResponse>) {
    error!("Unhandled error: {}", err);

    let (status_code, message) = match err.downcast_ref::<crate::error::AppError>() {
        Some(app_error) => match app_error {
            crate::error::AppError::Config(_) => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Configuration error")
            }
            crate::error::AppError::Crypto(_) => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Cryptographic error")
            }
            crate::error::AppError::Validation(_) => (StatusCode::BAD_REQUEST, "Validation error"),
            crate::error::AppError::Registry(_) => (StatusCode::BAD_GATEWAY, "Registry error"),
            crate::error::AppError::Http(_) => (StatusCode::BAD_GATEWAY, "HTTP error"),
            crate::error::AppError::Internal(_) => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal error")
            }
        },
        None => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error"),
    };

    (
        status_code,
        Json(ErrorResponse {
            error: "server_error".to_string(),
            message: message.to_string(),
            status_code: status_code.as_u16(),
        }),
    )
}

================
File: ondc-bap/src/presentation/middleware/logging.rs
================
//! Logging middleware for ONDC BAP Server

use axum::{extract::Request, middleware::Next, response::Response};
use std::time::Instant;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

/// Logging middleware for request/response logging
pub async fn logging_middleware(request: Request, next: Next) -> Response {
    let start = Instant::now();
    let request_id = Uuid::new_v4();

    // Log request details
    info!(
        request_id = %request_id,
        method = %request.method(),
        uri = %request.uri(),
        "Incoming request"
    );

    // Process request
    let response = next.run(request).await;

    // Calculate duration
    let duration = start.elapsed();

    // Log response details
    let status = response.status();
    let status_code = status.as_u16();

    match status_code {
        200..=299 => {
            info!(
                request_id = %request_id,
                status = %status_code,
                duration_ms = duration.as_millis(),
                "Request completed successfully"
            );
        }
        300..=399 => {
            debug!(
                request_id = %request_id,
                status = %status_code,
                duration_ms = duration.as_millis(),
                "Request redirected"
            );
        }
        400..=499 => {
            warn!(
                request_id = %request_id,
                status = %status_code,
                duration_ms = duration.as_millis(),
                "Client error"
            );
        }
        500..=599 => {
            error!(
                request_id = %request_id,
                status = %status_code,
                duration_ms = duration.as_millis(),
                "Server error"
            );
        }
        _ => {
            debug!(
                request_id = %request_id,
                status = %status_code,
                duration_ms = duration.as_millis(),
                "Request completed"
            );
        }
    }

    response
}

================
File: ondc-bap/src/presentation/middleware/rate_limiting.rs
================
//! Rate limiting middleware for ONDC BAP Server

use axum::{extract::Request, http::StatusCode, middleware::Next, response::Response};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use tracing::warn;

/// Rate limiter for per-IP limiting
#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window_duration: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window_duration: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window_duration,
        }
    }

    pub fn check_rate_limit(&self, client_ip: &str) -> bool {
        let mut requests = self.requests.lock().unwrap();
        let now = Instant::now();

        let client_requests = requests
            .entry(client_ip.to_string())
            .or_insert_with(Vec::new);

        // Remove old requests outside the window
        client_requests
            .retain(|&request_time| now.duration_since(request_time) < self.window_duration);

        if client_requests.len() >= self.max_requests {
            false
        } else {
            client_requests.push(now);
            true
        }
    }
}

/// Extract client IP from request headers
fn extract_client_ip(request: &Request) -> String {
    // Check for forwarded headers first (for requests behind proxies)
    if let Some(forwarded_for) = request.headers().get("x-forwarded-for") {
        if let Ok(forwarded_for_str) = forwarded_for.to_str() {
            // Take the first IP in the chain (original client IP)
            if let Some(first_ip) = forwarded_for_str.split(',').next() {
                return first_ip.trim().to_string();
            }
        }
    }

    // Check for real IP header
    if let Some(real_ip) = request.headers().get("x-real-ip") {
        if let Ok(real_ip_str) = real_ip.to_str() {
            return real_ip_str.to_string();
        }
    }

    // Check for CF-Connecting-IP (Cloudflare)
    if let Some(cf_ip) = request.headers().get("cf-connecting-ip") {
        if let Ok(cf_ip_str) = cf_ip.to_str() {
            return cf_ip_str.to_string();
        }
    }

    // Fallback to remote address if available
    if let Some(remote_addr) = request.extensions().get::<std::net::SocketAddr>() {
        return remote_addr.ip().to_string();
    }

    // Final fallback
    "unknown".to_string()
}

/// Rate limiting middleware (per-IP)
pub async fn rate_limiting_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // Extract client IP from request
    let client_ip = extract_client_ip(&request);

    // Create rate limiter (in production, this would be shared state)
    let rate_limiter = RateLimiter::new(100, Duration::from_secs(60)); // 100 requests per minute per IP

    if !rate_limiter.check_rate_limit(&client_ip) {
        warn!("Rate limit exceeded for IP: {}", client_ip);
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }

    Ok(next.run(request).await)
}

/// Rate limiting middleware with custom limits (per-IP)
pub async fn rate_limiting_middleware_with_limits(
    max_requests: usize,
    window_duration: Duration,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let client_ip = extract_client_ip(&request);
    let rate_limiter = RateLimiter::new(max_requests, window_duration);

    if !rate_limiter.check_rate_limit(&client_ip) {
        warn!("Rate limit exceeded for IP: {}", client_ip);
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }

    Ok(next.run(request).await)
}

/// Rate limiting middleware with different limits for different IP ranges
pub async fn adaptive_rate_limiting_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let client_ip = extract_client_ip(&request);

    // Define different rate limits based on IP characteristics
    let (max_requests, window_duration) = if client_ip == "127.0.0.1" || client_ip == "::1" {
        // Localhost gets higher limits for development
        (1000, Duration::from_secs(60))
    } else if client_ip.starts_with("10.")
        || client_ip.starts_with("192.168.")
        || client_ip.starts_with("172.")
    {
        // Private network IPs get moderate limits
        (200, Duration::from_secs(60))
    } else {
        // Public IPs get standard limits
        (100, Duration::from_secs(60))
    };

    let rate_limiter = RateLimiter::new(max_requests, window_duration);

    if !rate_limiter.check_rate_limit(&client_ip) {
        warn!(
            "Rate limit exceeded for IP: {} (limit: {}/min)",
            client_ip, max_requests
        );
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }

    Ok(next.run(request).await)
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::{HeaderMap, Request};

    #[test]
    fn test_extract_client_ip_from_forwarded_for() {
        let mut headers = HeaderMap::new();
        headers.insert("x-forwarded-for", "192.168.1.1, 10.0.0.1".parse().unwrap());

        let mut request = Request::new(Body::empty());
        *request.headers_mut() = headers;

        let client_ip = extract_client_ip(&request);
        assert_eq!(client_ip, "192.168.1.1");
    }

    #[test]
    fn test_extract_client_ip_from_real_ip() {
        let mut headers = HeaderMap::new();
        headers.insert("x-real-ip", "203.0.113.1".parse().unwrap());

        let mut request = Request::new(Body::empty());
        *request.headers_mut() = headers;

        let client_ip = extract_client_ip(&request);
        assert_eq!(client_ip, "203.0.113.1");
    }

    #[test]
    fn test_extract_client_ip_from_cloudflare() {
        let mut headers = HeaderMap::new();
        headers.insert("cf-connecting-ip", "198.51.100.1".parse().unwrap());

        let mut request = Request::new(Body::empty());
        *request.headers_mut() = headers;

        let client_ip = extract_client_ip(&request);
        assert_eq!(client_ip, "198.51.100.1");
    }

    #[test]
    fn test_extract_client_ip_fallback() {
        let request = Request::new(Body::empty());
        let client_ip = extract_client_ip(&request);
        assert_eq!(client_ip, "unknown");
    }

    #[test]
    fn test_rate_limiter_basic() {
        let rate_limiter = RateLimiter::new(2, Duration::from_secs(1));

        // First two requests should succeed
        assert!(rate_limiter.check_rate_limit("192.168.1.1"));
        assert!(rate_limiter.check_rate_limit("192.168.1.1"));

        // Third request should fail
        assert!(!rate_limiter.check_rate_limit("192.168.1.1"));

        // Different IP should still work
        assert!(rate_limiter.check_rate_limit("192.168.1.2"));
    }

    #[test]
    fn test_rate_limiter_window_expiry() {
        let rate_limiter = RateLimiter::new(1, Duration::from_millis(100));

        // First request should succeed
        assert!(rate_limiter.check_rate_limit("192.168.1.1"));

        // Second request should fail immediately
        assert!(!rate_limiter.check_rate_limit("192.168.1.1"));

        // Wait for window to expire
        std::thread::sleep(Duration::from_millis(150));

        // Should succeed again
        assert!(rate_limiter.check_rate_limit("192.168.1.1"));
    }
}

================
File: ondc-bap/src/presentation/middleware/security.rs
================
//! Security middleware for ONDC BAP Server

use axum::{extract::Request, http::HeaderValue, middleware::Next, response::Response};

/// Security headers middleware
pub async fn security_headers_middleware(request: Request, next: Next) -> Response {
    let mut response = next.run(request).await;

    let headers = response.headers_mut();

    // Add security headers
    headers.insert(
        "X-Content-Type-Options",
        HeaderValue::from_static("nosniff"),
    );
    headers.insert("X-Frame-Options", HeaderValue::from_static("DENY"));
    headers.insert(
        "X-XSS-Protection",
        HeaderValue::from_static("1; mode=block"),
    );
    headers.insert(
        "Referrer-Policy",
        HeaderValue::from_static("strict-origin-when-cross-origin"),
    );
    headers.insert(
        "Content-Security-Policy",
        HeaderValue::from_static(
            "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'",
        ),
    );
    headers.insert(
        "Strict-Transport-Security",
        HeaderValue::from_static("max-age=31536000; includeSubDomains"),
    );

    response
}

/// Request validation middleware
pub async fn request_validation_middleware(request: Request, next: Next) -> Response {
    // TODO: Implement request validation
    // - Validate content length
    // - Check for malicious patterns
    // - Validate content type

    next.run(request).await
}

================
File: ondc-bap/src/services/challenge_service.rs
================
//! Challenge processing service for ONDC BAP Server
//!
//! This service handles the processing of ONDC onboarding challenges
//! received in the on_subscribe endpoint. It performs X25519 key exchange
//! with ONDC public keys and AES-256-ECB decryption of challenges.

use std::sync::Arc;
use tracing::{info, error, instrument};
use serde::{Deserialize, Serialize};

use crate::config::BAPConfig;
use crate::services::KeyManagementService;
use ondc_crypto_algorithms::decrypt_aes256_ecb;
use ondc_crypto_formats::decode_signature;

/// Challenge processing error types
#[derive(Debug, thiserror::Error)]
pub enum ChallengeError {
    #[error("Invalid challenge format: {0}")]
    InvalidChallenge(String),

    #[error("Key exchange failed: {0}")]
    KeyExchangeError(String),

    #[error("Decryption failed: {0}")]
    DecryptionError(String),

    #[error("ONDC public key error: {0}")]
    ONDCKeyError(String),

    #[error("Key manager error: {0}")]
    KeyManagerError(String),

    #[error("Configuration error: {0}")]
    ConfigError(String),
}

/// On-subscribe request from ONDC registry
#[derive(Debug, Deserialize)]
pub struct OnSubscribeRequest {
    pub subscriber_id: String,
    pub challenge: String,
}

/// On-subscribe response to ONDC registry
#[derive(Debug, Serialize)]
pub struct OnSubscribeResponse {
    pub answer: String,
}

/// Challenge processing service
pub struct ChallengeService {
    key_manager: Arc<KeyManagementService>,
    config: Arc<BAPConfig>,
}

impl ChallengeService {
    /// Create a new challenge service
    pub fn new(key_manager: Arc<KeyManagementService>, config: Arc<BAPConfig>) -> Self {
        Self { key_manager, config }
    }

    /// Process an on_subscribe challenge
    ///
    /// This method:
    /// 1. Decodes the base64-encoded challenge
    /// 2. Generates a shared secret using X25519 key exchange
    /// 3. Decrypts the challenge using AES-256-ECB
    /// 4. Returns the decrypted answer
    #[instrument(skip(self, request), fields(subscriber_id = %request.subscriber_id))]
    pub async fn process_challenge(
        &self,
        request: OnSubscribeRequest,
    ) -> Result<OnSubscribeResponse, ChallengeError> {
        info!("Processing on_subscribe challenge");

        // Validate subscriber ID matches configuration
        if request.subscriber_id != self.config.ondc.subscriber_id {
            return Err(ChallengeError::ConfigError(format!(
                "Subscriber ID mismatch: expected {}, got {}",
                self.config.ondc.subscriber_id, request.subscriber_id
            )));
        }

        // Decode the base64-encoded challenge
        let encrypted_challenge = decode_signature(&request.challenge)
            .map_err(|e| ChallengeError::InvalidChallenge(format!("Failed to decode challenge: {}", e)))?;

        // Generate shared secret using X25519
        let shared_secret = self.generate_shared_secret().await?;

        // Decrypt challenge using AES-256-ECB
        let mut decrypted_bytes = decrypt_aes256_ecb(&encrypted_challenge, &shared_secret)
            .map_err(|e| ChallengeError::DecryptionError(format!("AES decryption failed: {}", e)))?;

        // Remove PKCS#7 padding
        if let Some(&padding_len) = decrypted_bytes.last() {
            if padding_len > 0 && padding_len <= 16 {
                let padding_start = decrypted_bytes.len().saturating_sub(padding_len as usize);
                let padding_bytes = &decrypted_bytes[padding_start..];
                
                // Verify padding is correct (all bytes should equal padding_len)
                if padding_bytes.iter().all(|&b| b == padding_len) {
                    decrypted_bytes.truncate(padding_start);
                    info!("Removed {} padding bytes", padding_len);
                } else {
                    info!("Invalid padding detected, keeping original data");
                }
            }
        }

        // Convert decrypted bytes to string
        let answer = String::from_utf8(decrypted_bytes)
            .map_err(|e| ChallengeError::DecryptionError(format!("Invalid UTF-8 in decrypted challenge: {}", e)))?;

        // Trim any whitespace that might be present
        let answer = answer.trim().to_string();

        info!("Challenge processed successfully");
        Ok(OnSubscribeResponse { answer })
    }

    /// Generate shared secret using X25519 key exchange with ONDC public key
    async fn generate_shared_secret(&self) -> Result<Vec<u8>, ChallengeError> {
        // Get encryption key from key manager
        let encryption_key = self.key_manager.get_encryption_key().await
            .map_err(|e| ChallengeError::KeyManagerError(e.to_string()))?;

        // Get ONDC public key for current environment
        let ondc_public_key = self.config.ondc.ondc_public_key_bytes()
            .map_err(|e| ChallengeError::ONDCKeyError(e.to_string()))?;

        // Perform X25519 key exchange
        let shared_secret = encryption_key.diffie_hellman(&ondc_public_key)
            .map_err(|e| ChallengeError::KeyExchangeError(e.to_string()))?;

        Ok(shared_secret.to_vec())
    }
}

================
File: ondc-bap/src/services/site_verification_service.rs
================
//! Site Verification Service for ONDC BAP Server
//!
//! This service handles ONDC site verification requirements:
//! - Generate unique request IDs
//! - Sign request IDs using Ed25519 without hashing
//! - Generate HTML verification pages
//! - Store request IDs for later verification

use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;
use tracing::{error, info, instrument, warn};
use uuid::Uuid;

use crate::config::BAPConfig;
use crate::services::key_management_service::KeyManagementError;
use crate::services::KeyManagementService;
use ondc_crypto_formats::encode_signature;
use ondc_crypto_traits::ONDCCryptoError;

/// Site verification service error types
#[derive(Debug, thiserror::Error)]
pub enum SiteVerificationError {
    #[error("Key management error: {0}")]
    KeyManagement(#[from] KeyManagementError),

    #[error("Crypto error: {0}")]
    Crypto(#[from] ONDCCryptoError),

    #[error("Request ID generation failed: {0}")]
    RequestIdGeneration(String),

    #[error("HTML generation failed: {0}")]
    HtmlGeneration(String),

    #[error("Request ID not found: {0}")]
    RequestIdNotFound(String),

    #[error("Request ID expired: {0}")]
    RequestIdExpired(String),
}


/// Site verification service
pub struct SiteVerificationService {
    key_manager: Arc<KeyManagementService>,
    config: Arc<BAPConfig>,
    request_ids: Arc<RwLock<Option<String>>>,
    ttl: Duration,
}

impl SiteVerificationService {
    /// Create a new site verification service
    pub fn new(key_manager: Arc<KeyManagementService>, config: Arc<BAPConfig>) -> Self {
        Self {
            key_manager,
            config,
            request_ids: Arc::new(RwLock::new(None)),
            ttl: Duration::from_secs(3600), // 1 hour TTL
        }
    }

    /// Generate site verification HTML content
    #[instrument(skip(self))]
    pub async fn generate_site_verification(&self) -> Result<String, SiteVerificationError> {
        self.generate_site_verification_with_request_id(None).await
    }

    /// Generate site verification HTML content with optional request ID
    #[instrument(skip(self))]
    pub async fn generate_site_verification_with_request_id(&self, request_id: Option<&str>) -> Result<String, SiteVerificationError> {
        info!("Generating site verification content");

        // Use provided request ID or generate a new one
        let request_id = match request_id {
            Some(id) => {
                info!("Using provided request_id: {}", id);
                id.to_string()
            }
            None => {
                let id = self.generate_request_id()?;
                info!("Generated new request_id: {}", id);
                // Store the request ID
                self.store_request_id(&id).await;
                id
            }
        };

        // Sign the request ID using Ed25519 without hashing
        let signed_content = self.sign_request_id(&request_id).await?;

        // Generate HTML content
        let html_content = self.generate_html_template(&signed_content)?;

        info!(
            "Site verification content generated successfully for request_id: {}",
            request_id
        );
        Ok(html_content)
    }

    /// Get the current stored request ID
    #[instrument(skip(self))]
    pub async fn get_current_request_id(&self) -> Option<String> {
        let request_ids = self.request_ids.read().await;
        request_ids.clone()
    }

    /// Verify a request ID exists and is valid
    #[instrument(skip(self), fields(request_id = %request_id))]
    pub async fn verify_request_id(&self, request_id: &str) -> Result<bool, SiteVerificationError> {
        let stored_request_id = self.request_ids.read().await;

        if let Some(stored) = stored_request_id.as_ref() {
            if stored == request_id {
                info!("Request ID verified successfully: {}", request_id);
                Ok(true)
            } else {
                warn!("Request ID mismatch: expected {}, got {}", stored, request_id);
                Err(SiteVerificationError::RequestIdNotFound(
                    request_id.to_string(),
                ))
            }
        } else {
            warn!("No request ID stored");
            Err(SiteVerificationError::RequestIdNotFound(
                request_id.to_string(),
            ))
        }
    }

    /// Clear the stored request ID
    #[instrument(skip(self))]
    pub async fn clear_request_id(&self) {
        let mut request_ids = self.request_ids.write().await;
        *request_ids = None;
        info!("Cleared stored request ID");
    }

    /// Generate a unique request ID
    fn generate_request_id(&self) -> Result<String, SiteVerificationError> {
        let request_id = Uuid::new_v4().to_string();
        info!("Generated request ID: {}", request_id);
        Ok(request_id)
    }

    /// Sign a request ID using Ed25519 without hashing
    #[instrument(skip(self, request_id))]
    async fn sign_request_id(&self, request_id: &str) -> Result<String, SiteVerificationError> {
        info!("Signing request ID with Ed25519");

        // Get the signing key
        let signer = self
            .key_manager
            .get_signing_key()
            .await
            .map_err(|e| SiteVerificationError::KeyManagement(e))?;

        // Sign the request ID without hashing (critical ONDC requirement)
        let signature = signer
            .sign_strict(request_id.as_bytes())
            .map_err(|e| SiteVerificationError::Crypto(e))?;

        // Encode the signature as base64
        let signed_content = encode_signature(&signature);

        info!("Request ID signed successfully");
        Ok(signed_content)
    }

    /// Store a request ID
    #[instrument(skip(self, request_id))]
    pub async fn store_request_id(&self, request_id: &str) {
        let mut request_ids = self.request_ids.write().await;
        *request_ids = Some(request_id.to_string());

        info!("Stored request ID: {}", request_id);
    }

    /// Generate HTML template with signed content
    fn generate_html_template(
        &self,
        signed_content: &str,
    ) -> Result<String, SiteVerificationError> {
        // Escape the signed content for HTML
        let escaped_content: std::borrow::Cow<'_, str> = html_escape::encode_text(signed_content);

        let html_content = format!(
            r#"
<html>
  <head>
    <meta
      name="ondc-site-verification"
      content="{}"
    />
    <title>ONDC Site Verification</title>
  </head>
  <body>
    <h1>ONDC Site Verification Page</h1>
    <p>This page is used for ONDC network participant verification.</p>
    <p>Generated at: {}</p>
  </body>
</html>"#,
            escaped_content,
            chrono::Utc::now().to_rfc3339()
        );

        Ok(html_content)
    }

    /// Set custom TTL for request IDs
    pub fn set_ttl(&mut self, ttl: Duration) {
        self.ttl = ttl;
        info!("Updated request ID TTL to {:?}", ttl);
    }

    /// Get current TTL
    pub fn get_ttl(&self) -> Duration {
        self.ttl
    }

    /// Get statistics about stored request ID
    pub async fn get_stats(&self) -> RequestIdStats {
        let request_ids = self.request_ids.read().await;
        let active_count = if request_ids.is_some() { 1 } else { 0 };

        RequestIdStats {
            total_count: active_count,
            active_count,
            expired_count: 0,
            ttl_seconds: self.ttl.as_secs(),
        }
    }
}

/// Statistics about stored request IDs
#[derive(Debug, Clone)]
pub struct RequestIdStats {
    pub total_count: usize,
    pub active_count: usize,
    pub expired_count: usize,
    pub ttl_seconds: u64,
}

impl Clone for SiteVerificationService {
    fn clone(&self) -> Self {
        Self {
            key_manager: self.key_manager.clone(),
            config: self.config.clone(),
            request_ids: self.request_ids.clone(),
            ttl: self.ttl,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::app_config::{BAPConfig, KeyConfig, SecurityConfig, ServerConfig};
    use crate::config::ondc_config::{Environment, ONDCConfig};

    fn create_test_config() -> BAPConfig {
        BAPConfig {
            server: ServerConfig::default(),
            ondc: ONDCConfig::new(Environment::Staging, "test.example.com".to_string()),
            keys: KeyConfig {
                signing_private_key: "dGVzdF9zaWduaW5nX3ByaXZhdGVfa2V5XzMyX2J5dGVzX2xvbmc="
                    .to_string(), // 32 bytes base64
                encryption_private_key: "dGVzdF9lbmNyeXB0aW9uX3ByaXZhdGVfa2V5XzMyX2J5dGVz"
                    .to_string(), // 32 bytes base64
                unique_key_id: "test_key_1".to_string(),
            },
            security: SecurityConfig::default(),
        }
    }

    #[tokio::test]
    async fn test_site_verification_service_creation() {
        let config = create_test_config();
        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .unwrap(),
        );
        let config = Arc::new(config);

        let service = SiteVerificationService::new(key_manager, config);
        assert_eq!(service.get_ttl(), Duration::from_secs(3600));
    }

    #[tokio::test]
    async fn test_request_id_generation() {
        let config = create_test_config();
        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .unwrap(),
        );
        let config = Arc::new(config);

        let service = SiteVerificationService::new(key_manager, config);

        let request_id = service.generate_request_id().unwrap();
        assert!(!request_id.is_empty());
        assert_eq!(request_id.len(), 36); // UUID v4 length
    }

    #[tokio::test]
    async fn test_html_template_generation() {
        let config = create_test_config();
        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .unwrap(),
        );
        let config = Arc::new(config);

        let service = SiteVerificationService::new(key_manager, config);

        let test_signature = "dGVzdF9zaWduYXR1cmVfNjRfYnl0ZXNfbG9uZ19iYXNlNjRfZW5jb2RlZA==";
        let html = service.generate_html_template(test_signature).unwrap();

        assert!(html.contains("ondc-site-verification"));
        assert!(html.contains(test_signature));
        assert!(html.contains("<html>"));
        assert!(html.contains("</html>"));
    }

    #[tokio::test]
    async fn test_request_id_storage_and_verification() {
        let config = create_test_config();
        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .unwrap(),
        );
        let config = Arc::new(config);

        let service = SiteVerificationService::new(key_manager, config);

        // Generate and store a request ID
        let request_id = service.generate_request_id().unwrap();
        
        // Store manually for testing
        {
            let mut request_ids = service.request_ids.write().await;
            *request_ids = Some(request_id.clone());
        }

        // Get the current request ID
        let stored_request_id = service.get_current_request_id().await;
        assert_eq!(stored_request_id, Some(request_id));
    }

    #[tokio::test]
    async fn test_request_id_retrieval() {
        let config = create_test_config();
        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .unwrap(),
        );
        let config = Arc::new(config);

        let service = SiteVerificationService::new(key_manager, config);

        // Initially no request ID
        let stored_request_id = service.get_current_request_id().await;
        assert_eq!(stored_request_id, None);

        // Generate and store a request ID
        let request_id = service.generate_request_id().unwrap();
        {
            let mut request_ids = service.request_ids.write().await;
            *request_ids = Some(request_id.clone());
        }

        // Should now return the stored ID
        let stored_request_id = service.get_current_request_id().await;
        assert_eq!(stored_request_id, Some(request_id));
    }
}

================
File: ondc-bap/src/lib.rs
================
//! ONDC BAP (Beckn Application Platform) Server
//!
//! A production-ready ONDC BAP server implementation in Rust that handles
//! ONDC network participant onboarding and provides required endpoints for
//! registry integration.
//!
//! ## Features
//!
//! - **ONDC Protocol Compliance**: Full implementation of ONDC registry APIs
//! - **Cryptographic Security**: Built on secure crypto foundation
//! - **Production Ready**: Comprehensive logging, monitoring, and error handling
//! - **Layered Architecture**: Clean separation of concerns with Axum web framework
//!
//! ## Quick Start
//!
//! ```rust
//! use ondc_bap::BAPServer;
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let server = BAPServer::new().await?;
//!     Ok(())
//! }
//! ```

pub mod config;
pub mod error;
pub mod infrastructure;
pub mod presentation;
pub mod services;

// Re-export main types for convenience
pub use config::BAPConfig;
pub use error::AppError;
pub use presentation::BAPServer;

/// Result type for BAP operations
pub type Result<T> = std::result::Result<T, error::AppError>;

/// Application version
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Default configuration file path
pub const DEFAULT_CONFIG_PATH: &str = "config/";

/// Default server port
pub const DEFAULT_PORT: u16 = 8080;

/// Default server host
pub const DEFAULT_HOST: &str = "0.0.0.0";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_constant() {
        assert!(!VERSION.is_empty());
    }

    #[test]
    fn test_default_constants() {
        assert_eq!(DEFAULT_PORT, 8080);
        assert_eq!(DEFAULT_HOST, "0.0.0.0");
        assert!(!DEFAULT_CONFIG_PATH.is_empty());
    }
}

================
File: ondc-bap/.env
================
ONDC_ENV=staging

================
File: ondc-crypto-algorithms/src/blake2.rs
================
//! BLAKE2 hashing implementation.

use ondc_crypto_traits::{Hasher, ONDCCryptoError};

/// BLAKE2 hasher implementation.
pub struct Blake2Hasher;

impl Blake2Hasher {
    /// Create a new BLAKE2 hasher.
    pub fn new() -> Self {
        Self
    }
}

impl Hasher for Blake2Hasher {
    type Error = ONDCCryptoError;
    type Output = Vec<u8>;

    fn hash(&self, _data: &[u8]) -> Result<Self::Output, Self::Error> {
        // TODO: Implement BLAKE2 hashing
        todo!("BLAKE2 hashing implementation")
    }

    fn hash_with_length(&self, _data: &[u8], _length: usize) -> Result<Self::Output, Self::Error> {
        // TODO: Implement BLAKE2 hashing with custom length
        todo!("BLAKE2 hashing with custom length implementation")
    }
}

================
File: ondc-crypto-cli/examples/demo.sh
================
#!/bin/bash

echo "=== ONDC Crypto CLI Demo ==="
echo

# Generate Ed25519 keys
echo "1. Generating Ed25519 key pair..."
cargo run --package ondc-crypto-cli -- generate ed25519 --json > ed25519.keys.json
echo "Keys saved to ed25519.keys.json"
echo

# Generate X25519 keys
echo "2. Generating X25519 key pair..."
cargo run --package ondc-crypto-cli -- generate x25519 --json > x25519.keys.json
echo "Keys saved to x25519.keys.json"
echo

# Extract keys for signing
PRIVATE_KEY=$(jq -r .private_key ed25519.keys.json)
PUBLIC_KEY=$(jq -r .public_key ed25519.keys.json)

echo "3. Signing a message..."
MESSAGE="Hello, ONDC World!"
echo "Message: $MESSAGE"
SIGNATURE=$(cargo run --package ondc-crypto-cli -- sign --private-key "$PRIVATE_KEY" --data "$MESSAGE")
echo "Signature: $SIGNATURE"
echo

echo "4. Verifying the signature..."
cargo run --package ondc-crypto-cli -- verify --public-key "$PUBLIC_KEY" --signature "$SIGNATURE" --data "$MESSAGE"
echo

echo "5. Testing invalid signature..."
MODIFIED_MESSAGE="Hello, ONDC World! (modified)"
echo "Modified message: $MODIFIED_MESSAGE"
cargo run --package ondc-crypto-cli -- verify --public-key "$PUBLIC_KEY" --signature "$SIGNATURE" --data "$MODIFIED_MESSAGE" || echo "Expected failure for modified message"
echo

echo "6. Different output formats..."
echo "Base64 format:"
cargo run --package ondc-crypto-cli -- generate ed25519 --format base64 | head -2
echo

echo "Hex format:"
cargo run --package ondc-crypto-cli -- generate ed25519 --format hex | head -2
echo

# Extract X25519 private key for challenge generation
X25519_PRIVATE_KEY=$(jq -r .private_key x25519.keys.json)

echo "7. Generating ONDC test challenge..."
echo "Using default test data:"
cargo run --package ondc-crypto-cli -- challenge --private-key "$X25519_PRIVATE_KEY" --environment staging
echo

echo "8. Generating custom challenge data..."
CUSTOM_CHALLENGE="Custom ONDC challenge for testing"
echo "Custom data: $CUSTOM_CHALLENGE"
cargo run --package ondc-crypto-cli -- challenge --private-key "$X25519_PRIVATE_KEY" --data "$CUSTOM_CHALLENGE" --environment staging
echo

echo "9. Generating challenge in JSON format..."
cargo run --package ondc-crypto-cli -- challenge --private-key "$X25519_PRIVATE_KEY" --data "$CUSTOM_CHALLENGE" --environment staging --json > challenge.json
echo "Challenge saved to challenge.json"
echo

echo "10. Testing different ONDC environments..."
echo "Pre-production environment:"
cargo run --package ondc-crypto-cli -- challenge --private-key "$X25519_PRIVATE_KEY" --data "Pre-prod test" --environment pre-prod
echo

echo "Production environment:"
cargo run --package ondc-crypto-cli -- challenge --private-key "$X25519_PRIVATE_KEY" --data "Production test" --environment production
echo

echo "11. Challenge testing workflow..."
echo "Generated challenge can be used to test BAP server /on_subscribe endpoint:"
echo
CHALLENGE_B64=$(jq -r .encrypted_challenge challenge.json)
echo "curl -X POST http://localhost:8080/on_subscribe \\"
echo "  -H \"Content-Type: application/json\" \\"
echo "  -d '{"
echo "    \"subscriber_id\": \"test.example.com\","
echo "    \"challenge\": \"$CHALLENGE_B64\""
echo "  }'"
echo

echo "=== Demo Complete ==="

================
File: ondc-crypto-traits/src/error.rs
================
//! Error types for ONDC cryptographic operations.

use thiserror::Error;

/// Main error type for ONDC cryptographic operations.
#[derive(Error, Debug)]
pub enum ONDCCryptoError {
    /// Signature verification failed
    #[error("signature verification failed")]
    VerificationFailed,

    /// Invalid key length
    #[error("invalid key length: expected {expected}, got {got}")]
    InvalidKeyLength { expected: usize, got: usize },

    /// Encoding error
    #[error("encoding error: {0}")]
    EncodingError(String),

    /// Invalid timestamp
    #[error("invalid timestamp: {timestamp}")]
    InvalidTimestamp { timestamp: u64 },

    /// ONDC protocol error
    #[error("ONDC protocol error: {code} - {message}")]
    ProtocolError { code: u32, message: String },

    /// Configuration error
    #[error("configuration error: {0}")]
    ConfigError(String),
}

impl ONDCCryptoError {
    /// Create a policy error (ONDC error code 132)
    pub fn policy_error(message: impl Into<String>) -> Self {
        Self::ProtocolError {
            code: 132,
            message: message.into(),
        }
    }

    /// Create a domain error (ONDC error code 129)
    pub fn domain_error(message: impl Into<String>) -> Self {
        Self::ProtocolError {
            code: 129,
            message: message.into(),
        }
    }
}

================
File: ondc-crypto-traits/src/types.rs
================
//! Core types and constants for ONDC cryptographic operations.
//!
//! This module defines the fundamental types, constants, and type aliases used
//! throughout the ONDC crypto SDK. These provide type safety and clarity for
//! cryptographic operations.

use std::marker::PhantomData;

// ============================================================================
// Cryptographic Constants
// ============================================================================

/// Ed25519 signature length in bytes
pub const ED25519_SIGNATURE_LENGTH: usize = 64;

/// Ed25519 public key length in bytes
pub const ED25519_PUBLIC_KEY_LENGTH: usize = 32;

/// Ed25519 private key length in bytes
pub const ED25519_PRIVATE_KEY_LENGTH: usize = 32;

/// Ed25519 key pair length in bytes (private + public)
pub const ED25519_KEYPAIR_LENGTH: usize = 64;

/// X25519 public key length in bytes
pub const X25519_PUBLIC_KEY_LENGTH: usize = 32;

/// X25519 private key length in bytes
pub const X25519_PRIVATE_KEY_LENGTH: usize = 32;

/// BLAKE2b maximum output length in bytes
pub const BLAKE2B_MAX_OUTPUT_LENGTH: usize = 64;

/// BLAKE2b default output length for ONDC (512 bits = 64 bytes)
pub const BLAKE2B_DEFAULT_OUTPUT_LENGTH: usize = 64;

/// Default timestamp tolerance in seconds (5 minutes)
pub const DEFAULT_TIMESTAMP_TOLERANCE: u64 = 300;

/// Default signature expiry time in seconds (1 hour)
pub const DEFAULT_SIGNATURE_EXPIRY: u64 = 3600;

// ============================================================================
// Type Aliases
// ============================================================================

/// Ed25519 signature type
pub type Ed25519Signature = [u8; ED25519_SIGNATURE_LENGTH];

/// Ed25519 public key type
pub type Ed25519PublicKey = [u8; ED25519_PUBLIC_KEY_LENGTH];

/// Ed25519 private key type
pub type Ed25519PrivateKey = [u8; ED25519_PRIVATE_KEY_LENGTH];

/// Ed25519 key pair type
pub type Ed25519KeyPair = [u8; ED25519_KEYPAIR_LENGTH];

/// X25519 public key type
pub type X25519PublicKey = [u8; X25519_PUBLIC_KEY_LENGTH];

/// X25519 private key type
pub type X25519PrivateKey = [u8; X25519_PRIVATE_KEY_LENGTH];

/// BLAKE2b hash output type
pub type Blake2bHash = [u8; BLAKE2B_DEFAULT_OUTPUT_LENGTH];

// ============================================================================
// Newtype Wrappers for Type Safety
// ============================================================================

/// Newtype wrapper for Ed25519 signatures
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ed25519SignatureBytes(pub Ed25519Signature);

impl AsRef<[u8]> for Ed25519SignatureBytes {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl From<Ed25519Signature> for Ed25519SignatureBytes {
    fn from(signature: Ed25519Signature) -> Self {
        Self(signature)
    }
}

/// Newtype wrapper for Ed25519 public keys
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ed25519PublicKeyBytes(pub Ed25519PublicKey);

impl AsRef<[u8]> for Ed25519PublicKeyBytes {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl From<Ed25519PublicKey> for Ed25519PublicKeyBytes {
    fn from(key: Ed25519PublicKey) -> Self {
        Self(key)
    }
}

/// Newtype wrapper for Ed25519 private keys
#[derive(Debug, Clone)]
pub struct Ed25519PrivateKeyBytes(pub Ed25519PrivateKey);

impl AsRef<[u8]> for Ed25519PrivateKeyBytes {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl From<Ed25519PrivateKey> for Ed25519PrivateKeyBytes {
    fn from(key: Ed25519PrivateKey) -> Self {
        Self(key)
    }
}

/// Newtype wrapper for BLAKE2b hashes
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Blake2bHashBytes(pub Blake2bHash);

impl AsRef<[u8]> for Blake2bHashBytes {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl From<Blake2bHash> for Blake2bHashBytes {
    fn from(hash: Blake2bHash) -> Self {
        Self(hash)
    }
}

// ============================================================================
// ONDC-Specific Types
// ============================================================================

/// ONDC subscriber ID type
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SubscriberId(pub String);

impl SubscriberId {
    /// Create a new subscriber ID
    pub fn new(id: String) -> Result<Self, crate::ONDCCryptoError> {
        if id.is_empty() {
            return Err(crate::ONDCCryptoError::ConfigError(
                "subscriber_id cannot be empty".into(),
            ));
        }
        if id.len() > 255 {
            return Err(crate::ONDCCryptoError::ConfigError(
                "subscriber_id too long".into(),
            ));
        }
        Ok(Self(id))
    }
}

impl AsRef<str> for SubscriberId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for SubscriberId {
    fn from(id: String) -> Self {
        Self(id)
    }
}

/// ONDC unique key ID type
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UniqueKeyId(pub String);

impl UniqueKeyId {
    /// Create a new unique key ID
    pub fn new(id: String) -> Result<Self, crate::ONDCCryptoError> {
        if id.is_empty() {
            return Err(crate::ONDCCryptoError::ConfigError(
                "unique_key_id cannot be empty".into(),
            ));
        }
        Ok(Self(id))
    }
}

impl AsRef<str> for UniqueKeyId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for UniqueKeyId {
    fn from(id: String) -> Self {
        Self(id)
    }
}

/// ONDC authorization header parameters
#[derive(Debug, Clone)]
pub struct AuthorizationHeaderParams {
    /// Request body
    pub body: Vec<u8>,
    /// Subscriber ID
    pub subscriber_id: SubscriberId,
    /// Unique key ID
    pub unique_key_id: UniqueKeyId,
    /// Optional creation timestamp
    pub created: Option<u64>,
    /// Optional expiration timestamp
    pub expires: Option<u64>,
}

impl AuthorizationHeaderParams {
    /// Create new authorization header parameters
    pub fn new(body: Vec<u8>, subscriber_id: SubscriberId, unique_key_id: UniqueKeyId) -> Self {
        Self {
            body,
            subscriber_id,
            unique_key_id,
            created: None,
            expires: None,
        }
    }

    /// Set creation timestamp
    pub fn with_created(mut self, created: u64) -> Self {
        self.created = Some(created);
        self
    }

    /// Set expiration timestamp
    pub fn with_expires(mut self, expires: u64) -> Self {
        self.expires = Some(expires);
        self
    }
}

/// ONDC vLookup signature parameters
#[derive(Debug, Clone)]
pub struct VLookupSignatureParams {
    /// Country code
    pub country: String,
    /// Domain
    pub domain: String,
    /// Type field
    pub type_field: String,
    /// City
    pub city: String,
    /// Subscriber ID
    pub subscriber_id: SubscriberId,
}

impl VLookupSignatureParams {
    /// Create new vLookup signature parameters
    pub fn new(
        country: String,
        domain: String,
        type_field: String,
        city: String,
        subscriber_id: SubscriberId,
    ) -> Self {
        Self {
            country,
            domain,
            type_field,
            city,
            subscriber_id,
        }
    }
}

// ============================================================================
// Validation Helpers
// ============================================================================

/// Validate Ed25519 signature length
pub fn validate_ed25519_signature_length(signature: &[u8]) -> Result<(), crate::ONDCCryptoError> {
    if signature.len() != ED25519_SIGNATURE_LENGTH {
        return Err(crate::ONDCCryptoError::InvalidKeyLength {
            expected: ED25519_SIGNATURE_LENGTH,
            got: signature.len(),
        });
    }
    Ok(())
}

/// Validate Ed25519 public key length
pub fn validate_ed25519_public_key_length(key: &[u8]) -> Result<(), crate::ONDCCryptoError> {
    if key.len() != ED25519_PUBLIC_KEY_LENGTH {
        return Err(crate::ONDCCryptoError::InvalidKeyLength {
            expected: ED25519_PUBLIC_KEY_LENGTH,
            got: key.len(),
        });
    }
    Ok(())
}

/// Validate Ed25519 private key length
pub fn validate_ed25519_private_key_length(key: &[u8]) -> Result<(), crate::ONDCCryptoError> {
    if key.len() != ED25519_PRIVATE_KEY_LENGTH {
        return Err(crate::ONDCCryptoError::InvalidKeyLength {
            expected: ED25519_PRIVATE_KEY_LENGTH,
            got: key.len(),
        });
    }
    Ok(())
}

/// Validate BLAKE2b output length
pub fn validate_blake2b_output_length(length: usize) -> Result<(), crate::ONDCCryptoError> {
    if length == 0 || length > BLAKE2B_MAX_OUTPUT_LENGTH {
        return Err(crate::ONDCCryptoError::ConfigError(format!(
            "BLAKE2b output length must be 1-{} bytes",
            BLAKE2B_MAX_OUTPUT_LENGTH
        )));
    }
    Ok(())
}

/// Validate timestamp tolerance
pub fn validate_timestamp_tolerance(tolerance: u64) -> Result<(), crate::ONDCCryptoError> {
    if tolerance == 0 {
        return Err(crate::ONDCCryptoError::ConfigError(
            "timestamp tolerance cannot be zero".into(),
        ));
    }
    if tolerance > 86400 {
        return Err(crate::ONDCCryptoError::ConfigError(
            "timestamp tolerance cannot exceed 24 hours".into(),
        ));
    }
    Ok(())
}

// ============================================================================
// Phantom Types for Type Safety
// ============================================================================

/// Phantom type marker for Ed25519 algorithm
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Ed25519;

/// Phantom type marker for X25519 algorithm
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct X25519;

/// Phantom type marker for BLAKE2b algorithm
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Blake2b;

/// Generic key type with algorithm marker
#[derive(Debug, Clone)]
pub struct Key<A, T> {
    data: T,
    _algorithm: PhantomData<A>,
}

impl<A, T> Key<A, T> {
    /// Create a new key with algorithm marker
    pub fn new(data: T) -> Self {
        Self {
            data,
            _algorithm: PhantomData,
        }
    }

    /// Get the key data
    pub fn data(&self) -> &T {
        &self.data
    }

    /// Consume the key and return the data
    pub fn into_data(self) -> T {
        self.data
    }
}

impl<A, T> AsRef<T> for Key<A, T> {
    fn as_ref(&self) -> &T {
        &self.data
    }
}

/// Type alias for Ed25519 public key with algorithm marker
pub type Ed25519Key = Key<Ed25519, Ed25519PublicKeyBytes>;

/// Type alias for X25519 public key with algorithm marker
pub type X25519Key = Key<X25519, X25519PublicKey>;

================
File: ondc-crypto-traits/Cargo.toml
================
[package]
name = "ondc-crypto-traits"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
description = "Core traits and error types for ONDC cryptographic operations"
keywords.workspace = true
categories.workspace = true
readme.workspace = true

[dependencies]
thiserror = { workspace = true }
zeroize = { workspace = true }

================
File: Makefile
================
# ONDC Crypto SDK Development Makefile
# Provides convenient commands for development workflow

.PHONY: help build test check fmt clippy clean doc install-hooks run-staging run-production

# Default target
help:
	@echo "ONDC Crypto SDK Development Commands:"
	@echo ""
	@echo "Build Commands:"
	@echo "  build          - Build all crates in release mode"
	@echo "  build-dev      - Build all crates in debug mode"
	@echo "  check          - Check that code compiles without warnings"
	@echo ""
	@echo "Testing Commands:"
	@echo "  test           - Run all tests"
	@echo "  test-release   - Run tests in release mode"
	@echo "  test-coverage  - Run tests with coverage reporting"
	@echo ""
	@echo "Code Quality Commands:"
	@echo "  fmt            - Format code with rustfmt"
	@echo "  fmt-check      - Check code formatting"
	@echo "  clippy         - Run clippy linter"
	@echo "  audit          - Run security audit"
	@echo ""
	@echo "Documentation Commands:"
	@echo "  doc            - Generate documentation"
	@echo "  doc-open       - Generate and open documentation"
	@echo ""
	@echo "Setup Commands:"
	@echo "  install-hooks  - Install pre-commit hooks"
	@echo "  clean          - Clean build artifacts"
	@echo ""
	@echo "Run Commands:"
	@echo "  run-staging    - Run BAP server with staging config"
	@echo "  run-production - Run BAP server with production config"
	@echo ""

# Build commands
build:
	cargo build --release --all-targets --all-features

build-dev:
	cargo build --all-targets --all-features

check:
	cargo check --all-targets --all-features

# Testing commands
test:
	cargo test --all-targets --all-features

test-release:
	cargo test --release --all-targets --all-features

test-coverage:
	cargo install cargo-tarpaulin --no-default-features --features native-tls
	cargo tarpaulin --all-features --out Html --output-dir coverage

# Code quality commands
fmt:
	cargo fmt --all

fmt-check:
	cargo fmt --all -- --check

clippy:
	cargo clippy --all-targets --all-features -- -D warnings

audit:
	cargo audit

# Documentation commands
doc:
	cargo doc --all-features --no-deps

doc-open:
	cargo doc --all-features --no-deps --open

# Setup commands
install-hooks:
	pre-commit install
	pre-commit install --hook-type commit-msg

clean:
	cargo clean
	rm -rf coverage/
	rm -rf target/

# Development workflow commands
dev-setup: install-hooks
	@echo "Development environment setup complete!"
	@echo "Run 'make check' to verify everything is working."

pre-commit: fmt clippy test
	@echo "Pre-commit checks passed!"

ci: fmt-check clippy test audit
	@echo "CI checks passed!"

# Security and performance commands
bench:
	cargo bench --all-features

security-check: audit clippy
	@echo "Security checks completed!"

# Release preparation
release-prep: clean build test-release doc audit
	@echo "Release preparation completed!"

# Quick development cycle
dev: fmt clippy test
	@echo "Development cycle completed!" 

# Run commands with environment configuration
run-staging:
	cd ondc-bap && ONDC_ENV=staging cargo run

run-production:
	cd ondc-bap && ONDC_ENV=production cargo run

================
File: README.md
================
# ONDC BAP Server - Network Participant Implementation

[![Rust](https://img.shields.io/badge/rust-stable-brightgreen.svg)](https://www.rust-lang.org/)
[![License](https://img.shields.io/badge/license-MIT%2FApache--2.0-blue.svg)](LICENSE)
[![ONDC](https://img.shields.io/badge/ONDC-Network%20Participant-orange.svg)](https://ondc.org/)

A production-ready ONDC BAP (Beckn Application Platform) server implementation in Rust, designed to onboard as a Network Participant in the ONDC (Open Network for Digital Commerce) ecosystem. This server provides all required endpoints for ONDC registry integration and participant onboarding.

## ðŸŽ¯ Project Goal

**Primary Objective**: Successfully onboard as a Network Participant in the ONDC ecosystem by implementing a compliant BAP server that can:

- âœ… Generate and serve site verification pages with Ed25519 signatures
- âœ… Process ONDC challenge-response authentication via X25519 key exchange and AES-256-ECB decryption
- ðŸ”„ Register with ONDC registry using `/subscribe` API
- ðŸ”„ Support all participant types (Buyer App, Seller App, Buyer & Seller App)
- ðŸ”„ Provide administrative endpoints for registration management

## ðŸš€ Current Status

**Phase 2 - Crypto Foundation**: âœ… **COMPLETED**
- Ed25519 signing and verification with ONDC compliance
- X25519 key exchange with secure key handling
- AES-256-ECB decryption for challenge processing
- Base64 encoding utilities and key format conversions

**Phase 3 - BAP Server Core**: âœ… **COMPLETED**
- Axum web server with production-ready middleware stack
- Site verification endpoint (`/ondc-site-verification.html`)
- Challenge processing endpoint (`/on_subscribe`)
- Comprehensive configuration management
- Security headers, rate limiting, and error handling

**Phase 4 - ONDC Protocol**: ðŸš§ **IN PROGRESS**
- âœ… Site verification implementation
- âœ… Challenge processing implementation
- ðŸ”„ Registry client implementation (Next)
- ðŸ”„ Onboarding service orchestration

## ðŸ“¦ Installation

### Prerequisites

1. **Domain Name**: Valid FQDN for your Network Participant
2. **SSL Certificate**: Valid SSL certificate for your domain
3. **ONDC Whitelisting**: Approval from ONDC for your subscriber_id
4. **Rust Environment**: Rust 1.70+ with Cargo

### Quick Start

```bash
# Clone the repository
git clone https://github.com/your-username/ondc-bap-server.git
cd ondc-bap-server

# Build the project
cargo build --release

# Run with staging configuration
ONDC_ENV=staging cargo run --bin ondc-bap
```

### Configuration

Create environment-specific configuration files:

```toml
# config/staging.toml
[server]
host = "0.0.0.0"
port = 8080

[ondc]
environment = "staging"
subscriber_id = "your-domain.com"
callback_url = "/ondc"

[keys]
signing_private_key = "base64-encoded-ed25519-private-key"
encryption_private_key = "base64-encoded-x25519-private-key"
unique_key_id = "key-1"
```

## ðŸ—ï¸ Architecture

The project follows a layered architecture with modular crates:

```
ondc-bap/                           # Main BAP server
â”œâ”€â”€ ondc-crypto-traits/            # Core traits and error types
â”œâ”€â”€ ondc-crypto-algorithms/        # Cryptographic implementations
â”œâ”€â”€ ondc-crypto-formats/           # Encoding and format utilities
â””â”€â”€ ondc-crypto-cli/               # Command-line utilities
```

### Key Components

- **Presentation Layer**: Axum HTTP server with middleware stack
- **Services Layer**: Business logic for onboarding and challenge processing
- **Infrastructure Layer**: Configuration, logging, and external integrations
- **Crypto Foundation**: Secure cryptographic operations for ONDC compliance

## ðŸ” ONDC Compliance Features

### 1. Site Verification
```rust
// Generates ONDC-compliant site verification page
GET /ondc-site-verification.html
```

**Features**:
- âœ… Unique request ID generation (UUID format)
- âœ… Ed25519 signing without hashing (ONDC requirement)
- âœ… Proper HTML meta tag format
- âœ… Request ID storage with TTL

### 2. Challenge Processing
```rust
// Processes ONDC challenge-response authentication
POST /on_subscribe
{
  "subscriber_id": "your-domain.com",
  "challenge": "base64-encoded-encrypted-challenge"
}
```

**Features**:
- âœ… X25519 key exchange with ONDC public keys
- âœ… AES-256-ECB challenge decryption
- âœ… Environment-specific ONDC public keys
- âœ… Comprehensive error handling and validation

### 3. Registry Integration (In Progress)
```rust
// Registry client for ONDC API integration
POST /subscribe  // Participant registration
POST /v2.0/lookup  // Participant lookup
```

**Planned Features**:
- ðŸ”„ HTTP signature generation for authenticated requests
- ðŸ”„ Retry logic with exponential backoff
- ðŸ”„ Rate limiting compliance
- ðŸ”„ Environment-specific registry URLs

## ðŸ›¡ï¸ Security Features

- **Memory Safety**: Automatic zeroization of sensitive data
- **Cryptographic Security**: Ed25519/X25519/AES-256-ECB operations
- **Input Validation**: Comprehensive request validation
- **Rate Limiting**: Per-IP adaptive rate limiting
- **Security Headers**: Production-ready security middleware
- **TLS Support**: HTTPS configuration for production

## ðŸ“š Documentation

- **[Technical Guide](docs/technical.md)** - Implementation details and patterns
- **[Architecture](docs/architecture.mermaid)** - System design and data flows
- **[Project Status](docs/status.md)** - Implementation progress and roadmap
- **[ONDC Onboarding Guide](docs/Onboarding%20of%20Participants.md)** - ONDC-specific requirements

## ðŸ”§ Development

### Building

```bash
# Build all crates
cargo build

# Build with optimizations
cargo build --release

# Run tests
cargo test

# Check code quality
cargo clippy
cargo fmt
```

### Configuration Management

```bash
# Development environment
ONDC_ENV=staging cargo run

# Production environment
ONDC_ENV=production cargo run --release

# Custom configuration
ONDC_SUBSCRIBER_ID=your-domain.com cargo run
```

### Key Generation

Use the provided CLI utilities for key generation:

```bash
# Generate Ed25519 signing key pair
cargo run --bin ondc-crypto-cli -- generate-signing-keys

# Generate X25519 encryption key pair
cargo run --bin ondc-crypto-cli -- generate-encryption-keys

# Convert key formats
cargo run --bin ondc-crypto-cli -- convert-key-format
```

## ðŸš€ Deployment

### Docker Deployment

```dockerfile
# Multi-stage build for production
FROM rust:1.70 as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bullseye-slim
COPY --from=builder /app/target/release/ondc-bap /usr/local/bin/
EXPOSE 8080
CMD ["ondc-bap"]
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ondc-bap-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ondc-bap-server
  template:
    metadata:
      labels:
        app: ondc-bap-server
    spec:
      containers:
      - name: ondc-bap
        image: ondc-bap-server:latest
        ports:
        - containerPort: 8080
        env:
        - name: ONDC_ENV
          value: "production"
```

## ðŸ” Monitoring and Observability

- **Health Checks**: `/health` endpoint for system status
- **Metrics**: Prometheus-style metrics collection
- **Logging**: Structured logging with tracing
- **Error Tracking**: Comprehensive error handling and reporting

## ðŸ¤ Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

### Development Workflow

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Run tests and ensure they pass
5. Commit your changes (`git commit -m 'Add amazing feature'`)
6. Push to the branch (`git push origin feature/amazing-feature`)
7. Open a Pull Request

## ðŸ“„ License

This project is licensed under either of

- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or https://www.apache.org/licenses/LICENSE-2.0)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or https://opensource.org/licenses/MIT)

at your option.

## ðŸ™ Acknowledgments

- [ONDC](https://ondc.org/) for the specification and protocol
- [Beckn Protocol](https://becknprotocol.io/) for the underlying protocol
- [Rust Crypto](https://github.com/RustCrypto) for cryptographic implementations
- [Axum](https://github.com/tokio-rs/axum) for the web framework

## ðŸ“ž Support

- **Issues**: [GitHub Issues](https://github.com/your-username/ondc-bap-server/issues)
- **Discussions**: [GitHub Discussions](https://github.com/your-username/ondc-bap-server/discussions)
- **ONDC Support**: techsupport@ondc.org

## ðŸ—ºï¸ Roadmap

See our [Project Status](docs/status.md) for detailed implementation progress.

### Next Milestones

- [ ] Registry client implementation
- [ ] Onboarding service orchestration
- [ ] Administrative API endpoints
- [ ] Integration testing with ONDC environments
- [ ] Production deployment guides

---

**Note**: This project is designed to help organizations successfully onboard as Network Participants in the ONDC ecosystem. The implementation follows ONDC specifications and best practices for secure, scalable, and maintainable BAP server development.

================
File: docs/architecture.mermaid
================
%% ============================================================================
%% 1. ONDC BAP Server - High Level Architecture
%% ============================================================================

graph TB
    subgraph "ONDC BAP Server Architecture"
        direction TB
        
        %% External Systems
        subgraph "External Systems"
            ONDC_REGISTRY[ðŸŒ ONDC Registry<br/>staging/preprod/prod]
            SSL_PROVIDER[ðŸ”’ SSL Certificate<br/>Provider]
            DNS_PROVIDER[ðŸŒ DNS Provider<br/>Domain Management]
        end
        
        %% BAP Server Layers
        subgraph "ONDC BAP Server"
            direction TB
            
            %% Presentation Layer
            subgraph "ðŸŽ¯ Presentation Layer (Axum)"
                HTTP_SERVER[HTTP Server<br/>Axum Router]
                MIDDLEWARE[Middleware Stack<br/>CORS, Logging, Auth]
                
                subgraph "Endpoints"
                    SITE_VERIFY["/ondc-site-verification.html"]
                    ON_SUBSCRIBE["/on_subscribe"]
                    HEALTH["/health"]
                    ADMIN_API["/admin/*"]
                end
            end
            
            %% Services Layer
            subgraph "âš™ï¸ Services Layer"
                ONBOARD_SVC[Onboarding Service]
                KEY_MGR_SVC[Key Management Service]
                REGISTRY_SVC[Registry Client Service]
                CHALLENGE_SVC[Challenge Handler Service]
            end
            
            %% Domain Layer
            subgraph "ðŸ›ï¸ Domain Layer"
                SUBSCRIBER[Subscriber Entity]
                CHALLENGE[Challenge Entity]
                REGISTRATION[Registration Entity]
                KEY_PAIR[KeyPair Value Object]
                DOMAIN_RULES[Domain Rules & Validation]
            end
            
            %% Infrastructure Layer
            subgraph "ðŸ”§ Infrastructure Layer"
                CONFIG_MGR[Configuration Manager]
                HTTP_CLIENT[HTTP Client<br/>Registry APIs]
                FILE_SYS[File System<br/>Key Storage]
                LOGGER[Logging & Tracing]
            end
        end
        
        %% Crypto Components
        subgraph "ðŸ” Crypto Foundation"
            ED25519_SIGNER[Ed25519 Signer<br/>ondc-crypto-algorithms]
            X25519_EXCHANGE[X25519 KeyExchange<br/>ondc-crypto-algorithms]
            BASE64_UTILS[Base64 Utils<br/>ondc-crypto-formats]
            BLAKE2_HASHER[Blake2 Hasher<br/>ondc-crypto-algorithms]
        end
        
        %% Connections - External
        ONDC_REGISTRY <--> HTTP_CLIENT
        SSL_PROVIDER --> HTTP_SERVER
        DNS_PROVIDER --> HTTP_SERVER
        
        %% Connections - Internal Layers
        HTTP_SERVER --> MIDDLEWARE
        MIDDLEWARE --> SITE_VERIFY
        MIDDLEWARE --> ON_SUBSCRIBE
        MIDDLEWARE --> HEALTH
        MIDDLEWARE --> ADMIN_API
        
        SITE_VERIFY --> ONBOARD_SVC
        ON_SUBSCRIBE --> CHALLENGE_SVC
        ADMIN_API --> ONBOARD_SVC
        ADMIN_API --> KEY_MGR_SVC
        
        ONBOARD_SVC --> REGISTRY_SVC
        ONBOARD_SVC --> KEY_MGR_SVC
        CHALLENGE_SVC --> KEY_MGR_SVC
        REGISTRY_SVC --> HTTP_CLIENT
        
        KEY_MGR_SVC --> SUBSCRIBER
        ONBOARD_SVC --> REGISTRATION
        CHALLENGE_SVC --> CHALLENGE
        
        SUBSCRIBER --> KEY_PAIR
        REGISTRATION --> DOMAIN_RULES
        CHALLENGE --> DOMAIN_RULES
        
        KEY_MGR_SVC --> ED25519_SIGNER
        KEY_MGR_SVC --> X25519_EXCHANGE
        REGISTRY_SVC --> BASE64_UTILS
        CHALLENGE_SVC --> X25519_EXCHANGE
        
        CONFIG_MGR --> FILE_SYS
        HTTP_CLIENT --> LOGGER
        KEY_MGR_SVC --> FILE_SYS
        
        %% Styling
        classDef externalSystem fill:#ffebcd,stroke:#d2691e,stroke-width:2px
        classDef presentationLayer fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
        classDef applicationLayer fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
        classDef domainLayer fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
        classDef infrastructureLayer fill:#fce4ec,stroke:#c2185b,stroke-width:2px
        classDef cryptoLayer fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
        
        class ONDC_REGISTRY,SSL_PROVIDER,DNS_PROVIDER externalSystem
        class HTTP_SERVER,MIDDLEWARE,SITE_VERIFY,ON_SUBSCRIBE,HEALTH,ADMIN_API presentationLayer
        class ONBOARD_SVC,KEY_MGR_SVC,REGISTRY_SVC,CHALLENGE_SVC applicationLayer
        class SUBSCRIBER,CHALLENGE,REGISTRATION,KEY_PAIR,DOMAIN_RULES domainLayer
        class CONFIG_MGR,HTTP_CLIENT,FILE_SYS,LOGGER infrastructureLayer
        class ED25519_SIGNER,X25519_EXCHANGE,BASE64_UTILS,BLAKE2_HASHER cryptoLayer
    end

---

%% ============================================================================
%% 2. ONDC Onboarding Flow Sequence
%% ============================================================================

sequenceDiagram
    participant Admin as ðŸ‘¤ Administrator
    participant BAP as ðŸ–¥ï¸ BAP Server
    participant Registry as ðŸŒ ONDC Registry
    participant FS as ðŸ’¾ File System
    
    Note over Admin,FS: ONDC Network Participant Onboarding Flow
    
    %% Prerequisites Check
    Admin->>BAP: POST /admin/register
    BAP->>FS: Load signing/encryption keys
    FS-->>BAP: Private keys
    BAP->>BAP: Validate domain & SSL
    BAP->>BAP: Generate request_id
    
    %% Site Verification Setup
    BAP->>BAP: Sign request_id with Ed25519
    BAP->>FS: Store signed verification
    Note over BAP: Site verification ready at /ondc-site-verification.html
    
    %% Registry Registration
    BAP->>Registry: POST /subscribe
    Note right of Registry: Payload includes:<br/>- subscriber_id<br/>- public keys<br/>- callback_url
    
    Registry->>Registry: Validate payload schema
    Registry->>Registry: Perform OCSP check
    Registry->>BAP: GET /ondc-site-verification.html
    BAP-->>Registry: Signed verification HTML
    Registry->>Registry: Verify domain signature
    
    %% Challenge-Response
    Registry->>BAP: POST /on_subscribe
    Note right of Registry: Contains encrypted challenge
    BAP->>BAP: Generate X25519 shared secret
    BAP->>BAP: Decrypt challenge with AES-256-ECB
    BAP-->>Registry: { "answer": "decrypted_challenge" }
    
    Registry->>Registry: Validate challenge response
    Registry-->>BAP: Registration success/failure
    BAP-->>Admin: Registration status
    
    %% Verification
    Admin->>BAP: GET /admin/status
    BAP->>Registry: POST /v2.0/lookup
    Registry-->>BAP: Participant record
    BAP-->>Admin: Registration confirmed

---

%% ============================================================================
%% 3. BAP Server Request Processing Flow
%% ============================================================================

graph LR
    subgraph "Request Processing Architecture"
        direction LR
        
        %% Incoming Requests
        CLIENT[ðŸ“± Client Request]
        REGISTRY_REQ[ðŸŒ Registry Request]
        
        %% Axum Router
        subgraph "Axum Router & Middleware"
            ROUTER[Router]
            AUTH_MW[Auth Middleware]
            LOG_MW[Logging Middleware]
            CORS_MW[CORS Middleware]
            ERROR_MW[Error Middleware]
        end
        
        %% Handlers
        subgraph "Request Handlers"
            SITE_HANDLER[Site Verification Handler]
            SUBSCRIBE_HANDLER[On Subscribe Handler]
            ADMIN_HANDLER[Admin Handler]
            HEALTH_HANDLER[Health Handler]
        end
        
        %% Services
        subgraph "Application Services"
            ONBOARD_SERVICE[Onboarding Service]
            KEY_SERVICE[Key Management]
            REGISTRY_CLIENT[Registry Client]
            CRYPTO_SERVICE[Crypto Operations]
        end
        
        %% External
        ONDC_API[ðŸŒ ONDC Registry API]
        FILE_STORAGE[ðŸ’¾ Key Storage]
        
        %% Flow
        CLIENT --> ROUTER
        REGISTRY_REQ --> ROUTER
        
        ROUTER --> AUTH_MW
        AUTH_MW --> LOG_MW
        LOG_MW --> CORS_MW
        CORS_MW --> ERROR_MW
        
        ERROR_MW --> SITE_HANDLER
        ERROR_MW --> SUBSCRIBE_HANDLER
        ERROR_MW --> ADMIN_HANDLER
        ERROR_MW --> HEALTH_HANDLER
        
        SITE_HANDLER --> ONBOARD_SERVICE
        SUBSCRIBE_HANDLER --> CRYPTO_SERVICE
        ADMIN_HANDLER --> ONBOARD_SERVICE
        HEALTH_HANDLER --> REGISTRY_CLIENT
        
        ONBOARD_SERVICE --> KEY_SERVICE
        ONBOARD_SERVICE --> REGISTRY_CLIENT
        CRYPTO_SERVICE --> KEY_SERVICE
        
        REGISTRY_CLIENT --> ONDC_API
        KEY_SERVICE --> FILE_STORAGE
        
        %% Styling
        classDef clientLayer fill:#e8f5e8,stroke:#2e7d32
        classDef middlewareLayer fill:#e3f2fd,stroke:#1565c0
        classDef handlerLayer fill:#fff3e0,stroke:#ef6c00
        classDef serviceLayer fill:#fce4ec,stroke:#c2185b
        classDef externalLayer fill:#f3e5f5,stroke:#7b1fa2
        
        class CLIENT,REGISTRY_REQ clientLayer
        class ROUTER,AUTH_MW,LOG_MW,CORS_MW,ERROR_MW middlewareLayer
        class SITE_HANDLER,SUBSCRIBE_HANDLER,ADMIN_HANDLER,HEALTH_HANDLER handlerLayer
        class ONBOARD_SERVICE,KEY_SERVICE,REGISTRY_CLIENT,CRYPTO_SERVICE serviceLayer
        class ONDC_API,FILE_STORAGE externalLayer
    end

---

%% ============================================================================
%% 4. Key Management and Crypto Operations
%% ============================================================================

graph TB
    subgraph "Key Management & Crypto Architecture"
        direction TB
        
        %% Configuration
        subgraph "ðŸ”§ Configuration Layer"
            ENV_CONFIG[Environment Config<br/>TOML/JSON]
            KEY_CONFIG[Key Configuration<br/>Base64/DER formats]
            ONDC_CONFIG[ONDC Settings<br/>Registry URLs, timeouts]
        end
        
        %% Key Management
        subgraph "ðŸ”‘ Key Management Service"
            KEY_LOADER[Key Loader<br/>Secure loading]
            KEY_VALIDATOR[Key Validator<br/>Format & length checks]
            KEY_STORAGE[Key Storage<br/>Memory-safe handling]
            KEY_ROTATOR[Key Rotation<br/>Lifecycle management]
        end
        
        %% Crypto Operations
        subgraph "ðŸ” Crypto Operations Service"
            SIGN_OPS[Signing Operations<br/>Ed25519 signing]
            VERIFY_OPS[Verification Operations<br/>Signature validation]
            EXCHANGE_OPS[Key Exchange<br/>X25519 ECDH]
            ENCRYPT_OPS[Encryption/Decryption<br/>AES-256-ECB]
        end
        
        %% Crypto Algorithms
        subgraph "âš™ï¸ Crypto Algorithms (ondc-crypto-algorithms)"
            ED25519_ALG[Ed25519Signer<br/>Ed25519Verifier]
            X25519_ALG[X25519KeyExchange<br/>Shared secret generation]
            BLAKE2_ALG[Blake2Hasher<br/>Digest generation]
        end
        
        %% Format Utilities
        subgraph "ðŸ“„ Format Utils (ondc-crypto-formats)"
            BASE64_FMT[Base64 Encoding<br/>Multiple variants]
            KEY_FMT[Key Format Conversion<br/>Raw/Base64/DER]
            ENCODING_FMT[Encoding Utilities<br/>Safe conversions]
        end
        
        %% External Storage
        FILE_SYS[ðŸ’¾ File System<br/>Secure key files]
        ENV_VARS[ðŸŒ Environment Variables<br/>Runtime configuration]
        
        %% Connections
        ENV_CONFIG --> KEY_LOADER
        KEY_CONFIG --> KEY_LOADER
        ONDC_CONFIG --> KEY_LOADER
        
        KEY_LOADER --> KEY_VALIDATOR
        KEY_VALIDATOR --> KEY_STORAGE
        KEY_STORAGE --> KEY_ROTATOR
        
        KEY_STORAGE --> SIGN_OPS
        KEY_STORAGE --> VERIFY_OPS
        KEY_STORAGE --> EXCHANGE_OPS
        KEY_STORAGE --> ENCRYPT_OPS
        
        SIGN_OPS --> ED25519_ALG
        VERIFY_OPS --> ED25519_ALG
        EXCHANGE_OPS --> X25519_ALG
        ENCRYPT_OPS --> X25519_ALG
        
        SIGN_OPS --> BASE64_FMT
        VERIFY_OPS --> BASE64_FMT
        EXCHANGE_OPS --> KEY_FMT
        ENCRYPT_OPS --> ENCODING_FMT
        
        KEY_LOADER --> FILE_SYS
        KEY_LOADER --> ENV_VARS
        
        %% Styling
        classDef configLayer fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
        classDef keyMgmtLayer fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
        classDef cryptoOpsLayer fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
        classDef algorithmsLayer fill:#fce4ec,stroke:#c2185b,stroke-width:2px
        classDef formatLayer fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
        classDef storageLayer fill:#fff8e1,stroke:#f57c00,stroke-width:2px
        
        class ENV_CONFIG,KEY_CONFIG,ONDC_CONFIG configLayer
        class KEY_LOADER,KEY_VALIDATOR,KEY_STORAGE,KEY_ROTATOR keyMgmtLayer
        class SIGN_OPS,VERIFY_OPS,EXCHANGE_OPS,ENCRYPT_OPS cryptoOpsLayer
        class ED25519_ALG,X25519_ALG,BLAKE2_ALG algorithmsLayer
        class BASE64_FMT,KEY_FMT,ENCODING_FMT formatLayer
        class FILE_SYS,ENV_VARS storageLayer
    end

---

%% ============================================================================
%% 5. Error Handling and Security Architecture
%% ============================================================================

graph TD
    subgraph "Error Handling & Security Architecture"
        direction TD
        
        %% Error Sources
        subgraph "ðŸš¨ Error Sources"
            HTTP_ERRORS[HTTP Request Errors<br/>4xx, 5xx responses]
            CRYPTO_ERRORS[Cryptographic Errors<br/>Invalid keys, signatures]
            REGISTRY_ERRORS[Registry API Errors<br/>Network, protocol issues]
            CONFIG_ERRORS[Configuration Errors<br/>Missing keys, invalid URLs]
            VALIDATION_ERRORS[Validation Errors<br/>Invalid payloads, formats]
        end
        
        %% Error Processing
        subgraph "âš™ï¸ Error Processing Pipeline"
            ERROR_CLASSIFIER[Error Classification<br/>Categorize error types]
            ERROR_ENRICHER[Context Enrichment<br/>Add correlation IDs]
            ERROR_CONVERTER[Error Conversion<br/>Internal â†’ HTTP responses]
            ERROR_LOGGER[Error Logging<br/>Structured logging]
            ERROR_METRICS[Error Metrics<br/>Monitoring & alerting]
        end
        
        %% Security Measures
        subgraph "ðŸ›¡ï¸ Security Measures"
            MEMORY_SAFETY[Memory Safety<br/>Automatic zeroization]
            TIMING_PROTECTION[Timing Attack Protection<br/>Constant-time operations]
            KEY_PROTECTION[Key Protection<br/>Secure storage & handling]
            TLS_CONFIG[TLS Configuration<br/>Strong cipher suites]
            RATE_LIMITING[Rate Limiting<br/>DOS protection]
        end
        
        %% Monitoring & Observability
        subgraph "ðŸ“Š Monitoring & Observability"
            HEALTH_CHECKS[Health Checks<br/>System status monitoring]
            METRICS_COLLECTION[Metrics Collection<br/>Performance tracking]
            DISTRIBUTED_TRACING[Distributed Tracing<br/>Request correlation]
            LOG_AGGREGATION[Log Aggregation<br/>Centralized logging]
            ALERTING[Alerting<br/>Incident response]
        end
        
        %% Recovery & Resilience
        subgraph "ðŸ”„ Recovery & Resilience"
            RETRY_LOGIC[Retry Logic<br/>Exponential backoff]
            CIRCUIT_BREAKER[Circuit Breaker<br/>Failure isolation]
            GRACEFUL_DEGRADATION[Graceful Degradation<br/>Partial functionality]
            BACKUP_RECOVERY[Backup & Recovery<br/>Data persistence]
            DISASTER_RECOVERY[Disaster Recovery<br/>System restoration]
        end
        
        %% Flow connections
        HTTP_ERRORS --> ERROR_CLASSIFIER
        CRYPTO_ERRORS --> ERROR_CLASSIFIER
        REGISTRY_ERRORS --> ERROR_CLASSIFIER
        CONFIG_ERRORS --> ERROR_CLASSIFIER
        VALIDATION_ERRORS --> ERROR_CLASSIFIER
        
        ERROR_CLASSIFIER --> ERROR_ENRICHER
        ERROR_ENRICHER --> ERROR_CONVERTER
        ERROR_CONVERTER --> ERROR_LOGGER
        ERROR_LOGGER --> ERROR_METRICS
        
        ERROR_METRICS --> HEALTH_CHECKS
        ERROR_METRICS --> METRICS_COLLECTION
        ERROR_METRICS --> ALERTING
        
        MEMORY_SAFETY --> KEY_PROTECTION
        TIMING_PROTECTION --> KEY_PROTECTION
        KEY_PROTECTION --> TLS_CONFIG
        TLS_CONFIG --> RATE_LIMITING
        
        HEALTH_CHECKS --> RETRY_LOGIC
        METRICS_COLLECTION --> CIRCUIT_BREAKER
        DISTRIBUTED_TRACING --> GRACEFUL_DEGRADATION
        LOG_AGGREGATION --> BACKUP_RECOVERY
        ALERTING --> DISASTER_RECOVERY
        
        %% Styling
        classDef errorSource fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px
        classDef errorProcess fill:#fff3e0,stroke:#f57c00,stroke-width:2px
        classDef security fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
        classDef monitoring fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
        classDef resilience fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
        
        class HTTP_ERRORS,CRYPTO_ERRORS,REGISTRY_ERRORS,CONFIG_ERRORS,VALIDATION_ERRORS errorSource
        class ERROR_CLASSIFIER,ERROR_ENRICHER,ERROR_CONVERTER,ERROR_LOGGER,ERROR_METRICS errorProcess
        class MEMORY_SAFETY,TIMING_PROTECTION,KEY_PROTECTION,TLS_CONFIG,RATE_LIMITING security
        class HEALTH_CHECKS,METRICS_COLLECTION,DISTRIBUTED_TRACING,LOG_AGGREGATION,ALERTING monitoring
        class RETRY_LOGIC,CIRCUIT_BREAKER,GRACEFUL_DEGRADATION,BACKUP_RECOVERY,DISASTER_RECOVERY resilience
    end

---

%% ============================================================================
%% 6. Deployment and Infrastructure Architecture
%% ============================================================================

graph TB
    subgraph "Deployment & Infrastructure Architecture"
        direction TB
        
        %% Container Layer
        subgraph "ðŸ³ Container Layer"
            DOCKER_IMAGE[Docker Image<br/>Multi-stage build]
            BASE_IMAGE[Base Image<br/>Distroless/Alpine]
            HEALTH_PROBE[Health Probes<br/>Liveness/Readiness]
        end
        
        %% Orchestration Layer
        subgraph "â˜¸ï¸ Orchestration Layer (Kubernetes)"
            DEPLOYMENT[Deployment<br/>Rolling updates]
            SERVICE[Service<br/>Load balancing]
            INGRESS[Ingress<br/>TLS termination]
            CONFIG_MAP[ConfigMap<br/>Configuration]
            SECRET[Secret<br/>Key storage]
            HPA[HPA<br/>Auto-scaling]
        end
        
        %% Infrastructure Layer
        subgraph "ðŸ—ï¸ Infrastructure Layer"
            LOAD_BALANCER[Load Balancer<br/>High availability]
            CERT_MANAGER[Cert Manager<br/>SSL automation]
            DNS_RESOLVER[DNS<br/>Service discovery]
            STORAGE_CLASS[Storage Class<br/>Persistent volumes]
        end
        
        %% Monitoring Stack
        subgraph "ðŸ“Š Monitoring Stack"
            PROMETHEUS[Prometheus<br/>Metrics collection]
            GRAFANA[Grafana<br/>Visualization]
            JAEGER[Jaeger<br/>Distributed tracing]
            LOKI[Loki<br/>Log aggregation]
            ALERT_MGR[AlertManager<br/>Incident management]
        end
        
        %% External Services
        subgraph "ðŸŒ External Services"
            ONDC_STAGING[ONDC Staging<br/>staging.registry.ondc.org]
            ONDC_PREPROD[ONDC Pre-Prod<br/>preprod.registry.ondc.org]
            ONDC_PROD[ONDC Production<br/>prod.registry.ondc.org]
            DNS_PROVIDER_EXT[DNS Provider<br/>Domain management]
            SSL_PROVIDER_EXT[SSL Provider<br/>Certificate authority]
        end
        
        %% Connections
        DOCKER_IMAGE --> DEPLOYMENT
        BASE_IMAGE --> DOCKER_IMAGE
        HEALTH_PROBE --> DOCKER_IMAGE
        
        DEPLOYMENT --> SERVICE
        SERVICE --> INGRESS
        CONFIG_MAP --> DEPLOYMENT
        SECRET --> DEPLOYMENT
        HPA --> DEPLOYMENT
        
        INGRESS --> LOAD_BALANCER
        INGRESS --> CERT_MANAGER
        SERVICE --> DNS_RESOLVER
        SECRET --> STORAGE_CLASS
        
        DEPLOYMENT --> PROMETHEUS
        PROMETHEUS --> GRAFANA
        DEPLOYMENT --> JAEGER
        DEPLOYMENT --> LOKI
        PROMETHEUS --> ALERT_MGR
        
        LOAD_BALANCER --> ONDC_STAGING
        LOAD_BALANCER --> ONDC_PREPROD
        LOAD_BALANCER --> ONDC_PROD
        CERT_MANAGER --> SSL_PROVIDER_EXT
        DNS_RESOLVER --> DNS_PROVIDER_EXT
        
        %% Styling
        classDef containerLayer fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
        classDef orchestrationLayer fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
        classDef infrastructureLayer fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
        classDef monitoringLayer fill:#fce4ec,stroke:#c2185b,stroke-width:2px
        classDef externalLayer fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
        
        class DOCKER_IMAGE,BASE_IMAGE,HEALTH_PROBE containerLayer
        class DEPLOYMENT,SERVICE,INGRESS,CONFIG_MAP,SECRET,HPA orchestrationLayer
        class LOAD_BALANCER,CERT_MANAGER,DNS_RESOLVER,STORAGE_CLASS infrastructureLayer
        class PROMETHEUS,GRAFANA,JAEGER,LOKI,ALERT_MGR monitoringLayer
        class ONDC_STAGING,ONDC_PREPROD,ONDC_PROD,DNS_PROVIDER_EXT,SSL_PROVIDER_EXT externalLayer
    end

================
File: ondc-bap/config/production.toml
================
# ONDC BAP Server - Production Configuration

[server]
host = "0.0.0.0"
port = 8442
request_timeout_secs = 30
max_connections = 10000

# TLS configuration (required for production)
[server.tls]
cert_path = "/opt/ssl-certs/fullchain.pem"
key_path = "/opt/ssl-certs/privkey.pem"

[ondc]
environment = "production"
registry_base_url = "https://network.lootai.co"
subscriber_id = "network.lootai.co"
callback_url = "/"
request_timeout_secs = 30
max_retries = 5

[keys]
# These must be actual production keys
signing_private_key = "your-production-signing-private-key-base64"
encryption_private_key = "your-production-encryption-private-key-base64"
unique_key_id = "prod_key_1"

[security]
enable_rate_limiting = true
max_requests_per_minute = 1000
enable_cors = true
allowed_origins = ["*"]

================
File: ondc-bap/src/bin/main.rs
================
//! ONDC BAP Server - Main Binary
//!
//! This is the main entry point for the ONDC BAP server application.

use ondc_bap::{BAPServer, Result};
use tracing::{error, info};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "ondc_bap=info,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    info!("Starting ONDC BAP Server v{}", ondc_bap::VERSION);

    // Create and run the server
    match BAPServer::new().await {
        Ok(server) => {
            info!("BAP Server initialized successfully");
            server.run().await
        }
        Err(e) => {
            error!("Failed to initialize BAP Server: {}", e);
            Err(e)
        }
    }
}

================
File: ondc-bap/src/config/app_config.rs
================
//! Main application configuration for ONDC BAP Server

use crate::config::{ConfigError, ONDCConfig};
use figment::providers::Format;
use serde::Deserialize;

/// Main BAP server configuration
#[derive(Debug, Clone, Deserialize)]
pub struct BAPConfig {
    pub server: ServerConfig,
    pub ondc: ONDCConfig,
    pub keys: KeyConfig,
    pub security: SecurityConfig,
}

/// Server configuration
#[derive(Debug, Clone, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub tls: Option<TlsConfig>,
    pub request_timeout_secs: u64,
    pub max_connections: usize,
}

/// TLS configuration
#[derive(Debug, Clone, Deserialize)]
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

/// Key configuration
#[derive(Debug, Clone, Deserialize)]
pub struct KeyConfig {
    pub signing_private_key: String,    // Base64 encoded
    pub encryption_private_key: String, // Base64 encoded
    pub unique_key_id: String,
}

/// Security configuration
#[derive(Debug, Clone, Deserialize)]
pub struct SecurityConfig {
    pub enable_rate_limiting: bool,
    pub max_requests_per_minute: usize,
    pub enable_cors: bool,
    pub allowed_origins: Vec<String>,
}

impl BAPConfig {
    /// Load configuration from environment and files
    pub fn load() -> Result<Self, ConfigError> {
        let environment = std::env::var("ONDC_ENV").unwrap_or_else(|_| "staging".to_string());

        let cwd = std::env::current_dir().unwrap();

        let config_path = format!("{}/ondc-bap/config/{}.toml", cwd.display(), environment);

        // Check if file exists
        if !std::path::Path::new(&config_path).exists() {
            return Err(ConfigError::LoadError(format!(
                "Config file not found: {}",
                config_path
            )));
        }

        let config: BAPConfig = figment::Figment::new()
            .merge(figment::providers::Toml::file(&config_path))
            .merge(figment::providers::Env::prefixed("ONDC_"))
            .extract()
            .map_err(|e| ConfigError::LoadError(e.to_string()))?;

        // Validate configuration
        config.validate()?;

        Ok(config)
    }

    /// Validate configuration consistency
    pub fn validate(&self) -> Result<(), ConfigError> {
        // Validate subscriber ID
        if self.ondc.subscriber_id.is_empty() {
            return Err(ConfigError::InvalidSubscriberId(
                "Subscriber ID cannot be empty".to_string(),
            ));
        }

        // Validate key formats
        self.keys.validate()?;

        // Validate URLs
        url::Url::parse(&self.ondc.registry_base_url)
            .map_err(|_| ConfigError::InvalidRegistryUrl(self.ondc.registry_base_url.clone()))?;

        Ok(())
    }
}

impl KeyConfig {
    /// Validate key configuration
    pub fn validate(&self) -> Result<(), ConfigError> {
        use ondc_crypto_formats::decode_signature;

        // Validate signing key format and length
        let signing_key = decode_signature(&self.signing_private_key).map_err(|_| {
            ConfigError::InvalidSigningKey("Invalid signing key format".to_string())
        })?;
        if signing_key.len() != 32 {
            return Err(ConfigError::InvalidSigningKeyLength(signing_key.len()));
        }

        // Validate encryption key format and length
        let encryption_key = decode_signature(&self.encryption_private_key).map_err(|_| {
            ConfigError::InvalidEncryptionKey("Invalid encryption key format".to_string())
        })?;
        if encryption_key.len() != 32 {
            return Err(ConfigError::InvalidEncryptionKeyLength(
                encryption_key.len(),
            ));
        }

        Ok(())
    }
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            host: "0.0.0.0".to_string(),
            port: 8080,
            tls: None,
            request_timeout_secs: 30,
            max_connections: 1000,
        }
    }
}

impl Default for SecurityConfig {
    fn default() -> Self {
        Self {
            enable_rate_limiting: true,
            max_requests_per_minute: 100,
            enable_cors: true,
            allowed_origins: vec!["*".to_string()],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_server_config_default() {
        let config = ServerConfig::default();
        assert_eq!(config.host, "0.0.0.0");
        assert_eq!(config.port, 8080);
        assert!(config.tls.is_none());
    }

    #[test]
    fn test_security_config_default() {
        let config = SecurityConfig::default();
        assert!(config.enable_rate_limiting);
        assert_eq!(config.max_requests_per_minute, 100);
        assert!(config.enable_cors);
    }
}

================
File: ondc-bap/src/config/environment.rs
================
//! Environment configuration loading utilities

use crate::config::{ondc_config::{BusinessEntityConfig, GstConfig, PanConfig}, BAPConfig, ConfigError};

/// Load configuration from environment
pub fn load_config() -> Result<BAPConfig, ConfigError> {
    BAPConfig::load()
}

/// Load configuration for specific environment
pub fn load_config_for_environment(env: &str) -> Result<BAPConfig, ConfigError> {
    std::env::set_var("ONDC_ENV", env);
    BAPConfig::load()
}

/// Create test configuration for development
pub fn create_test_config() -> BAPConfig {
    use crate::config::{
        app_config::KeyConfig, app_config::SecurityConfig, app_config::ServerConfig,
        ondc_config::Environment, ondc_config::ONDCConfig,
    };

    BAPConfig {
        server: ServerConfig {
            host: "0.0.0.0".to_string(),
            port: 8080,
            tls: None,
            request_timeout_secs: 30,
            max_connections: 1000,
        },
        ondc: ONDCConfig {
            environment: Environment::Staging,
            registry_base_url: "https://staging.registry.ondc.org".to_string(),
            subscriber_id: "test.example.com".to_string(),
            callback_url: "/".to_string(),
            request_timeout_secs: 30,
            max_retries: 3,
            network_participants: None,
            business_entity: BusinessEntityConfig {
                gst: GstConfig {
                    legal_entity_name: "Default Entity".to_string(),
                    business_address: "Default Address".to_string(),
                    city_code: vec!["std:080".to_string()],
                    gst_no: None,
                },
                pan: PanConfig {
                    name_as_per_pan: "Default Entity".to_string(),
                    pan_no: "AAAAA0000A".to_string(),
                    date_of_incorporation: "01/01/2020".to_string(),
                },
                name_of_authorised_signatory: "Default Signatory".to_string(),
                address_of_authorised_signatory: "Default Address".to_string(),
                email_id: "default@example.com".to_string(),
                mobile_no: 9999999999,
                country: "IND".to_string(),
            },
        },
        keys: KeyConfig {
            signing_private_key: generate_test_signing_key(),
            encryption_private_key: generate_test_encryption_key(),
            unique_key_id: "test_key_1".to_string(),
        },
        security: SecurityConfig {
            enable_rate_limiting: true,
            max_requests_per_minute: 100,
            enable_cors: true,
            allowed_origins: vec!["*".to_string()],
        },
    }
}

/// Generate test signing key for development
fn generate_test_signing_key() -> String {
    // Generate a test Ed25519 key pair
    use ondc_crypto_algorithms::Ed25519Signer;
    use ondc_crypto_formats::encode_signature;

    let signer = Ed25519Signer::generate().expect("Failed to generate test signer");
    let private_key = signer.private_key();
    encode_signature(private_key)
}

/// Generate test encryption key for development
fn generate_test_encryption_key() -> String {
    // Generate a test X25519 key pair
    use ondc_crypto_algorithms::X25519KeyExchange;
    use ondc_crypto_formats::encode_signature;

    let key_exchange = X25519KeyExchange::generate().expect("Failed to generate test key exchange");
    let private_key = key_exchange.private_key();
    encode_signature(private_key)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_test_config() {
        let config = create_test_config();
        assert_eq!(config.server.port, 8080);
        assert_eq!(config.ondc.subscriber_id, "test.example.com");
    }

    #[test]
    fn test_generate_test_keys() {
        let signing_key = generate_test_signing_key();
        let encryption_key = generate_test_encryption_key();

        assert!(!signing_key.is_empty());
        assert!(!encryption_key.is_empty());

        // Verify they can be decoded
        use ondc_crypto_formats::decode_signature;
        assert!(decode_signature(&signing_key).is_ok());
        assert!(decode_signature(&encryption_key).is_ok());
    }
}

================
File: ondc-bap/src/config/mod.rs
================
//! Configuration management for ONDC BAP Server
//!
//! This module handles all configuration aspects including:
//! - Environment-specific configuration loading
//! - Key management configuration
//! - ONDC registry settings
//! - Server configuration

pub mod app_config;
pub mod environment;
pub mod ondc_config;

pub use app_config::BAPConfig;
pub use environment::load_config;
pub use ondc_config::{Environment, ONDCConfig};

/// Configuration error types
#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Failed to load configuration: {0}")]
    LoadError(String),

    #[error("Invalid subscriber ID: {0}")]
    InvalidSubscriberId(String),

    #[error("Invalid registry URL: {0}")]
    InvalidRegistryUrl(String),

    #[error("Invalid signing key: {0}")]
    InvalidSigningKey(String),

    #[error("Invalid encryption key: {0}")]
    InvalidEncryptionKey(String),

    #[error("Invalid signing key length: expected 32 bytes, got {0}")]
    InvalidSigningKeyLength(usize),

    #[error("Invalid encryption key length: expected 32 bytes, got {0}")]
    InvalidEncryptionKeyLength(usize),

    #[error("Invalid ONDC key: {0}")]
    InvalidONDCKey(String),

    #[error("Missing required configuration: {0}")]
    MissingConfig(String),
}

================
File: ondc-bap/src/error/mod.rs
================
//! Error handling for ONDC BAP Server

use thiserror::Error;

/// Main application error type
#[derive(Error, Debug)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    Config(#[from] crate::config::ConfigError),

    #[error("Registry error: {0}")]
    Registry(String),

    #[error("Crypto error: {0}")]
    Crypto(String),

    #[error("HTTP error: {0}")]
    Http(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Internal error: {0}")]
    Internal(String),
}

impl From<std::io::Error> for AppError {
    fn from(err: std::io::Error) -> Self {
        AppError::Internal(err.to_string())
    }
}

impl From<serde_json::Error> for AppError {
    fn from(err: serde_json::Error) -> Self {
        AppError::Internal(err.to_string())
    }
}

impl From<reqwest::Error> for AppError {
    fn from(err: reqwest::Error) -> Self {
        AppError::Http(err.to_string())
    }
}

impl From<crate::services::RegistryClientError> for AppError {
    fn from(err: crate::services::RegistryClientError) -> Self {
        AppError::Registry(err.to_string())
    }
}

================
File: ondc-bap/src/presentation/middleware/mod.rs
================
//! Middleware for ONDC BAP Server

pub mod cors;
pub mod error_handling;
pub mod logging;
pub mod rate_limiting;
pub mod security;

// Re-export middleware functions
pub use cors::cors_middleware;
pub use error_handling::error_handling_middleware;
pub use logging::logging_middleware;
pub use rate_limiting::rate_limiting_middleware;
pub use security::security_headers_middleware;

================
File: ondc-bap/src/presentation/mod.rs
================
//! Presentation layer for ONDC BAP Server
//!
//! This module contains the HTTP layer implementation using Axum framework,
//! including routers, handlers, middleware, and application state management.

pub mod handlers;
pub mod middleware;
pub mod routes;
pub mod server;

// Re-export main types
pub use handlers::AppState;
pub use routes::create_router;
pub use server::BAPServer;

================
File: ondc-bap/Cargo.toml
================
[package]
name = "ondc-bap"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
description = "ONDC BAP (Beckn Application Platform) server implementation"
keywords = ["ondc", "bap", "beckn", "server", "api", "crypto"]
categories = ["web-programming", "api-bindings", "cryptography"]
readme.workspace = true

[dependencies]
# Internal crypto crates
ondc-crypto-traits = { path = "../ondc-crypto-traits" }
ondc-crypto-algorithms = { path = "../ondc-crypto-algorithms" }
ondc-crypto-formats = { path = "../ondc-crypto-formats" }

# Web framework
axum = "0.7"
axum-server = { version = "0.6", features = ["tls-rustls"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
hyper = "1.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }

# HTTP client
reqwest = { version = "0.11", features = ["json", "native-tls"] }

# Configuration
config = "0.14"
figment = { version = "0.10", features = ["toml", "env"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# Logging and tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-opentelemetry = "0.21"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Security
rustls = "0.22"
rustls-pemfile = "2.0"

# Time handling
chrono = { version = "0.4", features = ["serde"] }

# UUID generation
uuid = { version = "1.0", features = ["v4"] }

# URL parsing
url = "2.4"

# Regex for validation
regex = "1.0"

# HTML escaping
html-escape = "0.2"

# AES encryption for challenge decryption
aes = "0.8"
block-modes = "0.9"

# Memory safety
zeroize = "1.7"

[dev-dependencies]
# Testing
axum-test = "15.0"
wiremock = "0.5"
tokio-test = "0.4"

# Property-based testing
proptest = "1.3"

[[bin]]
name = "ondc-bap"
path = "src/bin/main.rs"

================
File: ondc-crypto-algorithms/src/ed25519.rs
================
//! Ed25519 signing and verification implementation.
//!
//! This module provides Ed25519 digital signature functionality using the
//! ed25519-dalek library. It implements the ONDC crypto traits for signing
//! and verification operations.
//!
//! # Security Features
//!
//! - Constant-time signature verification to prevent timing attacks
//! - Memory-safe key handling with automatic zeroization
//! - Strict signature verification to prevent malleability attacks
//! - Comprehensive input validation
//!
//! # Examples
//!
//! ```rust
//! use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
//! use ondc_crypto_traits::{Signer, Verifier};
//!
//! // Create a signer from a private key
//! let private_key = [0u8; 32]; // In practice, use a real private key
//! let signer = Ed25519Signer::new(&private_key).unwrap();
//!
//! // Sign a message
//! let message = b"Hello, ONDC!";
//! let signature = signer.sign(message).unwrap();
//!
//! // Verify the signature
//! let verifier = Ed25519Verifier::new();
//! let public_key = signer.public_key();
//! verifier.verify(public_key, message, &signature).unwrap();
//! ```

use ed25519_dalek::{
    Signature, SigningKey, VerifyingKey, KEYPAIR_LENGTH, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH,
};
use ondc_crypto_traits::{
    validate_ed25519_private_key_length, validate_ed25519_public_key_length,
    validate_ed25519_signature_length, Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature,
    KeyPair, ONDCCryptoError, PublicKey, Signer, Verifier,
};

/// Ed25519 signer implementation.
///
/// This struct provides Ed25519 digital signature creation capabilities.
/// It wraps the ed25519-dalek SigningKey and provides a safe interface
/// for signing operations.
///
/// # Security Features
///
/// - Automatic memory zeroization of sensitive data
/// - Deterministic signing operations
/// - Input validation for all operations
/// - Safe key handling with proper error propagation
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_algorithms::Ed25519Signer;
/// use ondc_crypto_traits::Signer;
///
/// let private_key = [0u8; 32]; // Use a real private key in practice
/// let signer = Ed25519Signer::new(&private_key).unwrap();
///
/// let message = b"Hello, ONDC!";
/// let signature = signer.sign(message).unwrap();
/// ```
pub struct Ed25519Signer {
    /// The underlying ed25519-dalek signing key
    signing_key: SigningKey,
}

impl Ed25519Signer {
    /// Create a new Ed25519 signer from a private key.
    ///
    /// # Arguments
    ///
    /// * `private_key` - The 32-byte Ed25519 private key
    ///
    /// # Returns
    ///
    /// Returns a new Ed25519Signer instance if the private key is valid.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The private key length is incorrect
    /// - The private key is invalid or malformed
    ///
    /// # Security Notes
    ///
    /// - The private key should be handled securely
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    /// - The private key material will be automatically zeroized when the signer is dropped
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    ///
    /// let private_key = [0u8; 32]; // Use a real private key in practice
    /// let signer = Ed25519Signer::new(&private_key).unwrap();
    /// ```
    pub fn new(private_key: &[u8]) -> Result<Self, ONDCCryptoError> {
        // Validate private key length
        validate_ed25519_private_key_length(private_key)?;

        // Convert to fixed-size array
        let mut key_bytes = [0u8; SECRET_KEY_LENGTH];
        key_bytes.copy_from_slice(private_key);

        // Create signing key from bytes
        let signing_key = SigningKey::from_bytes(&key_bytes);

        Ok(Self { signing_key })
    }

    /// Create a new Ed25519 signer from a keypair.
    ///
    /// # Arguments
    ///
    /// * `keypair_bytes` - The 64-byte Ed25519 keypair (private + public)
    ///
    /// # Returns
    ///
    /// Returns a new Ed25519Signer instance if the keypair is valid.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The keypair length is incorrect
    /// - The keypair is invalid or malformed
    /// - The public key doesn't match the private key
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    ///
    /// let keypair = [0u8; 64]; // Use a real keypair in practice
    /// let signer = Ed25519Signer::from_keypair_bytes(&keypair).unwrap();
    /// ```
    pub fn from_keypair_bytes(
        keypair_bytes: &[u8; KEYPAIR_LENGTH],
    ) -> Result<Self, ONDCCryptoError> {
        let signing_key = SigningKey::from_keypair_bytes(keypair_bytes).map_err(|_| {
            ONDCCryptoError::InvalidKeyLength {
                expected: KEYPAIR_LENGTH,
                got: keypair_bytes.len(),
            }
        })?;

        Ok(Self { signing_key })
    }

    /// Generate a new Ed25519 signer with a random private key.
    ///
    /// # Returns
    ///
    /// Returns a new Ed25519Signer instance with a cryptographically secure random key.
    ///
    /// # Errors
    ///
    /// Returns an error if key generation fails due to insufficient entropy.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// ```
    pub fn generate() -> Result<Self, ONDCCryptoError> {
        use rand::rngs::OsRng;

        let mut csprng = OsRng;
        let signing_key = SigningKey::generate(&mut csprng);
        Ok(Self { signing_key })
    }

    /// Get the public key associated with this signer.
    ///
    /// # Returns
    ///
    /// Returns the public key as a byte array.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let public_key = signer.public_key();
    /// assert_eq!(public_key.len(), 32);
    /// ```
    pub fn public_key(&self) -> [u8; PUBLIC_KEY_LENGTH] {
        *self.signing_key.verifying_key().as_bytes()
    }

    /// Get the private key bytes.
    ///
    /// # Returns
    ///
    /// Returns the private key as a byte array.
    ///
    /// # Security Notes
    ///
    /// - This method exposes private key material
    /// - Use with caution and ensure proper security handling
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    /// use zeroize::Zeroizing;
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let private_key = Zeroizing::new(signer.private_key().to_vec());
    /// ```
    pub fn private_key(&self) -> &[u8; SECRET_KEY_LENGTH] {
        self.signing_key.as_bytes()
    }

    /// Convert this signer to a keypair.
    ///
    /// # Returns
    ///
    /// Returns the keypair as a byte array (private + public).
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Signer;
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let keypair = signer.to_keypair_bytes();
    /// assert_eq!(keypair.len(), 64);
    /// ```
    pub fn to_keypair_bytes(&self) -> [u8; KEYPAIR_LENGTH] {
        self.signing_key.to_keypair_bytes()
    }

    /// Sign a message with strict verification compatibility.
    ///
    /// This method creates a signature that is compatible with strict verification,
    /// which prevents signature malleability attacks.
    ///
    /// # Arguments
    ///
    /// * `message` - The message to sign
    ///
    /// # Returns
    ///
    /// Returns a signature that can be verified with strict verification.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let verifier = Ed25519Verifier::new();
    ///
    /// let message = b"Hello, ONDC!";
    /// let signature = signer.sign_strict(message).unwrap();
    ///
    /// // Verify with strict verification
    /// verifier.verify_strict(signer.public_key(), message, &signature).unwrap();
    /// ```
    pub fn sign_strict(&self, message: &[u8]) -> Result<Ed25519Signature, ONDCCryptoError> {
        use ed25519_dalek::Signer;

        let signature = self.signing_key.sign(message);
        Ok(signature.to_bytes())
    }
}

impl Signer for Ed25519Signer {
    type Error = ONDCCryptoError;
    type Signature = Ed25519Signature;

    fn sign(&self, message: &[u8]) -> Result<Self::Signature, Self::Error> {
        self.sign_strict(message)
    }
}

impl KeyPair for Ed25519Signer {
    type Error = ONDCCryptoError;
    type PrivateKey = Ed25519PrivateKey;
    type PublicKey = Ed25519PublicKey;

    fn generate() -> Result<Self, Self::Error> {
        Self::generate()
    }

    fn from_private_key(private_key: &[u8]) -> Result<Self, Self::Error> {
        Self::new(private_key)
    }

    fn public_key(&self) -> &Self::PublicKey {
        // This is a bit awkward since we need to return a reference
        // We'll store the public key in a static or use a different approach
        // For now, let's use a workaround by storing it temporarily
        static mut PUBLIC_KEY_STORAGE: [u8; PUBLIC_KEY_LENGTH] = [0u8; PUBLIC_KEY_LENGTH];
        unsafe {
            PUBLIC_KEY_STORAGE = self.public_key();
            &PUBLIC_KEY_STORAGE
        }
    }

    fn private_key(&self) -> &Self::PrivateKey {
        self.private_key()
    }
}

impl Clone for Ed25519Signer {
    fn clone(&self) -> Self {
        Self {
            signing_key: self.signing_key.clone(),
        }
    }
}

/// Ed25519 verifier implementation.
///
/// This struct provides Ed25519 digital signature verification capabilities.
/// It wraps the ed25519-dalek VerifyingKey and provides a safe interface
/// for verification operations.
///
/// # Security Features
///
/// - Constant-time signature verification to prevent timing attacks
/// - Strict verification to prevent malleability attacks
/// - Comprehensive input validation
/// - Support for both standard and strict verification modes
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
/// use ondc_crypto_traits::{Signer, Verifier};
///
/// let signer = Ed25519Signer::generate().unwrap();
/// let verifier = Ed25519Verifier::new();
///
/// let message = b"Hello, ONDC!";
/// let signature = signer.sign(message).unwrap();
///
/// verifier.verify(signer.public_key(), message, &signature).unwrap();
/// ```
#[derive(Debug, Clone, Default)]
pub struct Ed25519Verifier;

impl Ed25519Verifier {
    /// Create a new Ed25519 verifier.
    ///
    /// # Returns
    ///
    /// Returns a new Ed25519Verifier instance.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Verifier;
    ///
    /// let verifier = Ed25519Verifier::new();
    /// ```
    pub fn new() -> Self {
        Self
    }

    /// Verify a signature with strict verification.
    ///
    /// This method performs strict signature verification that prevents
    /// signature malleability attacks by rejecting non-canonical signatures.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The public key to verify against
    /// * `message` - The original message that was signed
    /// * `signature` - The signature to verify
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the signature is valid, or an error if verification fails.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The public key length is incorrect
    /// - The signature length is incorrect
    /// - The signature is invalid or malformed
    /// - The signature verification fails
    ///
    /// # Security Notes
    ///
    /// - This operation uses constant-time comparisons
    /// - Strict verification prevents malleability attacks
    /// - All inputs are validated before processing
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let verifier = Ed25519Verifier::new();
    ///
    /// let message = b"Hello, ONDC!";
    /// let signature = signer.sign_strict(message).unwrap();
    ///
    /// verifier.verify_strict(signer.public_key(), message, &signature).unwrap();
    /// ```
    pub fn verify_strict(
        &self,
        public_key: &[u8; PUBLIC_KEY_LENGTH],
        message: &[u8],
        signature: &[u8; SECRET_KEY_LENGTH * 2],
    ) -> Result<(), ONDCCryptoError> {
        // Validate input lengths
        validate_ed25519_public_key_length(public_key)?;
        validate_ed25519_signature_length(signature)?;

        // Convert to fixed-size arrays
        let mut key_bytes = [0u8; PUBLIC_KEY_LENGTH];
        let mut sig_bytes = [0u8; SECRET_KEY_LENGTH * 2]; // Signature is 64 bytes

        key_bytes.copy_from_slice(public_key);
        sig_bytes.copy_from_slice(signature);

        // Create verifying key
        let verifying_key = VerifyingKey::from_bytes(&key_bytes).map_err(|_| {
            ONDCCryptoError::InvalidKeyLength {
                expected: PUBLIC_KEY_LENGTH,
                got: public_key.len(),
            }
        })?;

        // Create signature
        let signature = Signature::from_bytes(&sig_bytes);

        // Perform strict verification
        use ed25519_dalek::Verifier;
        verifying_key
            .verify_strict(message, &signature)
            .map_err(|_| ONDCCryptoError::VerificationFailed)
    }

    /// Verify a signature with standard verification.
    ///
    /// This method performs standard signature verification. For most use cases,
    /// `verify_strict` is recommended as it provides better security.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The public key to verify against
    /// * `message` - The original message that was signed
    /// * `signature` - The signature to verify
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the signature is valid, or an error if verification fails.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The public key length is incorrect
    /// - The signature length is incorrect
    /// - The signature is invalid or malformed
    /// - The signature verification fails
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
    ///
    /// let signer = Ed25519Signer::generate().unwrap();
    /// let verifier = Ed25519Verifier::new();
    ///
    /// let message = b"Hello, ONDC!";
    /// let signature = signer.sign(message).unwrap();
    ///
    /// verifier.verify_standard(signer.public_key(), message, &signature).unwrap();
    /// ```
    pub fn verify_standard(
        &self,
        public_key: &[u8; PUBLIC_KEY_LENGTH],
        message: &[u8],
        signature: &[u8; SECRET_KEY_LENGTH * 2],
    ) -> Result<(), ONDCCryptoError> {
        // Validate input lengths
        validate_ed25519_public_key_length(public_key)?;
        validate_ed25519_signature_length(signature)?;

        // Convert to fixed-size arrays
        let mut key_bytes = [0u8; PUBLIC_KEY_LENGTH];
        let mut sig_bytes = [0u8; SECRET_KEY_LENGTH * 2]; // Signature is 64 bytes

        key_bytes.copy_from_slice(public_key);
        sig_bytes.copy_from_slice(signature);

        // Create verifying key
        let verifying_key = VerifyingKey::from_bytes(&key_bytes).map_err(|_| {
            ONDCCryptoError::InvalidKeyLength {
                expected: PUBLIC_KEY_LENGTH,
                got: public_key.len(),
            }
        })?;

        // Create signature
        let signature = Signature::from_bytes(&sig_bytes);

        // Perform standard verification
        use ed25519_dalek::Verifier;
        verifying_key
            .verify(message, &signature)
            .map_err(|_| ONDCCryptoError::VerificationFailed)
    }

    /// Check if a public key is weak (has low order).
    ///
    /// Weak public keys can be used to generate signatures that are valid
    /// for almost every message. This method can be used to check for this
    /// property before verification.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The public key to check
    ///
    /// # Returns
    ///
    /// Returns `true` if the public key is weak, `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::Ed25519Verifier;
    ///
    /// let verifier = Ed25519Verifier::new();
    /// let public_key = [0u8; 32]; // Example key
    ///
    /// if verifier.is_weak_key(&public_key) {
    ///     println!("Warning: Weak public key detected");
    /// }
    /// ```
    pub fn is_weak_key(&self, public_key: &[u8]) -> Result<bool, ONDCCryptoError> {
        // Validate public key length
        validate_ed25519_public_key_length(public_key)?;

        // Convert to fixed-size array
        let mut key_bytes = [0u8; PUBLIC_KEY_LENGTH];
        key_bytes.copy_from_slice(public_key);

        // Create verifying key
        let verifying_key = VerifyingKey::from_bytes(&key_bytes).map_err(|_| {
            ONDCCryptoError::InvalidKeyLength {
                expected: PUBLIC_KEY_LENGTH,
                got: public_key.len(),
            }
        })?;

        Ok(verifying_key.is_weak())
    }
}

impl Verifier for Ed25519Verifier {
    type Error = ONDCCryptoError;
    type PublicKey = Ed25519PublicKey;
    type Signature = Ed25519Signature;

    fn verify(
        &self,
        public_key: &Self::PublicKey,
        message: &[u8],
        signature: &Self::Signature,
    ) -> Result<(), Self::Error> {
        self.verify_strict(public_key, message, signature)
    }
}

impl PublicKey for Ed25519Verifier {
    type Error = ONDCCryptoError;

    fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Error> {
        validate_ed25519_public_key_length(bytes)?;
        Ok(Self::new())
    }

    fn to_bytes(&self) -> Vec<u8> {
        // This is a stateless verifier, so we return an empty vector
        // In practice, you would store the public key in the verifier
        Vec::new()
    }

    fn validate(&self) -> Result<(), Self::Error> {
        // This is a stateless verifier, so validation always succeeds
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;

    fn generate_test_keypair() -> (Ed25519Signer, Ed25519Verifier) {
        let signer = Ed25519Signer::generate().unwrap();
        let verifier = Ed25519Verifier::new();
        (signer, verifier)
    }

    #[test]
    fn test_ed25519_signer_creation() {
        let signer = Ed25519Signer::generate().unwrap();
        assert_eq!(signer.public_key().len(), PUBLIC_KEY_LENGTH);
        assert_eq!(signer.private_key().len(), SECRET_KEY_LENGTH);
    }

    #[test]
    fn test_ed25519_signer_from_private_key() {
        let original_signer = Ed25519Signer::generate().unwrap();
        let private_key = original_signer.private_key();

        let new_signer = Ed25519Signer::new(private_key).unwrap();
        assert_eq!(new_signer.public_key(), original_signer.public_key());
    }

    #[test]
    fn test_ed25519_signer_from_keypair() {
        let original_signer = Ed25519Signer::generate().unwrap();
        let keypair = original_signer.to_keypair_bytes();

        let new_signer = Ed25519Signer::from_keypair_bytes(&keypair).unwrap();
        assert_eq!(new_signer.public_key(), original_signer.public_key());
    }

    #[test]
    fn test_ed25519_signing_roundtrip() {
        let (signer, verifier) = generate_test_keypair();
        let message = b"Hello, ONDC!";

        let signature = signer.sign(message).unwrap();
        let public_key = signer.public_key();
        verifier.verify(&public_key, message, &signature).unwrap();
    }

    #[test]
    fn test_ed25519_strict_verification() {
        let (signer, verifier) = generate_test_keypair();
        let message = b"Hello, ONDC!";

        let signature = signer.sign_strict(message).unwrap();
        let public_key = signer.public_key();
        verifier
            .verify_strict(&public_key, message, &signature)
            .unwrap();
    }

    #[test]
    fn test_ed25519_invalid_signature_fails() {
        let (signer, verifier) = generate_test_keypair();
        let message = b"Hello, ONDC!";

        let mut signature = signer.sign(message).unwrap();
        signature[0] ^= 1; // Corrupt signature
        let public_key = signer.public_key();

        assert!(verifier.verify(&public_key, message, &signature).is_err());
    }

    #[test]
    fn test_ed25519_invalid_public_key_fails() {
        let (signer, verifier) = generate_test_keypair();
        let message = b"Hello, ONDC!";
        let signature = signer.sign(message).unwrap();

        let mut invalid_key = signer.public_key();
        invalid_key[0] ^= 1; // Corrupt public key

        assert!(verifier.verify(&invalid_key, message, &signature).is_err());
    }

    #[test]
    fn test_ed25519_invalid_private_key_length() {
        let invalid_key = [0u8; 16]; // Wrong length
        assert!(Ed25519Signer::new(&invalid_key).is_err());
    }

    #[test]
    fn test_ed25519_invalid_public_key_length() {
        let verifier = Ed25519Verifier::new();
        let invalid_key = [0u8; 16]; // Wrong length
        let signature = [0u8; 64];
        let message = b"test";

        // This should fail at compile time due to type mismatch
        // assert!(verifier.verify(&invalid_key, message, &signature).is_err());
    }

    #[test]
    fn test_ed25519_invalid_signature_length() {
        let (signer, verifier) = generate_test_keypair();
        let message = b"test";
        // This test is now handled by the type system - wrong signature length won't compile
        // let invalid_signature = [0u8; 32]; // Wrong length
        // let public_key = signer.public_key();
        // assert!(verifier.verify(&public_key, message, &invalid_signature).is_err());
    }

    #[test]
    fn test_ed25519_keypair_trait() {
        let signer = Ed25519Signer::generate().unwrap();

        // Test KeyPair trait methods
        let public_key = signer.public_key();
        let private_key = signer.private_key();

        assert_eq!(public_key.len(), PUBLIC_KEY_LENGTH);
        assert_eq!(private_key.len(), SECRET_KEY_LENGTH);
    }

    #[test]
    fn test_ed25519_signer_clone() {
        let signer = Ed25519Signer::generate().unwrap();
        let cloned_signer = signer.clone();

        let message = b"test message";
        let signature1 = signer.sign(message).unwrap();
        let signature2 = cloned_signer.sign(message).unwrap();

        assert_eq!(signature1, signature2);
    }

    #[test]
    fn test_ed25519_verifier_clone() {
        let verifier1 = Ed25519Verifier::new();
        let verifier2 = verifier1.clone();

        // Both should work identically
        assert_eq!(verifier1.to_bytes(), verifier2.to_bytes());
    }

    #[test]
    fn test_ed25519_deterministic_signing() {
        let signer = Ed25519Signer::generate().unwrap();
        let message = b"deterministic test message";

        let signature1 = signer.sign(message).unwrap();
        let signature2 = signer.sign(message).unwrap();

        assert_eq!(signature1, signature2);
    }

    #[test]
    fn test_ed25519_different_messages_different_signatures() {
        let signer = Ed25519Signer::generate().unwrap();
        let message1 = b"message 1";
        let message2 = b"message 2";

        let signature1 = signer.sign(message1).unwrap();
        let signature2 = signer.sign(message2).unwrap();

        assert_ne!(signature1, signature2);
    }
}

================
File: ondc-crypto-algorithms/src/lib.rs
================
//! Cryptographic algorithm implementations for ONDC.
//!
//! This crate provides implementations of cryptographic algorithms used in
//! ONDC operations, including Ed25519 signing, BLAKE2 hashing, and X25519
//! key exchange.

pub mod blake2;
pub mod ed25519;
pub mod x25519;
pub mod aes;

pub use blake2::Blake2Hasher;
pub use ed25519::{Ed25519Signer, Ed25519Verifier};
pub use x25519::X25519KeyExchange;
pub use aes::{decrypt_aes256_ecb, encrypt_aes256_ecb};

/// Re-export commonly used types
pub mod prelude {
    pub use super::blake2::Blake2Hasher;
    pub use super::ed25519::{Ed25519Signer, Ed25519Verifier};
    pub use super::x25519::X25519KeyExchange;
}

================
File: ondc-crypto-algorithms/src/x25519.rs
================
//! X25519 key exchange implementation.
//!
//! This module provides X25519 elliptic curve Diffie-Hellman key exchange
//! functionality using the x25519-dalek library. It implements secure key
//! generation, key exchange, and shared secret derivation.
//!
//! # Security Features
//!
//! - Constant-time key exchange operations to prevent timing attacks
//! - Memory-safe key handling with automatic zeroization
//! - Support for both ephemeral and static key exchange
//! - Comprehensive input validation and error handling
//! - Protection against weak key attacks
//!
//! # Examples
//!
//! ```rust
//! use ondc_crypto_algorithms::X25519KeyExchange;
//! use ondc_crypto_traits::{KeyPair, PublicKey};
//!
//! // Generate key pairs for Alice and Bob
//! let alice_keypair = X25519KeyExchange::generate().unwrap();
//! let bob_keypair = X25519KeyExchange::generate().unwrap();
//!
//! // Perform key exchange
//! let alice_shared = alice_keypair.diffie_hellman(bob_keypair.public_key()).unwrap();
//! let bob_shared = bob_keypair.diffie_hellman(alice_keypair.public_key()).unwrap();
//!
//! // Both parties now have the same shared secret
//! assert_eq!(alice_shared.as_ref(), bob_shared.as_ref());
//! ```

use ondc_crypto_traits::{
    KeyPair, ONDCCryptoError, PublicKey, X25519PrivateKey as ONDCX25519PrivateKey,
    X25519PublicKey as ONDCX25519PublicKey, X25519_PRIVATE_KEY_LENGTH, X25519_PUBLIC_KEY_LENGTH,
};
use x25519_dalek::{
    EphemeralSecret, PublicKey as X25519PublicKey, StaticSecret, X25519_BASEPOINT_BYTES,
};
use zeroize::{Zeroize, Zeroizing};

/// X25519 key exchange implementation.
///
/// This struct provides X25519 elliptic curve Diffie-Hellman key exchange
/// capabilities. It supports both ephemeral and static key exchange patterns
/// and provides secure key generation and validation.
///
/// # Security Features
///
/// - Automatic memory zeroization of sensitive data
/// - Constant-time key exchange operations
/// - Input validation for all operations
/// - Protection against weak key attacks
/// - Support for both ephemeral and static key patterns
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_algorithms::X25519KeyExchange;
/// use ondc_crypto_traits::KeyPair;
///
/// // Generate a new key pair
/// let keypair = X25519KeyExchange::generate().unwrap();
///
/// // Get the public key for exchange
/// let public_key = keypair.public_key();
///
/// // Perform key exchange with another party's public key
/// let other_public_key = [0u8; 32]; // In practice, this would come from another party
/// let shared_secret = keypair.diffie_hellman(&other_public_key).unwrap();
/// ```
#[derive(Zeroize)]
#[zeroize(drop)]
pub struct X25519KeyExchange {
    /// The underlying x25519-dalek static secret
    secret: StaticSecret,
}

impl X25519KeyExchange {
    /// Create a new X25519 key exchange instance from a private key.
    ///
    /// # Arguments
    ///
    /// * `private_key` - The 32-byte X25519 private key
    ///
    /// # Returns
    ///
    /// Returns a new X25519KeyExchange instance if the private key is valid.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The private key length is incorrect
    /// - The private key is invalid or malformed
    ///
    /// # Security Notes
    ///
    /// - The private key should be handled securely
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    /// - The private key material will be automatically zeroized when the instance is dropped
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let private_key = [0u8; 32]; // Use a real private key in practice
    /// let keypair = X25519KeyExchange::new(&private_key).unwrap();
    /// ```
    pub fn new(private_key: &[u8]) -> Result<Self, ONDCCryptoError> {
        // Validate private key length
        if private_key.len() != X25519_PRIVATE_KEY_LENGTH {
            return Err(ONDCCryptoError::InvalidKeyLength {
                expected: X25519_PRIVATE_KEY_LENGTH,
                got: private_key.len(),
            });
        }

        // Convert to fixed-size array
        let mut key_bytes = [0u8; X25519_PRIVATE_KEY_LENGTH];
        key_bytes.copy_from_slice(private_key);

        // Create static secret from bytes
        let secret = StaticSecret::from(key_bytes);

        Ok(Self { secret })
    }

    /// Generate a new X25519 key exchange instance with a random private key.
    ///
    /// # Returns
    ///
    /// Returns a new X25519KeyExchange instance with a cryptographically secure random key.
    ///
    /// # Errors
    ///
    /// Returns an error if key generation fails due to insufficient entropy.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let keypair = X25519KeyExchange::generate().unwrap();
    /// ```
    pub fn generate() -> Result<Self, ONDCCryptoError> {
        use rand::rngs::OsRng;

        let mut csprng = OsRng;
        let secret = StaticSecret::random_from_rng(&mut csprng);
        Ok(Self { secret })
    }

    /// Get the public key associated with this key exchange instance.
    ///
    /// # Returns
    ///
    /// Returns the public key as a byte array.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let keypair = X25519KeyExchange::generate().unwrap();
    /// let public_key = keypair.public_key();
    /// assert_eq!(public_key.len(), 32);
    /// ```
    pub fn public_key(&self) -> ONDCX25519PublicKey {
        let public_key = X25519PublicKey::from(&self.secret);
        *public_key.as_bytes()
    }

    /// Get the private key bytes.
    ///
    /// # Returns
    ///
    /// Returns the private key as a byte array.
    ///
    /// # Security Notes
    ///
    /// - This method should be used carefully as it exposes private key material
    /// - Callers should ensure the returned data is handled securely
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let keypair = X25519KeyExchange::generate().unwrap();
    /// let private_key = keypair.private_key();
    /// assert_eq!(private_key.len(), 32);
    /// ```
    pub fn private_key(&self) -> &[u8; X25519_PRIVATE_KEY_LENGTH] {
        self.secret.as_bytes()
    }

    /// Perform a Diffie-Hellman key exchange with another party's public key.
    ///
    /// # Arguments
    ///
    /// * `their_public_key` - The other party's public key
    ///
    /// # Returns
    ///
    /// Returns the shared secret derived from the key exchange.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The public key length is incorrect
    /// - The public key is invalid or malformed
    /// - The key exchange fails
    ///
    /// # Security Notes
    ///
    /// - The shared secret should be handled securely
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    /// - The shared secret should be used to derive encryption keys, not used directly
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let alice = X25519KeyExchange::generate().unwrap();
    /// let bob = X25519KeyExchange::generate().unwrap();
    ///
    /// let alice_shared = alice.diffie_hellman(bob.public_key()).unwrap();
    /// let bob_shared = bob.diffie_hellman(alice.public_key()).unwrap();
    ///
    /// assert_eq!(alice_shared.as_ref(), bob_shared.as_ref());
    /// ```
    pub fn diffie_hellman(
        &self,
        their_public_key: &[u8],
    ) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
        // Validate public key length
        if their_public_key.len() != X25519_PUBLIC_KEY_LENGTH {
            return Err(ONDCCryptoError::InvalidKeyLength {
                expected: X25519_PUBLIC_KEY_LENGTH,
                got: their_public_key.len(),
            });
        }

        // Convert to fixed-size array
        let mut key_bytes = [0u8; X25519_PUBLIC_KEY_LENGTH];
        key_bytes.copy_from_slice(their_public_key);

        // Create public key from bytes
        let their_public = X25519PublicKey::from(key_bytes);

        // Perform key exchange
        let shared_secret = self.secret.diffie_hellman(&their_public);

        // Check for weak key attack (non-contributory behavior)
        if !shared_secret.was_contributory() {
            return Err(ONDCCryptoError::ConfigError(
                "Key exchange resulted in weak shared secret".into(),
            ));
        }

        Ok(Zeroizing::new(shared_secret.as_bytes().to_vec()))
    }

    /// Perform an ephemeral Diffie-Hellman key exchange.
    ///
    /// This method creates a new ephemeral secret for each key exchange,
    /// providing forward secrecy.
    ///
    /// # Arguments
    ///
    /// * `their_public_key` - The other party's public key
    ///
    /// # Returns
    ///
    /// Returns a tuple of (ephemeral_public_key, shared_secret).
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The public key length is incorrect
    /// - The public key is invalid or malformed
    /// - The key exchange fails
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let bob_public_key = [0u8; 32]; // In practice, this would come from Bob
    /// let (alice_ephemeral_public, shared_secret) =
    ///     X25519KeyExchange::ephemeral_diffie_hellman(&bob_public_key).unwrap();
    /// ```
    pub fn ephemeral_diffie_hellman(
        their_public_key: &[u8],
    ) -> Result<(ONDCX25519PublicKey, Zeroizing<Vec<u8>>), ONDCCryptoError> {
        use rand::rngs::OsRng;

        // Validate public key length
        if their_public_key.len() != X25519_PUBLIC_KEY_LENGTH {
            return Err(ONDCCryptoError::InvalidKeyLength {
                expected: X25519_PUBLIC_KEY_LENGTH,
                got: their_public_key.len(),
            });
        }

        // Generate ephemeral secret
        let mut csprng = OsRng;
        let ephemeral_secret = EphemeralSecret::random_from_rng(&mut csprng);

        // Get ephemeral public key first (before consuming the secret)
        let ephemeral_public = X25519PublicKey::from(&ephemeral_secret);

        // Convert their public key to fixed-size array
        let mut key_bytes = [0u8; X25519_PUBLIC_KEY_LENGTH];
        key_bytes.copy_from_slice(their_public_key);
        let their_public = X25519PublicKey::from(key_bytes);

        // Perform key exchange (consumes ephemeral_secret)
        let shared_secret = ephemeral_secret.diffie_hellman(&their_public);

        Ok((
            *ephemeral_public.as_bytes(),
            Zeroizing::new(shared_secret.as_bytes().to_vec()),
        ))
    }

    /// Validate a public key for security.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The public key to validate
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the public key is valid, or an error if validation fails.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let public_key = [0u8; 32];
    /// X25519KeyExchange::validate_public_key(&public_key).unwrap();
    /// ```
    pub fn validate_public_key(public_key: &[u8]) -> Result<(), ONDCCryptoError> {
        // Check length
        if public_key.len() != X25519_PUBLIC_KEY_LENGTH {
            return Err(ONDCCryptoError::InvalidKeyLength {
                expected: X25519_PUBLIC_KEY_LENGTH,
                got: public_key.len(),
            });
        }

        // Convert to fixed-size array
        let mut key_bytes = [0u8; X25519_PUBLIC_KEY_LENGTH];
        key_bytes.copy_from_slice(public_key);

        // Try to create public key from bytes
        let _public_key = X25519PublicKey::from(key_bytes);

        Ok(())
    }

    /// Get the X25519 basepoint for testing and validation.
    ///
    /// # Returns
    ///
    /// Returns the X25519 basepoint as a byte array.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use ondc_crypto_algorithms::X25519KeyExchange;
    ///
    /// let basepoint = X25519KeyExchange::basepoint();
    /// assert_eq!(basepoint.len(), 32);
    /// ```
    pub fn basepoint() -> ONDCX25519PublicKey {
        X25519_BASEPOINT_BYTES
    }
}

impl KeyPair for X25519KeyExchange {
    type Error = ONDCCryptoError;
    type PrivateKey = ONDCX25519PrivateKey;
    type PublicKey = ONDCX25519PublicKey;

    fn generate() -> Result<Self, Self::Error> {
        Self::generate()
    }

    fn from_private_key(private_key: &[u8]) -> Result<Self, Self::Error> {
        Self::new(private_key)
    }

    fn public_key(&self) -> &Self::PublicKey {
        // We need to return a reference, but we can't store it in the struct
        // This is a limitation of the trait design for X25519
        // For now, we'll use a different approach by storing the public key
        // This is not ideal but works for the trait implementation
        static mut PUBLIC_KEY_CACHE: Option<ONDCX25519PublicKey> = None;

        unsafe {
            PUBLIC_KEY_CACHE = Some(self.public_key());
            PUBLIC_KEY_CACHE.as_ref().unwrap()
        }
    }

    fn private_key(&self) -> &Self::PrivateKey {
        self.private_key()
    }
}

impl PublicKey for X25519KeyExchange {
    type Error = ONDCCryptoError;

    fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Error> {
        // For X25519, we can't create a key exchange instance from just a public key
        // This would require a private key. Instead, we'll validate the public key.
        Self::validate_public_key(bytes)?;

        // Return a dummy instance for validation purposes
        // In practice, this method might not be used for X25519
        Err(ONDCCryptoError::ConfigError(
            "Cannot create X25519KeyExchange from public key only".into(),
        ))
    }

    fn to_bytes(&self) -> Vec<u8> {
        self.public_key().to_vec()
    }

    fn validate(&self) -> Result<(), Self::Error> {
        // The key is already validated during creation
        Ok(())
    }
}

impl Clone for X25519KeyExchange {
    fn clone(&self) -> Self {
        // Clone the secret bytes and create a new instance
        let secret_bytes = self.secret.to_bytes();
        Self::new(&secret_bytes).expect("Cloned key should be valid")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ondc_crypto_traits::{KeyPair, PublicKey};

    fn generate_test_keypair() -> X25519KeyExchange {
        X25519KeyExchange::generate().expect("Failed to generate test keypair")
    }

    #[test]
    fn test_x25519_keypair_creation() {
        let keypair = generate_test_keypair();
        assert_eq!(keypair.public_key().len(), X25519_PUBLIC_KEY_LENGTH);
        assert_eq!(keypair.private_key().len(), X25519_PRIVATE_KEY_LENGTH);
    }

    #[test]
    fn test_x25519_keypair_from_private_key() {
        let original = generate_test_keypair();
        let private_key = original.private_key();

        let keypair =
            X25519KeyExchange::new(private_key).expect("Failed to create from private key");
        assert_eq!(keypair.public_key(), original.public_key());
    }

    // #[test]
    // fn test_x25519_diffie_hellman_roundtrip() {
    //     let alice = generate_test_keypair();
    //     let bob = generate_test_keypair();
    //
    //     let alice_shared = alice.diffie_hellman(&bob.public_key()).expect("Alice DH failed");
    //     let bob_shared = bob.diffie_hellman(&alice.public_key()).expect("Bob DH failed");
    //
    //     let alice_slice: &[u8] = alice_shared.as_ref();
    //     let bob_slice: &[u8] = bob_shared.as_ref();
    //     assert_eq!(alice_slice, bob_slice);
    // }

    // #[test]
    // fn test_x25519_ephemeral_diffie_hellman() {
    //     let bob = generate_test_keypair();
    //     let bob_public = bob.public_key();

    //     let (alice_ephemeral_public, alice_shared) =
    //         X25519KeyExchange::ephemeral_diffie_hellman(&bob_public).expect("Ephemeral DH failed");

    //     let bob_shared = bob.diffie_hellman(&alice_ephemeral_public).expect("Bob DH failed");

    //     assert_eq!(alice_shared.as_ref(), bob_shared.as_ref());
    // }

    #[test]
    fn test_x25519_invalid_private_key_length() {
        let invalid_key = [0u8; 16]; // Wrong length
        let result = X25519KeyExchange::new(&invalid_key);
        assert!(result.is_err());
    }

    #[test]
    fn test_x25519_invalid_public_key_length() {
        let keypair = generate_test_keypair();
        let invalid_public = [0u8; 16]; // Wrong length

        let result = keypair.diffie_hellman(&invalid_public);
        assert!(result.is_err());
    }

    #[test]
    fn test_x25519_public_key_validation() {
        let keypair = generate_test_keypair();
        let public_key = keypair.public_key();

        X25519KeyExchange::validate_public_key(&public_key)
            .expect("Valid public key should pass validation");
    }

    #[test]
    fn test_x25519_basepoint() {
        let basepoint = X25519KeyExchange::basepoint();
        assert_eq!(basepoint.len(), X25519_PUBLIC_KEY_LENGTH);
        assert_eq!(basepoint[0], 9); // X25519 basepoint starts with 9
    }

    #[test]
    fn test_x25519_keypair_trait() {
        let keypair = X25519KeyExchange::generate().expect("Failed to generate keypair");

        // Test KeyPair trait methods
        let public_key = keypair.public_key();
        let private_key = keypair.private_key();

        assert_eq!(public_key.len(), X25519_PUBLIC_KEY_LENGTH);
        assert_eq!(private_key.len(), X25519_PRIVATE_KEY_LENGTH);
    }

    #[test]
    fn test_x25519_keypair_clone() {
        let original = generate_test_keypair();
        let cloned = original.clone();

        assert_eq!(original.public_key(), cloned.public_key());
        assert_eq!(original.private_key(), cloned.private_key());
    }

    #[test]
    fn test_x25519_different_keypairs_different_public_keys() {
        let keypair1 = generate_test_keypair();
        let keypair2 = generate_test_keypair();

        assert_ne!(keypair1.public_key(), keypair2.public_key());
    }

    #[test]
    fn test_x25519_weak_key_protection() {
        // Test with zero public key (weak key)
        let keypair = generate_test_keypair();
        let zero_public_key = [0u8; X25519_PUBLIC_KEY_LENGTH];

        let result = keypair.diffie_hellman(&zero_public_key);
        assert!(result.is_err()); // Should fail due to weak key protection
    }
}

================
File: ondc-crypto-cli/src/main.rs
================
use clap::{Parser, Subcommand};
use ondc_crypto_algorithms::{prelude::*, encrypt_aes256_ecb};
use ondc_crypto_formats::prelude::*;
use ondc_crypto_traits::traits::{Hasher, Signer, Verifier};
use std::io::{self, Read};

#[derive(Parser)]
#[command(name = "ondc-crypto")]
#[command(about = "ONDC Cryptographic CLI Utilities")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate cryptographic keys
    Generate {
        /// Type of key to generate
        #[arg(value_enum)]
        key_type: KeyType,

        /// Output format for the keys
        #[arg(short, long, value_enum, default_value_t = OutputFormat::Base64)]
        format: OutputFormat,

        /// Output to JSON format
        #[arg(short, long)]
        json: bool,
    },

    /// Sign data with Ed25519
    Sign {
        /// Private key in base64 format
        #[arg(short, long)]
        private_key: String,

        /// Data to sign (if not provided, reads from stdin)
        #[arg(short, long)]
        data: Option<String>,

        /// Output format for the signature
        #[arg(short, long, value_enum, default_value_t = OutputFormat::Base64)]
        format: OutputFormat,
    },

    /// Verify Ed25519 signature
    Verify {
        /// Public key in base64 format
        #[arg(short, long)]
        public_key: String,

        /// Signature to verify
        #[arg(short, long)]
        signature: String,

        /// Data that was signed (if not provided, reads from stdin)
        #[arg(short, long)]
        data: Option<String>,
    },

    /// Hash data with BLAKE2
    Hash {
        /// Data to hash (if not provided, reads from stdin)
        #[arg(short, long)]
        data: Option<String>,

        /// Output format for the hash
        #[arg(short, long, value_enum, default_value_t = OutputFormat::Hex)]
        format: OutputFormat,
    },

    /// Generate ONDC test challenge
    Challenge {
        /// Challenge data to encrypt (if not provided, uses default test data)
        #[arg(short, long)]
        data: Option<String>,

        /// Your X25519 private key in base64 format
        #[arg(short, long)]
        private_key: String,

        /// ONDC environment (staging, preprod, production)
        #[arg(short, long, value_enum, default_value_t = ONDCEnvironment::Staging)]
        environment: ONDCEnvironment,

        /// Output to JSON format
        #[arg(short, long)]
        json: bool,
    },
}

#[derive(clap::ValueEnum, Clone)]
enum KeyType {
    Ed25519,
    X25519,
}

#[derive(clap::ValueEnum, Clone)]
enum OutputFormat {
    Base64,
    Hex,
    Raw,
}

#[derive(clap::ValueEnum, Clone)]
enum ONDCEnvironment {
    Staging,
    PreProd,
    Production,
}

impl std::fmt::Display for ONDCEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ONDCEnvironment::Staging => write!(f, "staging"),
            ONDCEnvironment::PreProd => write!(f, "preprod"),
            ONDCEnvironment::Production => write!(f, "production"),
        }
    }
}

#[derive(serde::Serialize)]
struct KeyPairOutput {
    private_key: String,
    public_key: String,
    key_type: String,
}

fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt::init();

    let cli = Cli::parse();

    match cli.command {
        Commands::Generate {
            key_type,
            format,
            json,
        } => {
            generate_keys(key_type, format, json)?;
        }
        Commands::Sign {
            private_key,
            data,
            format,
        } => {
            sign_data(private_key, data, format)?;
        }
        Commands::Verify {
            public_key,
            signature,
            data,
        } => {
            verify_signature(public_key, signature, data)?;
        }
        Commands::Hash { data, format } => {
            hash_data(data, format)?;
        }
        Commands::Challenge {
            data,
            private_key,
            environment,
            json,
        } => {
            generate_challenge(data, private_key, environment, json)?;
        }
    }

    Ok(())
}

fn generate_keys(key_type: KeyType, format: OutputFormat, json: bool) -> anyhow::Result<()> {
    match key_type {
        KeyType::Ed25519 => {
            let signer = Ed25519Signer::generate()?;
            let private_key = signer.private_key();
            let public_key = signer.public_key();

            let private_key_str = format_key(private_key, &format);
            let public_key_str = format_key(&public_key, &format);

            if json {
                let key_pair = KeyPairOutput {
                    private_key: private_key_str,
                    public_key: public_key_str,
                    key_type: "Ed25519".to_string(),
                };
                println!("{}", serde_json::to_string_pretty(&key_pair)?);
            } else {
                println!("Ed25519 Key Pair:");
                println!("Private Key: {}", private_key_str);
                println!("Public Key:  {}", public_key_str);
            }
        }
        KeyType::X25519 => {
            let key_exchange = X25519KeyExchange::generate()?;
            let private_key = key_exchange.private_key();
            let public_key = key_exchange.public_key();

            let private_key_str = format_key(private_key, &format);
            let public_key_str = format_key(&public_key, &format);

            if json {
                let key_pair = KeyPairOutput {
                    private_key: private_key_str,
                    public_key: public_key_str,
                    key_type: "X25519".to_string(),
                };
                println!("{}", serde_json::to_string_pretty(&key_pair)?);
            } else {
                println!("X25519 Key Pair:");
                println!("Private Key: {}", private_key_str);
                println!("Public Key:  {}", public_key_str);
            }
        }
    }

    Ok(())
}

fn sign_data(
    private_key: String,
    data: Option<String>,
    format: OutputFormat,
) -> anyhow::Result<()> {
    // Decode private key
    let private_key_bytes = ed25519_private_key_from_base64(&private_key)?;
    let signer = Ed25519Signer::new(&private_key_bytes)?;

    // Get data to sign
    let data_to_sign = if let Some(data) = data {
        data.into_bytes()
    } else {
        let mut buffer = Vec::new();
        io::stdin().read_to_end(&mut buffer)?;
        buffer
    };

    // Sign the data
    let signature = signer.sign(&data_to_sign)?;
    let signature_str = format_signature(&signature, &format);

    println!("{}", signature_str);
    Ok(())
}

fn verify_signature(
    public_key: String,
    signature: String,
    data: Option<String>,
) -> anyhow::Result<()> {
    // Decode public key
    let public_key_bytes = ed25519_public_key_from_base64(&public_key)?;
    let verifier = Ed25519Verifier::new();

    // Decode signature
    let signature_bytes = decode_signature(&signature)?;

    // Get data that was signed
    let data_to_verify = if let Some(data) = data {
        data.into_bytes()
    } else {
        let mut buffer = Vec::new();
        io::stdin().read_to_end(&mut buffer)?;
        buffer
    };

    // Convert public key to fixed-size array
    let mut public_key_array = [0u8; 32];
    public_key_array.copy_from_slice(&public_key_bytes);

    // Convert signature to fixed-size array
    let mut signature_array = [0u8; 64];
    signature_array.copy_from_slice(&signature_bytes);

    // Verify the signature
    match verifier.verify(&public_key_array, &data_to_verify, &signature_array) {
        Ok(_) => {
            println!("âœ“ Signature is valid");
            std::process::exit(0);
        }
        Err(_) => {
            eprintln!("âœ— Signature is invalid");
            std::process::exit(1);
        }
    }
}

fn hash_data(data: Option<String>, format: OutputFormat) -> anyhow::Result<()> {
    let hasher = Blake2Hasher::new();

    // Get data to hash
    let data_to_hash = if let Some(data) = data {
        data.into_bytes()
    } else {
        let mut buffer = Vec::new();
        io::stdin().read_to_end(&mut buffer)?;
        buffer
    };

    // Hash the data
    let hash = hasher.hash(&data_to_hash)?;
    let hash_str = format_hash(&hash, &format);

    println!("{}", hash_str);
    Ok(())
}

fn generate_challenge(
    data: Option<String>,
    private_key: String,
    environment: ONDCEnvironment,
    json: bool,
) -> anyhow::Result<()> {
    // Decode private key from base64
    let private_key_bytes = x25519_private_key_from_base64(&private_key)?;
    let key_exchange = X25519KeyExchange::new(&private_key_bytes)?;

    // Get ONDC public key for the environment
    let ondc_public_key = get_ondc_public_key(environment.clone())?;

    // Generate shared secret using X25519 key exchange
    let shared_secret = key_exchange.diffie_hellman(&ondc_public_key)?;

    // Prepare challenge data
    let challenge_data = if let Some(data) = data {
        data.into_bytes()
    } else {
        b"This is a test challenge for ONDC".to_vec()
    };

    // Encrypt challenge using AES-256-ECB with shared secret
    let encrypted_challenge = encrypt_aes256_ecb(&challenge_data, &shared_secret)?;

    if json {
        let challenge_output = ChallengeOutput {
            encrypted_challenge: encode_signature(&encrypted_challenge),
            environment: environment.to_string(),
            original_data: String::from_utf8_lossy(&challenge_data).to_string(),
        };
        println!("{}", serde_json::to_string_pretty(&challenge_output)?);
    } else {
        println!("ONDC Test Challenge Generated:");
        println!("Encrypted Challenge (Base64):");
        println!("{}", encode_signature(&encrypted_challenge));
        println!("Environment: {}", environment);
        println!("Original Data: {}", String::from_utf8_lossy(&challenge_data));
    }

    Ok(())
}

fn get_ondc_public_key(environment: ONDCEnvironment) -> anyhow::Result<[u8; 32]> {
    let public_key_b64 = match environment {
        ONDCEnvironment::Staging => "MCowBQYDK2VuAyEAduMuZgmtpjdCuxv+Nc49K0cB6tL/Dj3HZetvVN7ZekM=",
        ONDCEnvironment::PreProd => "MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=",
        ONDCEnvironment::Production => "MCowBQYDK2VuAyEAvVEyZY91O2yV8w8/CAwVDAnqIZDJJUPdLUUKwLo3K0M=",
    };

    let decoded = decode_signature(public_key_b64)?;
    
    // Extract raw key from DER format (last 32 bytes)
    if decoded.len() < 32 {
        return Err(anyhow::anyhow!("ONDC public key too short"));
    }
    
    let mut key = [0u8; 32];
    key.copy_from_slice(&decoded[decoded.len() - 32..]);
    Ok(key)
}

fn x25519_private_key_from_base64(private_key_b64: &str) -> anyhow::Result<[u8; 32]> {
    let decoded = decode_signature(private_key_b64)?;
    if decoded.len() != 32 {
        return Err(anyhow::anyhow!("X25519 private key must be 32 bytes"));
    }
    
    let mut key = [0u8; 32];
    key.copy_from_slice(&decoded);
    Ok(key)
}

#[derive(serde::Serialize)]
struct ChallengeOutput {
    encrypted_challenge: String,
    environment: String,
    original_data: String,
}

fn format_key(key: &[u8], format: &OutputFormat) -> String {
    match format {
        OutputFormat::Base64 => encode_signature(key),
        OutputFormat::Hex => hex::encode(key),
        OutputFormat::Raw => String::from_utf8_lossy(key).to_string(),
    }
}

fn format_signature(signature: &[u8], format: &OutputFormat) -> String {
    match format {
        OutputFormat::Base64 => encode_signature(signature),
        OutputFormat::Hex => hex::encode(signature),
        OutputFormat::Raw => String::from_utf8_lossy(signature).to_string(),
    }
}

fn format_hash(hash: &[u8], format: &OutputFormat) -> String {
    match format {
        OutputFormat::Base64 => encode_signature(hash),
        OutputFormat::Hex => hex::encode(hash),
        OutputFormat::Raw => String::from_utf8_lossy(hash).to_string(),
    }
}

================
File: ondc-crypto-formats/src/base64.rs
================
//! Base64 encoding and decoding utilities for ONDC cryptographic operations.
//!
//! This module provides secure Base64 encoding and decoding functions that are
//! compatible with the ONDC protocol and the Node.js implementation.
//!
//! # Security Considerations
//!
//! - All encoding operations use constant-time implementations where possible
//! - Sensitive data is automatically zeroized when using `Zeroizing` types
//! - Input validation prevents buffer overflow attacks
//! - Error messages do not leak sensitive information

use base64::engine::general_purpose::{STANDARD, URL_SAFE, URL_SAFE_NO_PAD};
use base64::engine::Engine;
use ondc_crypto_traits::ONDCCryptoError;
use zeroize::{Zeroize, Zeroizing};

/// Base64 encoding variants supported by ONDC
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Base64Variant {
    /// Standard Base64 encoding (RFC 4648)
    Standard,
    /// URL-safe Base64 encoding (RFC 4648)
    UrlSafe,
    /// URL-safe Base64 encoding without padding
    UrlSafeNoPad,
}

impl Default for Base64Variant {
    fn default() -> Self {
        Self::Standard
    }
}

/// Encode signature for ONDC headers using standard Base64 encoding.
///
/// This function uses the same encoding as the Node.js implementation
/// (`_sodium.base64_variants.ORIGINAL`).
///
/// # Arguments
///
/// * `signature` - The signature bytes to encode
///
/// # Returns
///
/// A Base64-encoded string suitable for use in ONDC authorization headers.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::encode_signature;
///
/// let signature = [0x01, 0x02, 0x03, 0x04];
/// let encoded = encode_signature(&signature);
/// assert_eq!(encoded, "AQIDBA==");
/// ```
///
/// # Security
///
/// This function does not handle sensitive data directly. For sensitive data,
/// use `encode_signature_secure()`.
pub fn encode_signature(signature: &[u8]) -> String {
    STANDARD.encode(signature)
}

/// Encode signature with specified Base64 variant.
///
/// # Arguments
///
/// * `signature` - The signature bytes to encode
/// * `variant` - The Base64 encoding variant to use
///
/// # Returns
///
/// A Base64-encoded string using the specified variant.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::{encode_signature_variant, Base64Variant};
///
/// let signature = [0x01, 0x02, 0x03, 0x04];
/// let encoded = encode_signature_variant(&signature, Base64Variant::UrlSafe);
/// assert_eq!(encoded, "AQIDBA==");
/// ```
pub fn encode_signature_variant(signature: &[u8], variant: Base64Variant) -> String {
    match variant {
        Base64Variant::Standard => STANDARD.encode(signature),
        Base64Variant::UrlSafe => URL_SAFE.encode(signature),
        Base64Variant::UrlSafeNoPad => URL_SAFE_NO_PAD.encode(signature),
    }
}

/// Encode signature securely with automatic zeroization.
///
/// This function is designed for encoding sensitive data that should be
/// automatically zeroized after use.
///
/// # Arguments
///
/// * `signature` - The signature bytes to encode (will be zeroized after encoding)
///
/// # Returns
///
/// A Base64-encoded string with the original data zeroized.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::encode_signature_secure;
/// use zeroize::Zeroizing;
///
/// let mut signature = Zeroizing::new(vec![0x01, 0x02, 0x03, 0x04]);
/// let encoded = encode_signature_secure(&mut signature);
/// // signature is now zeroized
/// ```
///
/// # Security
///
/// The input signature is automatically zeroized after encoding to prevent
/// memory disclosure of sensitive data.
pub fn encode_signature_secure(signature: &mut Zeroizing<Vec<u8>>) -> String {
    let encoded = STANDARD.encode(signature.as_slice());
    // Zeroize the sensitive data
    signature.zeroize();
    encoded
}

/// Decode signature with validation.
///
/// This function decodes Base64-encoded signatures and validates the output.
/// It uses the same decoding as the Node.js implementation.
///
/// # Arguments
///
/// * `encoded` - The Base64-encoded signature string
///
/// # Returns
///
/// The decoded signature bytes, or an error if decoding fails.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::decode_signature;
///
/// let encoded = "AQIDBA==";
/// let decoded = decode_signature(encoded).unwrap();
/// assert_eq!(decoded, vec![0x01, 0x02, 0x03, 0x04]);
/// ```
///
/// # Errors
///
/// Returns `ONDCCryptoError::EncodingError` if the input is not valid Base64.
pub fn decode_signature(encoded: &str) -> Result<Vec<u8>, ONDCCryptoError> {
    STANDARD
        .decode(encoded)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("Invalid Base64 encoding: {}", e)))
}

/// Decode signature with specified Base64 variant.
///
/// # Arguments
///
/// * `encoded` - The Base64-encoded signature string
/// * `variant` - The Base64 encoding variant to use for decoding
///
/// # Returns
///
/// The decoded signature bytes, or an error if decoding fails.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::{decode_signature_variant, Base64Variant};
///
/// let encoded = "AQIDBA==";
/// let decoded = decode_signature_variant(encoded, Base64Variant::Standard).unwrap();
/// assert_eq!(decoded, vec![0x01, 0x02, 0x03, 0x04]);
/// ```
///
/// # Errors
///
/// Returns `ONDCCryptoError::EncodingError` if the input is not valid Base64
/// for the specified variant.
pub fn decode_signature_variant(
    encoded: &str,
    variant: Base64Variant,
) -> Result<Vec<u8>, ONDCCryptoError> {
    let result = match variant {
        Base64Variant::Standard => STANDARD.decode(encoded),
        Base64Variant::UrlSafe => URL_SAFE.decode(encoded),
        Base64Variant::UrlSafeNoPad => URL_SAFE_NO_PAD.decode(encoded),
    };

    result.map_err(|e| ONDCCryptoError::EncodingError(format!("Invalid Base64 encoding: {}", e)))
}

/// Decode signature securely with automatic zeroization.
///
/// This function is designed for decoding sensitive data that should be
/// automatically zeroized after use.
///
/// # Arguments
///
/// * `encoded` - The Base64-encoded signature string
///
/// # Returns
///
/// The decoded signature bytes in a `Zeroizing` container, or an error if decoding fails.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::decode_signature_secure;
///
/// let encoded = "AQIDBA==";
/// let decoded = decode_signature_secure(encoded).unwrap();
/// // decoded is automatically zeroized when dropped
/// ```
///
/// # Security
///
/// The decoded data is automatically zeroized when the `Zeroizing` container is dropped.
///
/// # Errors
///
/// Returns `ONDCCryptoError::EncodingError` if the input is not valid Base64.
pub fn decode_signature_secure(encoded: &str) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
    let decoded = decode_signature(encoded)?;
    Ok(Zeroizing::new(decoded))
}

/// Validate Base64 string format.
///
/// This function checks if a string is valid Base64 without actually decoding it.
///
/// # Arguments
///
/// * `encoded` - The string to validate
/// * `variant` - The Base64 variant to validate against
///
/// # Returns
///
/// `true` if the string is valid Base64, `false` otherwise.
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::{is_valid_base64, Base64Variant};
///
/// assert!(is_valid_base64("AQIDBA==", Base64Variant::Standard));
/// assert!(!is_valid_base64("invalid!", Base64Variant::Standard));
/// ```
pub fn is_valid_base64(encoded: &str, variant: Base64Variant) -> bool {
    match variant {
        Base64Variant::Standard => STANDARD.decode(encoded).is_ok(),
        Base64Variant::UrlSafe => URL_SAFE.decode(encoded).is_ok(),
        Base64Variant::UrlSafeNoPad => URL_SAFE_NO_PAD.decode(encoded).is_ok(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_signature() {
        let signature = [0x01, 0x02, 0x03, 0x04];
        let encoded = encode_signature(&signature);
        assert_eq!(encoded, "AQIDBA==");
    }

    #[test]
    fn test_decode_signature() {
        let encoded = "AQIDBA==";
        let decoded = decode_signature(encoded).unwrap();
        assert_eq!(decoded, vec![0x01, 0x02, 0x03, 0x04]);
    }

    #[test]
    fn test_encode_decode_roundtrip() {
        let original = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
        let encoded = encode_signature(&original);
        let decoded = decode_signature(&encoded).unwrap();
        assert_eq!(decoded, original);
    }

    #[test]
    fn test_decode_invalid_base64() {
        let invalid = "invalid!";
        let result = decode_signature(invalid);
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err(),
            ONDCCryptoError::EncodingError(_)
        ));
    }

    #[test]
    fn test_encode_signature_variant() {
        let signature = [0x01, 0x02, 0x03, 0x04];

        let standard = encode_signature_variant(&signature, Base64Variant::Standard);
        assert_eq!(standard, "AQIDBA==");

        let url_safe = encode_signature_variant(&signature, Base64Variant::UrlSafe);
        assert_eq!(url_safe, "AQIDBA==");

        let url_safe_no_pad = encode_signature_variant(&signature, Base64Variant::UrlSafeNoPad);
        assert_eq!(url_safe_no_pad, "AQIDBA");
    }

    #[test]
    fn test_decode_signature_variant() {
        let standard_encoded = "AQIDBA==";
        let decoded = decode_signature_variant(standard_encoded, Base64Variant::Standard).unwrap();
        assert_eq!(decoded, vec![0x01, 0x02, 0x03, 0x04]);

        let url_safe_no_pad_encoded = "AQIDBA";
        let decoded =
            decode_signature_variant(url_safe_no_pad_encoded, Base64Variant::UrlSafeNoPad).unwrap();
        assert_eq!(decoded, vec![0x01, 0x02, 0x03, 0x04]);
    }

    #[test]
    fn test_encode_signature_secure() {
        let mut signature = Zeroizing::new(vec![0x01, 0x02, 0x03, 0x04]);
        let encoded = encode_signature_secure(&mut signature);
        assert_eq!(encoded, "AQIDBA==");

        // Verify the signature was zeroized
        assert_eq!(signature.as_slice(), &[]);
    }

    #[test]
    fn test_decode_signature_secure() {
        let encoded = "AQIDBA==";
        let decoded = decode_signature_secure(encoded).unwrap();
        assert_eq!(decoded.as_slice(), &[0x01, 0x02, 0x03, 0x04]);

        // The Zeroizing container will automatically zeroize when dropped
    }

    #[test]
    fn test_is_valid_base64() {
        assert!(is_valid_base64("AQIDBA==", Base64Variant::Standard));
        assert!(is_valid_base64("AQIDBA", Base64Variant::UrlSafeNoPad));
        assert!(!is_valid_base64("invalid!", Base64Variant::Standard));
        assert!(!is_valid_base64("AQIDBA===", Base64Variant::Standard)); // Too much padding
    }

    #[test]
    fn test_empty_input() {
        let empty = [];
        let encoded = encode_signature(&empty);
        assert_eq!(encoded, "");

        let decoded = decode_signature("").unwrap();
        assert_eq!(decoded, vec![]);
    }

    #[test]
    fn test_large_input() {
        let large_data: Vec<u8> = (0..1000).map(|i| (i % 256) as u8).collect();
        let encoded = encode_signature(&large_data);
        let decoded = decode_signature(&encoded).unwrap();
        assert_eq!(decoded, large_data);
    }

    #[test]
    fn test_ondc_compatibility() {
        // Test with data that matches ONDC signature patterns
        let signature = vec![
            0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b,
            0x5c, 0x6d, 0x7e, 0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d,
            0x9e, 0x0f, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f,
            0x3a, 0x4b, 0x5c, 0x6d, 0x7e, 0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b,
            0x7c, 0x8d, 0x9e, 0x0f, 0x1a, 0x2b, 0x3c, 0x4d,
        ];

        let encoded = encode_signature(&signature);
        let decoded = decode_signature(&encoded).unwrap();
        assert_eq!(decoded, signature);

        // Verify the encoded string is valid for ONDC headers
        assert!(!encoded.contains('+') || !encoded.contains('/')); // Should be URL-safe if needed
    }
}

================
File: ondc-crypto-formats/Cargo.toml
================
[package]
name = "ondc-crypto-formats"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
description = "Encoding and decoding utilities for ONDC cryptographic operations"
keywords.workspace = true
categories.workspace = true
readme.workspace = true

[dependencies]
# Internal crates
ondc-crypto-traits = { path = "../ondc-crypto-traits" }

# Encoding dependencies
base64 = { workspace = true }
hex = { workspace = true }

# DER encoding/decoding
der = { version = "0.8.0-rc.6", features = ["alloc", "pem", "std", "oid", "derive"] }

# Memory safety
zeroize = { workspace = true }

================
File: ondc-crypto-traits/src/lib.rs
================
//! Core traits and error types for ONDC cryptographic operations.
//!
//! This crate provides the foundational traits and error types used throughout
//! the ONDC crypto SDK. It defines the interfaces for signing, verification,
//! and hashing operations.

pub mod error;
pub mod traits;
pub mod types;

pub use error::ONDCCryptoError;
pub use traits::{Hasher, KeyPair, PublicKey, Signer, SigningString, Verifier};
pub use types::*;

/// Re-export commonly used types
pub mod prelude {
    pub use super::error::ONDCCryptoError;
    pub use super::traits::{Hasher, KeyPair, PublicKey, Signer, SigningString, Verifier};
    pub use super::types::*;
}

================
File: docs/technical.md
================
# ONDC BAP Server Technical Guide

## Overview

This document provides comprehensive technical guidance for implementing the ONDC (Open Network for Digital Commerce) BAP (Beckn Application Platform) server in Rust. The server is designed as a layered web service that handles ONDC network participant onboarding and provides the required endpoints for registry integration, built on top of our established cryptographic foundation.

## Core Design Principles

### 1. Layered Architecture
- **Presentation Layer**: HTTP request handling with Axum framework
- **Services Layer**: Business logic and service orchestration
- **Domain Layer**: Core business entities and rules
- **Infrastructure Layer**: External integrations and data persistence

### 2. Security First
- **Zero-Trust Model**: Validate all inputs and authenticate all requests
- **Cryptographic Security**: Leverage existing crypto foundation for all operations
- **Network Security**: TLS/HTTPS for all communications
- **Key Security**: Secure key management with automatic zeroization

### 3. ONDC Protocol Compliance
- **Registry Integration**: Full compliance with ONDC registry APIs
- **Challenge-Response**: Proper implementation of onboarding flow
- **Digital Signatures**: Correct HTTP signature generation and verification
- **Error Handling**: ONDC-compliant error codes and responses

### 4. Production Ready
- **Observability**: Comprehensive logging, metrics, and tracing
- **Reliability**: Retry mechanisms, circuit breakers, and graceful degradation
- **Scalability**: Horizontal scaling support with stateless design
- **Maintainability**: Clean architecture with clear separation of concerns

## Updated Crate Architecture

### Updated Crate Architecture

The project now consists of four foundational crates plus the main BAP server:

#### Foundational Crates (Phase 2 - COMPLETED âœ…)

1. **`ondc-crypto-traits`** - Core traits and types
   - Cryptographic trait definitions
   - Error handling system
   - Common types and constants

2. **`ondc-crypto-algorithms`** - Cryptographic implementations
   - Ed25519 signing and verification
   - X25519 key exchange
   - Blake2 hashing

3. **`ondc-crypto-formats`** - Encoding and formatting
   - Base64 encoding utilities
   - Key format conversions
   - DER format support

#### Main BAP Server Crate: `ondc-bap`

**Purpose**: Production-ready ONDC BAP server with web API and registry integration.

**New Structure**:
```
ondc-bap/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                    # Application entry point
â”‚   â”œâ”€â”€ lib.rs                     # Library exports
â”‚   â”œâ”€â”€ config/                    # Configuration management
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ app_config.rs          # Application configuration
â”‚   â”‚   â”œâ”€â”€ ondc_config.rs         # ONDC-specific settings
â”‚   â”‚   â””â”€â”€ environment.rs         # Environment handling
â”‚   â”œâ”€â”€ presentation/              # HTTP layer (Axum)
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ server.rs              # Axum server setup
â”‚   â”‚   â”œâ”€â”€ middleware/            # HTTP middleware
â”‚   â”‚   â”œâ”€â”€ handlers/              # Request handlers
â”‚   â”‚   â””â”€â”€ routes.rs              # Route definitions
â”‚   â”œâ”€â”€ services/                  # Application services
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ onboarding_service.rs  # Onboarding orchestration
â”‚   â”‚   â”œâ”€â”€ key_management_service.rs
â”‚   â”‚   â”œâ”€â”€ registry_client.rs     # Registry API client
â”‚   â”‚   â””â”€â”€ challenge_service.rs   # Challenge handling
â”‚   â”œâ”€â”€ infrastructure/            # Infrastructure layer
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ http_client.rs         # External HTTP client
â”‚   â”‚   â”œâ”€â”€ file_storage.rs        # File system operations
â”‚   â”‚   â””â”€â”€ logging.rs             # Logging configuration
â”‚   â””â”€â”€ error/                     # Error handling
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ app_error.rs           # Application errors
â”‚       â””â”€â”€ registry_error.rs      # Registry-specific errors
â”œâ”€â”€ config/                        # Configuration files
â”‚   â”œâ”€â”€ staging.toml
â”‚   â”œâ”€â”€ preprod.toml
â”‚   â””â”€â”€ production.toml
â”œâ”€â”€ examples/                      # Usage examples
â””â”€â”€ tests/                         # Integration tests
```

**Key Dependencies**:
```toml
[dependencies]
# Existing crypto crates
ondc-crypto-traits = { path = "../ondc-crypto-traits" }
ondc-crypto-algorithms = { path = "../ondc-crypto-algorithms" }
ondc-crypto-formats = { path = "../ondc-crypto-formats" }

# Web framework
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
hyper = "1.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }

# HTTP client
reqwest = { version = "0.11", features = ["json", "native-tls"] }

# Configuration
config = "0.14"
figment = { version = "0.10", features = ["toml", "env"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Logging and tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-opentelemetry = "0.21"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Security
rustls = "0.22"
rustls-pemfile = "2.0"
```

## Implementation Patterns

### 1. Configuration Management Pattern

```rust
// config/app_config.rs
use figment::{Figment, providers::{Format, Toml, Env}};
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct BAPConfig {
    pub server: ServerConfig,
    pub ondc: ONDCConfig,
    pub keys: KeyConfig,
    pub security: SecurityConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub tls: Option<TlsConfig>,
    pub request_timeout_secs: u64,
    pub max_connections: usize,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ONDCConfig {
    pub environment: Environment,
    pub registry_base_url: String,
    pub subscriber_id: String,
    pub callback_url: String,
    pub request_timeout_secs: u64,
    pub max_retries: usize,
}

#[derive(Debug, Clone, Deserialize)]
pub struct KeyConfig {
    pub signing_private_key: String,      // Base64 encoded
    pub encryption_private_key: String,   // Base64 encoded
    pub unique_key_id: String,
}

impl BAPConfig {
    pub fn load() -> Result<Self, ConfigError> {
        let environment = std::env::var("ONDC_ENV").unwrap_or_else(|_| "staging".to_string());
        
        Figment::new()
            .merge(Toml::file(format!("config/{}.toml", environment)))
            .merge(Env::prefixed("ONDC_"))
            .extract()
    }
    
    pub fn validate(&self) -> Result<(), ConfigError> {
        // Validate configuration consistency
        if self.ondc.subscriber_id.is_empty() {
            return Err(ConfigError::InvalidSubscriberId);
        }
        
        // Validate key formats
        self.keys.validate()?;
        
        // Validate URLs
        url::Url::parse(&self.ondc.registry_base_url)
            .map_err(|_| ConfigError::InvalidRegistryUrl)?;
        
        Ok(())
    }
}

impl KeyConfig {
    pub fn validate(&self) -> Result<(), ConfigError> {
        use ondc_crypto_formats::{decode_signature};
        
        // Validate signing key format and length
        let signing_key = decode_signature(&self.signing_private_key)
            .map_err(|_| ConfigError::InvalidSigningKey)?;
        if signing_key.len() != 32 {
            return Err(ConfigError::InvalidSigningKeyLength);
        }
        
        // Validate encryption key format and length
        let encryption_key = decode_signature(&self.encryption_private_key)
            .map_err(|_| ConfigError::InvalidEncryptionKey)?;
        if encryption_key.len() != 32 {
            return Err(ConfigError::InvalidEncryptionKeyLength);
        }
        
        Ok(())
    }
}
```

### 2. Layered Service Pattern

```rust
// application/onboarding_service.rs
use std::sync::Arc;
use anyhow::Result;
use tracing::{info, warn, error, instrument};

pub struct OnboardingService {
    registry_client: Arc<RegistryClient>,
    key_manager: Arc<KeyManager>,
    config: Arc<ONDCConfig>,
}

impl OnboardingService {
    pub fn new(
        registry_client: Arc<RegistryClient>,
        key_manager: Arc<KeyManager>,
        config: Arc<ONDCConfig>,
    ) -> Self {
        Self {
            registry_client,
            key_manager,
            config,
        }
    }
    
    #[instrument(skip(self), fields(subscriber_id = %self.config.subscriber_id))]
    pub async fn register_participant(
        &self,
        registration_request: RegistrationRequest,
    ) -> Result<RegistrationResponse, OnboardingError> {
        info!("Starting participant registration");
        
        // Validate prerequisites
        self.validate_prerequisites(&registration_request).await?;
        
        // Generate unique request ID
        let request_id = self.generate_request_id();
        
        // Prepare subscription payload
        let subscription_payload = self.prepare_subscription_payload(
            &registration_request,
            &request_id,
        ).await?;
        
        // Register with ONDC registry
        match self.registry_client.subscribe(subscription_payload).await {
            Ok(response) => {
                info!("Registration successful");
                Ok(RegistrationResponse {
                    status: RegistrationStatus::Success,
                    request_id,
                    message: "Successfully registered with ONDC registry".to_string(),
                })
            }
            Err(e) => {
                error!("Registration failed: {}", e);
                Err(OnboardingError::RegistrationFailed(e.to_string()))
            }
        }
    }
    
    #[instrument(skip(self))]
    pub async fn check_registration_status(&self) -> Result<RegistrationStatus, OnboardingError> {
        info!("Checking registration status");
        
        let lookup_criteria = LookupCriteria {
            country: "IND".to_string(),
            domain: self.determine_domain(),
            subscriber_id: Some(self.config.subscriber_id.clone()),
        };
        
        match self.registry_client.lookup(lookup_criteria).await {
            Ok(participants) => {
                if participants.iter().any(|p| p.subscriber_id == self.config.subscriber_id) {
                    info!("Registration confirmed in registry");
                    Ok(RegistrationStatus::Active)
                } else {
                    warn!("Participant not found in registry");
                    Ok(RegistrationStatus::NotFound)
                }
            }
            Err(e) => {
                error!("Failed to check registration status: {}", e);
                Err(OnboardingError::StatusCheckFailed(e.to_string()))
            }
        }
    }
    
    async fn validate_prerequisites(
        &self,
        request: &RegistrationRequest,
    ) -> Result<(), OnboardingError> {
        // Validate domain accessibility
        self.validate_domain_accessibility().await?;
        
        // Validate SSL certificate
        self.validate_ssl_certificate().await?;
        
        // Validate key pairs
        self.key_manager.validate_key_pairs()?;
        
        Ok(())
    }
    
    async fn prepare_subscription_payload(
        &self,
        request: &RegistrationRequest,
        request_id: &str,
    ) -> Result<SubscriptionPayload, OnboardingError> {
        let signing_public_key = self.key_manager.get_signing_public_key()?;
        let encryption_public_key = self.key_manager.get_encryption_public_key()?;
        
        Ok(SubscriptionPayload {
            subscriber_id: self.config.subscriber_id.clone(),
            callback_url: self.config.callback_url.clone(),
            subscriber_url: self.config.subscriber_id.clone(),
            signing_public_key: signing_public_key,
            encryption_public_key: encryption_public_key,
            unique_key_id: self.key_manager.get_unique_key_id(),
            request_id: request_id.to_string(),
            timestamp: chrono::Utc::now().timestamp() as u64,
            ops_no: request.ops_no,
            // Add other required fields based on ops_no
        })
    }
}
```

### 3. Axum Handler Pattern

```rust
// presentation/handlers/ondc_handlers.rs
use axum::{
    extract::{State, Json},
    response::{Html, Result as AxumResult},
    http::StatusCode,
};
use tracing::{info, error, instrument};

#[derive(Clone)]
pub struct AppState {
    pub onboarding_service: Arc<OnboardingService>,
    pub challenge_service: Arc<ChallengeService>,
    pub key_manager: Arc<KeyManager>,
    pub config: Arc<BAPConfig>,
}

#[instrument(skip(state))]
pub async fn serve_site_verification(
    State(state): State<AppState>,
) -> AxumResult<Html<String>> {
    info!("Serving site verification page");
    
    match state.challenge_service.generate_site_verification().await {
        Ok(html_content) => {
            info!("Site verification page generated successfully");
            Ok(Html(html_content))
        }
        Err(e) => {
            error!("Failed to generate site verification: {}", e);
            Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to generate verification page: {}", e),
            ).into())
        }
    }
}

#[instrument(skip(state, request), fields(subscriber_id = ?request.subscriber_id))]
pub async fn handle_on_subscribe(
    State(state): State<AppState>,
    Json(request): Json<OnSubscribeRequest>,
) -> AxumResult<Json<OnSubscribeResponse>> {
    info!("Processing on_subscribe challenge");
    
    // Validate request
    if let Err(e) = validate_on_subscribe_request(&request) {
        error!("Invalid on_subscribe request: {}", e);
        return Err((
            StatusCode::BAD_REQUEST,
            format!("Invalid request: {}", e),
        ).into());
    }
    
    // Process challenge
    match state.challenge_service.process_challenge(request).await {
        Ok(response) => {
            info!("Challenge processed successfully");
            Ok(Json(response))
        }
        Err(e) => {
            error!("Failed to process challenge: {}", e);
            Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Challenge processing failed: {}", e),
            ).into())
        }
    }
}

#[instrument(skip(state, request))]
pub async fn admin_register(
    State(state): State<AppState>,
    Json(request): Json<AdminRegistrationRequest>,
) -> AxumResult<Json<AdminRegistrationResponse>> {
    info!("Processing admin registration request");
    
    // Validate admin request
    if let Err(e) = validate_admin_request(&request) {
        error!("Invalid admin request: {}", e);
        return Err((
            StatusCode::BAD_REQUEST,
            format!("Invalid request: {}", e),
        ).into());
    }
    
    // Process registration
    match state.onboarding_service.register_participant(request.into()).await {
        Ok(response) => {
            info!("Registration initiated successfully");
            Ok(Json(AdminRegistrationResponse {
                status: "initiated".to_string(),
                message: response.message,
                request_id: response.request_id,
            }))
        }
        Err(e) => {
            error!("Registration failed: {}", e);
            Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Registration failed: {}", e),
            ).into())
        }
    }
}

pub async fn health_check() -> AxumResult<Json<HealthResponse>> {
    Ok(Json(HealthResponse {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    }))
}

fn validate_on_subscribe_request(request: &OnSubscribeRequest) -> Result<(), ValidationError> {
    if request.subscriber_id.is_empty() {
        return Err(ValidationError::EmptySubscriberId);
    }
    
    if request.challenge.is_empty() {
        return Err(ValidationError::EmptyChallenge);
    }
    
    // Add more validation as needed
    Ok(())
}
```

### 4. Challenge Processing Pattern

```rust
// application/challenge_service.rs
use std::sync::Arc;
use ondc_crypto_algorithms::{X25519KeyExchange, Ed25519Signer};
use ondc_crypto_formats::{decode_signature, encode_signature};

pub struct ChallengeService {
    key_manager: Arc<KeyManager>,
    config: Arc<BAPConfig>,
}

impl ChallengeService {
    pub fn new(key_manager: Arc<KeyManager>, config: Arc<BAPConfig>) -> Self {
        Self { key_manager, config }
    }
    
    #[instrument(skip(self))]
    pub async fn generate_site_verification(&self) -> Result<String, ChallengeError> {
        info!("Generating site verification content");
        
        // Generate unique request ID
        let request_id = uuid::Uuid::new_v4().to_string();
        
        // Sign the request ID using Ed25519
        let signed_content = self.sign_request_id(&request_id).await?;
        
        // Generate HTML content
        let html_content = format!(
            r#"<!--Contents of ondc-site-verification.html. -->
<!--Please replace SIGNED_UNIQUE_REQ_ID with an actual value-->
<html>
  <head>
    <meta
      name="ondc-site-verification"
      content="{}"
    />
  </head>
  <body>
    ONDC Site Verification Page
  </body>
</html>"#,
            signed_content
        );
        
        info!("Site verification content generated");
        Ok(html_content)
    }
    
    #[instrument(skip(self, request), fields(challenge_length = request.challenge.len()))]
    pub async fn process_challenge(
        &self,
        request: OnSubscribeRequest,
    ) -> Result<OnSubscribeResponse, ChallengeError> {
        info!("Processing on_subscribe challenge");
        
        // Decode the encrypted challenge
        let encrypted_challenge = decode_signature(&request.challenge)
            .map_err(|e| ChallengeError::InvalidChallenge(e.to_string()))?;
        
        // Generate shared secret using X25519
        let shared_secret = self.generate_shared_secret().await?;
        
        // Decrypt challenge using AES-256-ECB
        let decrypted_answer = self.decrypt_challenge(&encrypted_challenge, &shared_secret)?;
        
        info!("Challenge decrypted successfully");
        
        Ok(OnSubscribeResponse {
            answer: decrypted_answer,
        })
    }
    
    async fn sign_request_id(&self, request_id: &str) -> Result<String, ChallengeError> {
        let signer = self.key_manager.get_ed25519_signer()
            .map_err(|e| ChallengeError::KeyManagerError(e.to_string()))?;
        
        let signature = signer.sign(request_id.as_bytes())
            .map_err(|e| ChallengeError::SigningError(e.to_string()))?;
        
        Ok(encode_signature(&signature))
    }
    
    async fn generate_shared_secret(&self) -> Result<Vec<u8>, ChallengeError> {
        let key_exchange = self.key_manager.get_x25519_key_exchange()
            .map_err(|e| ChallengeError::KeyManagerError(e.to_string()))?;
        
        // Get ONDC public key for the current environment
        let ondc_public_key = self.get_ondc_public_key()?;
        
        let shared_secret = key_exchange.diffie_hellman(&ondc_public_key)
            .map_err(|e| ChallengeError::KeyExchangeError(e.to_string()))?;
        
        Ok(shared_secret.to_vec())
    }
    
    fn decrypt_challenge(
        &self,
        encrypted_challenge: &[u8],
        shared_secret: &[u8],
    ) -> Result<String, ChallengeError> {
        use aes::Aes256;
        use block_modes::{BlockMode, Ecb};
        use block_modes::block_padding::NoPadding;
        
        type Aes256Ecb = Ecb<Aes256, NoPadding>;
        
        let cipher = Aes256Ecb::new_from_slices(shared_secret, &[])
            .map_err(|e| ChallengeError::DecryptionError(e.to_string()))?;
        
        let decrypted = cipher.decrypt_vec(encrypted_challenge)
            .map_err(|e| ChallengeError::DecryptionError(e.to_string()))?;
        
        String::from_utf8(decrypted)
            .map_err(|e| ChallengeError::DecryptionError(e.to_string()))
    }
    
    fn get_ondc_public_key(&self) -> Result<[u8; 32], ChallengeError> {
        let public_key_b64 = match self.config.ondc.environment {
            Environment::Staging => "MCowBQYDK2VuAyEAduMuZgmtpjdCuxv+Nc49K0cB6tL/Dj3HZetvVN7ZekM=",
            Environment::PreProd => "MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=",
            Environment::Production => "MCowBQYDK2VuAyEAvVEyZY91O2yV8w8/CAwVDAnqIZDJJUPdLUUKwLo3K0M=",
        };
        
        let decoded = decode_signature(public_key_b64)
            .map_err(|e| ChallengeError::InvalidONDCKey(e.to_string()))?;
        
        // Extract raw key from DER format (last 32 bytes)
        if decoded.len() < 32 {
            return Err(ChallengeError::InvalidONDCKey("Key too short".to_string()));
        }
        
        let mut key = [0u8; 32];
        key.copy_from_slice(&decoded[decoded.len() - 32..]);
        Ok(key)
    }
}
```

### 5. Registry Client Pattern

```rust
// application/registry_client.rs
use std::time::Duration;
use reqwest::{Client, ClientBuilder};
use serde::{Serialize, Deserialize};
use tracing::{info, warn, error, instrument};

pub struct RegistryClient {
    client: Client,
    base_url: String,
    key_manager: Arc<KeyManager>,
    config: Arc<ONDCConfig>,
}

impl RegistryClient {
    pub fn new(
        key_manager: Arc<KeyManager>,
        config: Arc<ONDCConfig>,
    ) -> Result<Self, RegistryClientError> {
        let client = ClientBuilder::new()
            .timeout(Duration::from_secs(config.request_timeout_secs))
            .use_rustls_tls()
            .build()
            .map_err(|e| RegistryClientError::ClientCreationFailed(e.to_string()))?;
        
        Ok(Self {
            client,
            base_url: config.registry_base_url.clone(),
            key_manager,
            config: config.clone(),
        })
    }
    
    #[instrument(skip(self, payload), fields(subscriber_id = %payload.subscriber_id))]
    pub async fn subscribe(
        &self,
        payload: SubscriptionPayload,
    ) -> Result<SubscriptionResponse, RegistryClientError> {
        info!("Sending subscription request to registry");
        
        let url = format!("{}/subscribe", self.base_url);
        
        let response = self.client
            .post(&url)
            .json(&payload)
            .send()
            .await
            .map_err(|e| RegistryClientError::RequestFailed(e.to_string()))?;
        
        if response.status().is_success() {
            let subscription_response: SubscriptionResponse = response
                .json()
                .await
                .map_err(|e| RegistryClientError::DeserializationFailed(e.to_string()))?;
            
            info!("Subscription request successful");
            Ok(subscription_response)
        } else {
            let error_text = response
                .text()
                .await
                .unwrap_or_else(|_| "Unknown error".to_string());
            
            error!("Subscription request failed: {}", error_text);
            Err(RegistryClientError::SubscriptionFailed(error_text))
        }
    }
    
    #[instrument(skip(self, criteria))]
    pub async fn lookup(
        &self,
        criteria: LookupCriteria,
    ) -> Result<Vec<Participant>, RegistryClientError> {
        info!("Performing registry lookup");
        
        let url = format!("{}/v2.0/lookup", self.base_url);
        
        // Create authorization header for v2.0 API
        let auth_header = self.create_authorization_header(&criteria).await?;
        
        let response = self.client
            .post(&url)
            .header("Authorization", auth_header)
            .header("Content-Type", "application/json")
            .json(&criteria)
            .send()
            .await
            .map_err(|e| RegistryClientError::RequestFailed(e.to_string()))?;
        
        if response.status().is_success() {
            let lookup_response: LookupResponse = response
                .json()
                .await
                .map_err(|e| RegistryClientError::DeserializationFailed(e.to_string()))?;
            
            info!("Lookup request successful, found {} participants", lookup_response.participants.len());
            Ok(lookup_response.participants)
        } else if response.status() == 429 {
            warn!("Rate limit exceeded, should retry with backoff");
            Err(RegistryClientError::RateLimitExceeded)
        } else {
            let error_text = response
                .text()
                .await
                .unwrap_or_else(|_| "Unknown error".to_string());
            
            error!("Lookup request failed: {}", error_text);
            Err(RegistryClientError::LookupFailed(error_text))
        }
    }
    
    async fn create_authorization_header(
        &self,
        criteria: &LookupCriteria,
    ) -> Result<String, RegistryClientError> {
        let created = chrono::Utc::now().timestamp() as u64;
        let expires = created + 300; // 5 minutes from now
        
        // Create digest
        let body_json = serde_json::to_string(criteria)
            .map_err(|e| RegistryClientError::SerializationFailed(e.to_string()))?;
        
        let hasher = Blake2Hasher::new();
        let digest = hasher.generate_ondc_digest(body_json.as_bytes());
        
        // Create signing string
        let signing_string = format!(
            "(created): {}\n(expires): {}\ndigest: {}",
            created, expires, digest
        );
        
        // Sign the string
        let signer = self.key_manager.get_ed25519_signer()
            .map_err(|e| RegistryClientError::KeyManagerError(e.to_string()))?;
        
        let signature = signer.sign(signing_string.as_bytes())
            .map_err(|e| RegistryClientError::SigningError(e.to_string()))?;
        
        let signature_b64 = encode_signature(&signature);
        
        // Create authorization header
        let auth_header = format!(
            r#"Signature keyId="{}|{}|ed25519",algorithm="ed25519",created="{}",expires="{}",headers="(created) (expires) digest",signature="{}""#,
            self.config.subscriber_id,
            self.key_manager.get_unique_key_id(),
            created,
            expires,
            signature_b64
        );
        
        Ok(auth_header)
    }
}

// Retry implementation with exponential backoff
impl RegistryClient {
    pub async fn subscribe_with_retry(
        &self,
        payload: SubscriptionPayload,
    ) -> Result<SubscriptionResponse, RegistryClientError> {
        let mut attempts = 0;
        let max_attempts = self.config.max_retries;
        
        loop {
            match self.subscribe(payload.clone()).await {
                Ok(response) => return Ok(response),
                Err(RegistryClientError::RateLimitExceeded) if attempts < max_attempts => {
                    let delay = Duration::from_millis(1000 * 2_u64.pow(attempts));
                    warn!("Rate limited, retrying in {:?}", delay);
                    tokio::time::sleep(delay).await;
                    attempts += 1;
                }
                Err(e) => return Err(e),
            }
        }
    }
}
```

## Security Implementation

### 1. TLS/HTTPS Configuration

```rust
// presentation/server.rs
use axum_server::tls_rustls::RustlsConfig;
use std::net::SocketAddr;

pub async fn create_server(config: &BAPConfig, app_state: AppState) -> Result<(), ServerError> {
    let app = create_router(app_state);
    
    let addr = SocketAddr::from(([0, 0, 0, 0], config.server.port));
    
    if let Some(tls_config) = &config.server.tls {
        info!("Starting HTTPS server on {}", addr);
        
        let rustls_config = RustlsConfig::from_pem_file(
            &tls_config.cert_path,
            &tls_config.key_path,
        ).await
        .map_err(|e| ServerError::TlsConfigurationFailed(e.to_string()))?;
        
        axum_server::bind_rustls(addr, rustls_config)
            .serve(app.into_make_service())
            .await
            .map_err(|e| ServerError::ServerStartFailed(e.to_string()))?;
    } else {
        warn!("Starting HTTP server (TLS disabled) on {}", addr);
        
        axum_server::bind(addr)
            .serve(app.into_make_service())
            .await
            .map_err(|e| ServerError::ServerStartFailed(e.to_string()))?;
    }
    
    Ok(())
}
```

### 2. Input Validation and Sanitization

```rust
// domain/validation.rs
use regex::Regex;

pub struct InputValidator;

impl InputValidator {
    pub fn validate_subscriber_id(subscriber_id: &str) -> Result<(), ValidationError> {
        if subscriber_id.is_empty() {
            return Err(ValidationError::EmptySubscriberId);
        }
        
        if subscriber_id.len() > 255 {
            return Err(ValidationError::SubscriberIdTooLong);
        }
        
        // Validate FQDN format
        let fqdn_regex = Regex::new(r"^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
            .unwrap();
        
        if !fqdn_regex.is_match(subscriber_id) {
            return Err(ValidationError::InvalidSubscriberIdFormat);
        }
        
        Ok(())
    }
    
    pub fn validate_challenge(challenge: &str) -> Result<(), ValidationError> {
        if challenge.is_empty() {
            return Err(ValidationError::EmptyChallenge);
        }
        
        // Validate base64 format
        if let Err(_) = base64::decode(challenge) {
            return Err(ValidationError::InvalidChallengeFormat);
        }
        
        Ok(())
    }
    
    pub fn sanitize_callback_url(callback_url: &str) -> Result<String, ValidationError> {
        // Remove any potentially dangerous characters
        let sanitized = callback_url
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '/' || *c == '-' || *c == '_')
            .collect::<String>();
        
        if sanitized != callback_url {
            return Err(ValidationError::UnsafeCallbackUrl);
        }
        
        Ok(sanitized)
    }
}
```

### 3. Rate Limiting and Security Middleware

```rust
// presentation/middleware/security.rs
use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
    http::{HeaderMap, HeaderValue, StatusCode},
};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window_duration: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window_duration: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window_duration,
        }
    }
    
    pub fn check_rate_limit(&self, client_ip: &str) -> bool {
        let mut requests = self.requests.lock().unwrap();
        let now = Instant::now();
        
        let client_requests = requests.entry(client_ip.to_string()).or_insert_with(Vec::new);
        
        // Remove old requests outside the window
        client_requests.retain(|&request_time| {
            now.duration_since(request_time) < self.window_duration
        });
        
        if client_requests.len() >= self.max_requests {
            false
        } else {
            client_requests.push(now);
            true
        }
    }
}

pub async fn rate_limit_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let client_ip = request
        .headers()
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .or_else(|| {
            request
                .headers()
                .get("x-real-ip")
                .and_then(|h| h.to_str().ok())
        })
        .unwrap_or("unknown");
    
    // Get rate limiter from app state (this would be injected)
    // For demonstration purposes, create a default limiter
    let rate_limiter = RateLimiter::new(100, Duration::from_secs(60)); // 100 requests per minute
    
    if !rate_limiter.check_rate_limit(client_ip) {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    
    Ok(next.run(request).await)
}

pub async fn security_headers_middleware(
    request: Request,
    next: Next,
) -> Response {
    let mut response = next.run(request).await;
    
    let headers = response.headers_mut();
    
    // Add security headers
    headers.insert("X-Content-Type-Options", HeaderValue::from_static("nosniff"));
    headers.insert("X-Frame-Options", HeaderValue::from_static("DENY"));
    headers.insert("X-XSS-Protection", HeaderValue::from_static("1; mode=block"));
    headers.insert("Referrer-Policy", HeaderValue::from_static("strict-origin-when-cross-origin"));
    headers.insert(
        "Content-Security-Policy",
        HeaderValue::from_static("default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'")
    );
    
    response
}
```

## Testing Patterns

### 1. Integration Testing with Test Containers

```rust
// tests/integration_tests.rs
use std::collections::HashMap;
use tokio::test;
use axum_test::TestServer;
use wiremock::{MockServer, Mock, ResponseTemplate};
use wiremock::matchers::{method, path};

#[tokio::test]
async fn test_onboarding_flow() -> Result<(), Box<dyn std::error::Error>> {
    // Start mock ONDC registry
    let mock_server = MockServer::start().await;
    
    // Configure mock responses
    Mock::given(method("POST"))
        .and(path("/subscribe"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(serde_json::json!({
                "message": {
                    "ack": {
                        "status": "ACK"
                    }
                },
                "error": {
                    "type": null,
                    "code": null,
                    "path": null,
                    "message": null
                }
            })))
        .mount(&mock_server)
        .await;
    
    Mock::given(method("POST"))
        .and(path("/on_subscribe"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(serde_json::json!({
                "answer": "test_challenge_response"
            })))
        .mount(&mock_server)
        .await;
    
    // Create test configuration
    let mut test_config = create_test_config();
    test_config.ondc.registry_base_url = mock_server.uri();
    
    // Create test server
    let app_state = create_test_app_state(test_config).await?;
    let test_server = TestServer::new(create_router(app_state))?;
    
    // Test site verification endpoint
    let response = test_server
        .get("/ondc-site-verification.html")
        .await;
    
    assert_eq!(response.status_code(), 200);
    assert!(response.text().contains("ondc-site-verification"));
    
    // Test on_subscribe endpoint
    let on_subscribe_request = serde_json::json!({
        "subscriber_id": "test.example.com",
        "challenge": "dGVzdF9jaGFsbGVuZ2U=" // base64 encoded "test_challenge"
    });
    
    let response = test_server
        .post("/on_subscribe")
        .json(&on_subscribe_request)
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    let response_body: serde_json::Value = response.json();
    assert!(response_body["answer"].is_string());
    
    // Test admin registration endpoint
    let registration_request = serde_json::json!({
        "ops_no": 1,
        "domain": "ONDC:RET10",
        "country": "IND"
    });
    
    let response = test_server
        .post("/admin/register")
        .json(&registration_request)
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    Ok(())
}

#[tokio::test]
async fn test_challenge_decryption() -> Result<(), Box<dyn std::error::Error>> {
    let test_config = create_test_config();
    let key_manager = Arc::new(KeyManager::new(&test_config.keys).await?);
    let challenge_service = ChallengeService::new(key_manager, Arc::new(test_config));
    
    // Create test challenge (this would normally be encrypted by ONDC)
    let test_challenge = "test_challenge_string";
    let challenge_request = OnSubscribeRequest {
        subscriber_id: "test.example.com".to_string(),
        challenge: base64::encode(test_challenge.as_bytes()),
    };
    
    let response = challenge_service.process_challenge(challenge_request).await?;
    
    // Verify that the challenge was processed correctly
    assert!(!response.answer.is_empty());
    
    Ok(())
}

async fn create_test_app_state(config: BAPConfig) -> Result<AppState, Box<dyn std::error::Error>> {
    let key_manager = Arc::new(KeyManager::new(&config.keys).await?);
    let registry_client = Arc::new(RegistryClient::new(
        key_manager.clone(),
        Arc::new(config.ondc.clone()),
    )?);
    let onboarding_service = Arc::new(OnboardingService::new(
        registry_client.clone(),
        key_manager.clone(),
        Arc::new(config.ondc.clone()),
    ));
    let challenge_service = Arc::new(ChallengeService::new(
        key_manager.clone(),
        Arc::new(config.clone()),
    ));
    
    Ok(AppState {
        onboarding_service,
        challenge_service,
        key_manager,
        config: Arc::new(config),
    })
}

fn create_test_config() -> BAPConfig {
    BAPConfig {
        server: ServerConfig {
            host: "0.0.0.0".to_string(),
            port: 8080,
            tls: None,
            request_timeout_secs: 30,
            max_connections: 1000,
        },
        ondc: ONDCConfig {
            environment: Environment::Staging,
            registry_base_url: "https://staging.registry.ondc.org".to_string(),
            subscriber_id: "test.example.com".to_string(),
            callback_url: "/".to_string(),
            request_timeout_secs: 30,
            max_retries: 3,
        },
        keys: KeyConfig {
            signing_private_key: generate_test_signing_key(),
            encryption_private_key: generate_test_encryption_key(),
            unique_key_id: "test_key_1".to_string(),
        },
        security: SecurityConfig {
            enable_rate_limiting: true,
            max_requests_per_minute: 100,
            enable_cors: true,
            allowed_origins: vec!["*".to_string()],
        },
    }
}
```

### 2. Property-Based Testing for Crypto Operations

```rust
// tests/property_tests.rs
use proptest::prelude::*;
use ondc_crypto_algorithms::{Ed25519Signer, Ed25519Verifier};
use ondc_crypto_formats::{encode_signature, decode_signature};

proptest! {
    #[test]
    fn test_signature_roundtrip(message in ".*") {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        
        runtime.block_on(async {
            let signer = Ed25519Signer::generate().unwrap();
            let verifier = Ed25519Verifier::new();
            
            let signature = signer.sign(message.as_bytes()).unwrap();
            let public_key = signer.public_key();
            
            // Signature should verify correctly
            verifier.verify(&public_key, message.as_bytes(), &signature).unwrap();
        });
    }
    
    #[test]
    fn test_base64_encoding_roundtrip(data in prop::collection::vec(any::<u8>(), 0..1000)) {
        let encoded = encode_signature(&data);
        let decoded = decode_signature(&encoded).unwrap();
        
        prop_assert_eq!(data, decoded);
    }
    
    #[test]
    fn test_challenge_processing(challenge_data in prop::collection::vec(any::<u8>(), 32..256)) {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        
        runtime.block_on(async {
            let test_config = create_test_config();
            let key_manager = Arc::new(KeyManager::new(&test_config.keys).await.unwrap());
            let challenge_service = ChallengeService::new(key_manager, Arc::new(test_config));
            
            let challenge_b64 = encode_signature(&challenge_data);
            let request = OnSubscribeRequest {
                subscriber_id: "test.example.com".to_string(),
                challenge: challenge_b64,
            };
            
            // Challenge processing should not panic
            let _result = challenge_service.process_challenge(request).await;
        });
    }
}
```

## Performance Considerations

### 1. Async/Await Performance Patterns

```rust
// application/performance_optimizations.rs
use std::sync::Arc;
use tokio::sync::{RwLock, Semaphore};
use std::time::Duration;

pub struct PerformanceOptimizedService {
    // Use RwLock for read-heavy operations
    cache: Arc<RwLock<HashMap<String, CachedValue>>>,
    // Limit concurrent expensive operations
    semaphore: Arc<Semaphore>,
}

impl PerformanceOptimizedService {
    pub fn new(max_concurrent_operations: usize) -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
            semaphore: Arc::new(Semaphore::new(max_concurrent_operations)),
        }
    }
    
    pub async fn expensive_operation(&self, key: &str) -> Result<String, ServiceError> {
        // Check cache first (read lock)
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.get(key) {
                if !cached.is_expired() {
                    return Ok(cached.value.clone());
                }
            }
        }
        
        // Acquire semaphore to limit concurrent operations
        let _permit = self.semaphore.acquire().await
            .map_err(|_| ServiceError::ResourceExhausted)?;
        
        // Double-check cache after acquiring semaphore
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.get(key) {
                if !cached.is_expired() {
                    return Ok(cached.value.clone());
                }
            }
        }
        
        // Perform expensive operation
        let result = self.perform_expensive_computation(key).await?;
        
        // Update cache (write lock)
        {
            let mut cache = self.cache.write().await;
            cache.insert(key.to_string(), CachedValue {
                value: result.clone(),
                expires_at: tokio::time::Instant::now() + Duration::from_secs(300),
            });
        }
        
        Ok(result)
    }
    
    async fn perform_expensive_computation(&self, _key: &str) -> Result<String, ServiceError> {
        // Simulate expensive operation
        tokio::time::sleep(Duration::from_millis(100)).await;
        Ok("computed_value".to_string())
    }
}

#[derive(Clone)]
struct CachedValue {
    value: String,
    expires_at: tokio::time::Instant,
}

impl CachedValue {
    fn is_expired(&self) -> bool {
        tokio::time::Instant::now() > self.expires_at
    }
}
```

### 2. Connection Pooling and Resource Management

```rust
// infrastructure/connection_pool.rs
use reqwest::{Client, ClientBuilder};
use std::sync::Arc;
use std::time::Duration;

pub struct ConnectionPoolManager {
    http_client: Client,
}

impl ConnectionPoolManager {
    pub fn new(config: &BAPConfig) -> Result<Self, ConnectionError> {
        let client = ClientBuilder::new()
            .pool_max_idle_per_host(10)
            .pool_idle_timeout(Duration::from_secs(30))
            .timeout(Duration::from_secs(config.server.request_timeout_secs))
            .tcp_keepalive(Duration::from_secs(60))
            .http2_keep_alive_interval(Duration::from_secs(30))
            .http2_keep_alive_timeout(Duration::from_secs(10))
            .use_rustls_tls()
            .build()
            .map_err(|e| ConnectionError::ClientCreationFailed(e.to_string()))?;
        
        Ok(Self {
            http_client: client,
        })
    }
    
    pub fn get_http_client(&self) -> &Client {
        &self.http_client
    }
}

// Use connection pool in registry client
impl RegistryClient {
    pub fn new_with_pool(
        pool_manager: Arc<ConnectionPoolManager>,
        key_manager: Arc<KeyManager>,
        config: Arc<ONDCConfig>,
    ) -> Self {
        Self {
            client: pool_manager.get_http_client().clone(),
            base_url: config.registry_base_url.clone(),
            key_manager,
            config,
        }
    }
}
```

================
File: ondc-bap/src/presentation/handlers/admin.rs
================
//! Administrative handlers for ONDC BAP Server

use axum::{
    extract::{Json, State},
    http::StatusCode,
    response::Json as JsonResponse,
};
use serde::{Deserialize, Serialize};
use tracing::{error, info, instrument};

use super::AppState;

/// Admin registration request
#[derive(Debug, Deserialize)]
pub struct AdminRegistrationRequest {
    pub ops_no: u32,
}

/// Admin registration response
#[derive(Debug, Serialize)]
pub struct AdminRegistrationResponse {
    pub status: String,
    pub message: String,
    pub request_id: Option<String>,
}

/// Admin status response
#[derive(Debug, Serialize)]
pub struct AdminStatusResponse {
    pub status: String,
    pub message: String,
    pub timestamp: String,
}

/// Administrative registration endpoint
///
/// This endpoint allows administrators to initiate ONDC network participant registration
/// by calling the registry subscribe API with the specified operation number.
#[instrument(skip(_state, request), fields(ops_no = request.ops_no))]
pub async fn admin_register(
    State(_state): State<AppState>,
    Json(request): Json<AdminRegistrationRequest>,
) -> Result<JsonResponse<AdminRegistrationResponse>, StatusCode> {
    info!("Processing admin registration request (ops_no: {})", request.ops_no);

    // Validate ops_no
    if !matches!(request.ops_no, 1 | 2 | 4) {
        error!("Invalid ops_no: {}", request.ops_no);
        return Err(StatusCode::BAD_REQUEST);
    }

    // TODO: Add registry client to AppState when implemented
    // For now, return a placeholder response
    info!("Registration request validated successfully");

    Ok(JsonResponse(AdminRegistrationResponse {
        status: "initiated".to_string(),
        message: format!("Registration initiated for ops_no: {}", request.ops_no),
        request_id: Some(uuid::Uuid::new_v4().to_string()),
    }))
}

/// Administrative status endpoint
///
/// This endpoint provides status information about the BAP server and its registration status.
#[instrument(skip(_state))]
pub async fn admin_status(
    State(_state): State<AppState>,
) -> Result<JsonResponse<AdminStatusResponse>, StatusCode> {
    info!("Admin status requested");

    // TODO: Add actual status checking logic
    // For now, return basic status information

    Ok(JsonResponse(AdminStatusResponse {
        status: "operational".to_string(),
        message: "BAP server is operational".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
    }))
}

/// Health check endpoint for administrative purposes
///
/// This endpoint provides detailed health information including key validation
/// and service status.
#[instrument(skip(state))]
pub async fn admin_health(
    State(state): State<AppState>,
) -> Result<JsonResponse<AdminHealthResponse>, StatusCode> {
    info!("Admin health check requested");

    // Validate key pairs
    let key_validation = state.key_manager.validate_key_pairs().await;
    let key_status = if key_validation.is_ok() {
        "healthy".to_string()
    } else {
        "unhealthy".to_string()
    };

    // Get key metadata
    let key_metadata = state.key_manager.get_key_metadata().await;

    Ok(JsonResponse(AdminHealthResponse {
        status: "operational".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        services: ServiceHealth {
            key_management: key_status,
            site_verification: "healthy".to_string(),
            challenge_processing: "healthy".to_string(),
            registry_client: "not_implemented".to_string(),
        },
        key_metadata: KeyHealth {
            key_id: key_metadata.key_id,
            created_at: key_metadata.created_at.to_rfc3339(),
            is_active: key_metadata.is_active,
            rotation_count: key_metadata.rotation_count,
        },
    }))
}

/// Admin health response with detailed service information
#[derive(Debug, Serialize)]
pub struct AdminHealthResponse {
    pub status: String,
    pub timestamp: String,
    pub services: ServiceHealth,
    pub key_metadata: KeyHealth,
}

/// Service health information
#[derive(Debug, Serialize)]
pub struct ServiceHealth {
    pub key_management: String,
    pub site_verification: String,
    pub challenge_processing: String,
    pub registry_client: String,
}

/// Key health information
#[derive(Debug, Serialize)]
pub struct KeyHealth {
    pub key_id: String,
    pub created_at: String,
    pub is_active: bool,
    pub rotation_count: u32,
}

/// Configuration update request
#[derive(Deserialize)]
pub struct ConfigUpdateRequest {
    pub key: String,
    pub value: String,
}

/// Configuration update response
#[derive(Serialize)]
pub struct ConfigUpdateResponse {
    pub success: bool,
    pub message: String,
}

/// Update configuration endpoint
pub async fn update_config(
    State(_state): State<AppState>,
    Json(_request): Json<ConfigUpdateRequest>,
) -> Result<JsonResponse<ConfigUpdateResponse>, StatusCode> {
    info!("Configuration update request received");

    // TODO: Implement configuration update logic

    Ok(JsonResponse(ConfigUpdateResponse {
        success: true,
        message: "Configuration updated successfully".to_string(),
    }))
}

/// Key rotation request
#[derive(Deserialize)]
pub struct KeyRotationRequest {
    pub key_type: String,
}

/// Key rotation response
#[derive(Serialize)]
pub struct KeyRotationResponse {
    pub success: bool,
    pub message: String,
    pub new_key_id: Option<String>,
}

/// Rotate keys endpoint
pub async fn rotate_keys(
    State(_state): State<AppState>,
    Json(_request): Json<KeyRotationRequest>,
) -> Result<JsonResponse<KeyRotationResponse>, StatusCode> {
    info!("Key rotation request received");

    // TODO: Implement key rotation logic

    Ok(JsonResponse(KeyRotationResponse {
        success: true,
        message: "Keys rotated successfully".to_string(),
        new_key_id: Some(uuid::Uuid::new_v4().to_string()),
    }))
}

/// Subscribe request
#[derive(Debug, Deserialize)]
pub struct SubscribeRequest {
    pub ops_no: u32,
}

/// Subscribe response
#[derive(Debug, Serialize)]
pub struct SubscribeResponse {
    pub status: String,
    pub message: String,
    pub request_id: Option<String>,
    pub registry_response: Option<String>,
}

/// Subscribe to ONDC registry endpoint
///
/// This endpoint allows administrators to subscribe to the ONDC registry
/// by calling the registry subscribe API with the specified operation number.
#[instrument(skip(state, request), fields(ops_no = request.ops_no))]
pub async fn subscribe_to_registry(
    State(state): State<AppState>,
    Json(request): Json<SubscribeRequest>,
) -> Result<JsonResponse<SubscribeResponse>, StatusCode> {
    info!("Processing subscribe request (ops_no: {})", request.ops_no);

    // Validate ops_no
    if !matches!(request.ops_no, 1 | 2 | 4) {
        error!("Invalid ops_no: {}", request.ops_no);
        return Err(StatusCode::BAD_REQUEST);
    }

    // Generate a new request_id for this subscription
    let request_id = uuid::Uuid::new_v4().to_string();
    info!("Generated request_id for subscription: {}", request_id);
    
    // Store the request_id in site verification service so it can be used when site verification is accessed
    state.site_verification_service.store_request_id(&request_id).await;
    
    // Call the registry client subscribe method with the generated request_id
    match state.registry_client.subscribe_with_request_id(request.ops_no, request_id).await {
        Ok(registry_response) => {
            info!("Successfully subscribed to registry with ops_no: {}", request.ops_no);
            
            // Validate the response
            if let Err(validation_error) = state.registry_client.validate_subscription_response(&registry_response) {
                error!("Registry response validation failed: {:?}", validation_error);
                return Err(StatusCode::INTERNAL_SERVER_ERROR);
            }

            Ok(JsonResponse(SubscribeResponse {
                status: "success".to_string(),
                message: format!("Successfully subscribed to registry with ops_no: {}", request.ops_no),
                request_id: Some(uuid::Uuid::new_v4().to_string()),
                registry_response: Some(format!("Status: {}", registry_response.message.ack.status)),
            }))
        }
        Err(registry_error) => {
            error!("Registry subscription failed: {:?}", registry_error);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

================
File: ondc-bap/src/presentation/handlers/ondc.rs
================
//! ONDC protocol handlers for ONDC BAP Server

use axum::{
    extract::{Json, State},
    http::StatusCode,
    response::{Html, Json as JsonResponse},
};
use tracing::{error, info, instrument, warn};

use super::AppState;
use crate::services::{OnSubscribeRequest, OnSubscribeResponse};
use ondc_crypto_formats::decode_signature;

/// Site verification endpoint
#[instrument(skip(state))]
pub async fn serve_site_verification(
    State(state): State<AppState>,
) -> Result<Html<String>, StatusCode> {
    info!("Site verification page requested");

    // Get the stored request_id from the subscription call
    let stored_request_id = state.site_verification_service.get_current_request_id().await;
    
    match stored_request_id {
        Some(request_id) => {
            info!("Using stored request_id for site verification: {}", request_id);
            // Generate site verification with the stored request_id
            match state
                .site_verification_service
                .generate_site_verification_with_request_id(Some(&request_id))
                .await
            {
                Ok(html_content) => {
                    info!("Site verification page generated successfully with stored request_id");
                    Ok(Html(html_content))
                }
                Err(e) => {
                    error!("Failed to generate site verification: {}", e);
                    Err(StatusCode::INTERNAL_SERVER_ERROR)
                }
            }
        }
        None => {
            warn!("No stored request_id found, generating new one");
            // Fallback to generating a new request_id
            match state
                .site_verification_service
                .generate_site_verification()
                .await
            {
                Ok(html_content) => {
                    info!("Site verification page generated successfully");
                    Ok(Html(html_content))
                }
                Err(e) => {
                    error!("Failed to generate site verification: {}", e);
                    Err(StatusCode::INTERNAL_SERVER_ERROR)
                }
            }
        }
    }
}

/// Handle on-subscribe challenge from ONDC registry
#[instrument(skip(state, request), fields(subscriber_id = %request.subscriber_id))]
pub async fn handle_on_subscribe(
    State(state): State<AppState>,
    Json(request): Json<OnSubscribeRequest>,
) -> Result<JsonResponse<OnSubscribeResponse>, StatusCode> {
    info!("On-subscribe challenge received");

    // Validate request
    if let Err(e) = validate_on_subscribe_request(&request) {
        error!("Invalid on_subscribe request: {}", e);
        return Err(StatusCode::BAD_REQUEST);
    }

    // Process challenge
    match state.challenge_service.process_challenge(request).await {
        Ok(response) => {
            info!("Challenge processed successfully");
            Ok(JsonResponse(response))
        }
        Err(e) => {
            error!("Failed to process challenge: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

/// Participant information response
#[derive(serde::Serialize)]
pub struct ParticipantInfo {
    pub subscriber_id: String,
    pub signing_public_key: String,
    pub encryption_public_key: String,
    pub unique_key_id: String,
    pub status: String,
}

/// Get participant information endpoint
pub async fn get_participant_info(
    State(_state): State<AppState>,
) -> Result<JsonResponse<ParticipantInfo>, StatusCode> {
    info!("Participant info requested");

    // TODO: Implement actual participant info retrieval
    // For now, return placeholder data

    Ok(JsonResponse(ParticipantInfo {
        subscriber_id: "placeholder.example.com".to_string(),
        signing_public_key: "placeholder_signing_public_key".to_string(),
        encryption_public_key: "placeholder_encryption_public_key".to_string(),
        unique_key_id: "placeholder_key_id".to_string(),
        status: "placeholder_status".to_string(),
    }))
}

/// Validate on_subscribe request
fn validate_on_subscribe_request(request: &OnSubscribeRequest) -> Result<(), String> {
    if request.subscriber_id.is_empty() {
        return Err("Subscriber ID cannot be empty".to_string());
    }

    if request.challenge.is_empty() {
        return Err("Challenge cannot be empty".to_string());
    }

    // Validate base64 format
    if let Err(_) = decode_signature(&request.challenge) {
        return Err("Challenge must be valid base64".to_string());
    }

    Ok(())
}

================
File: ondc-bap/src/presentation/routes.rs
================
//! Route definitions for ONDC BAP Server

use axum::{
    middleware,
    routing::{get, post},
    Router,
};
use std::sync::Arc;
use tower_http::trace::TraceLayer;

use super::handlers::{
    admin_register, handle_on_subscribe, health_check, serve_site_verification, subscribe_to_registry, AppState,
};
use super::middleware::{
    cors_middleware, error_handling_middleware, logging_middleware, rate_limiting_middleware,
    security_headers_middleware,
};
use crate::{config::BAPConfig, services::RegistryClient};
use crate::services::KeyManagementService;

/// Create the main application router
pub fn create_router(config: Arc<BAPConfig>, key_manager: Arc<KeyManagementService>, registry_client: Arc<RegistryClient>) -> Router {
    // Create application state
    let app_state = AppState::new(config, key_manager, registry_client);

    // Create router with middleware stack
    Router::new()
        // Health and monitoring routes
        .route("/health", get(health_check))
        .route("/ready", get(super::handlers::health::readiness_check))
        .route("/live", get(super::handlers::health::liveness_check))
        .route("/metrics", get(metrics_handler))
        
        // ONDC protocol routes
        .route("/ondc-site-verification.html", get(serve_site_verification))
        .route("/on_subscribe", post(handle_on_subscribe))
        .route("/participant/info", get(super::handlers::ondc::get_participant_info))
        
        // Administrative routes
        .nest("/admin", admin_routes())
        
        // Apply middleware stack
        .layer(middleware::from_fn(logging_middleware))
        .layer(middleware::from_fn(security_headers_middleware))
        .layer(middleware::from_fn(error_handling_middleware))
        .layer(middleware::from_fn(rate_limiting_middleware))
        .layer(cors_middleware())
        .layer(TraceLayer::new_for_http())
        
        // Add application state
        .with_state(app_state)
}

/// Administrative routes
fn admin_routes() -> Router<AppState> {
    Router::new()
        .route("/register", post(admin_register))
        .route("/subscribe", post(subscribe_to_registry))
        .route("/config", post(super::handlers::admin::update_config))
        .route("/keys/rotate", post(super::handlers::admin::rotate_keys))
}

/// Metrics endpoint (Prometheus format)
async fn metrics_handler() -> String {
    // TODO: Implement actual metrics collection
    // For now, return basic Prometheus metrics

    r#"# HELP ondc_bap_requests_total Total number of requests
# TYPE ondc_bap_requests_total counter
ondc_bap_requests_total{endpoint="/health"} 0
ondc_bap_requests_total{endpoint="/ondc-site-verification.html"} 0
ondc_bap_requests_total{endpoint="/on_subscribe"} 0

# HELP ondc_bap_request_duration_seconds Request duration in seconds
# TYPE ondc_bap_request_duration_seconds histogram
ondc_bap_request_duration_seconds_bucket{le="0.1"} 0
ondc_bap_request_duration_seconds_bucket{le="0.5"} 0
ondc_bap_request_duration_seconds_bucket{le="1.0"} 0
ondc_bap_request_duration_seconds_bucket{le="+Inf"} 0

# HELP ondc_bap_up Server uptime status
# TYPE ondc_bap_up gauge
ondc_bap_up 1
"#
    .to_string()
}

================
File: ondc-bap/src/services/key_management_service.rs
================
//! Key Management Service for ONDC BAP Server
//!
//! This service provides secure key management capabilities including:
//! - Secure key loading from configuration
//! - Key validation and format verification
//! - Support for multiple key formats (base64, DER)
//! - Key rotation capabilities
//! - Automatic key zeroization on drop

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tracing::{error, info, instrument, warn};

use crate::config::app_config::KeyConfig;
use crate::config::ConfigError;
use ondc_crypto_algorithms::{Ed25519Signer, X25519KeyExchange};
use ondc_crypto_formats::{decode_signature, encode_signature};
use ondc_crypto_traits::{ONDCCryptoError, Signer};

/// Key management service error types
#[derive(Debug, thiserror::Error)]
pub enum KeyManagementError {
    #[error("Configuration error: {0}")]
    Config(#[from] ConfigError),

    #[error("Crypto error: {0}")]
    Crypto(#[from] ONDCCryptoError),

    #[error("Key validation failed: {0}")]
    ValidationFailed(String),

    #[error("Key format not supported: {0}")]
    UnsupportedFormat(String),

    #[error("Key rotation failed: {0}")]
    RotationFailed(String),

    #[error("Key storage error: {0}")]
    StorageError(String),

    #[error("Key not found: {0}")]
    KeyNotFound(String),

    #[error("Key expired: {0}")]
    KeyExpired(String),

    #[error("Key conversion error: {0}")]
    ConversionError(String),
}

/// Key metadata for tracking key lifecycle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyMetadata {
    pub key_id: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    pub key_type: KeyType,
    pub format: KeyFormat,
    pub is_active: bool,
    pub rotation_count: u32,
}

/// Supported key types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum KeyType {
    Ed25519Signing,
    X25519Encryption,
}

/// Supported key formats
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum KeyFormat {
    Base64,
    DER,
    Raw,
}

/// Key pair with metadata
pub struct KeyPairWithMetadata {
    pub signing_key: Option<Ed25519Signer>,
    pub encryption_key: Option<X25519KeyExchange>,
    pub metadata: KeyMetadata,
}

/// Key rotation policy
#[derive(Debug, Clone)]
pub struct KeyRotationPolicy {
    pub max_key_age_days: u32,
    pub rotation_grace_period_days: u32,
    pub auto_rotation_enabled: bool,
    pub backup_keys_required: bool,
}

impl Default for KeyRotationPolicy {
    fn default() -> Self {
        Self {
            max_key_age_days: 365,          // 1 year
            rotation_grace_period_days: 30, // 30 days grace period
            auto_rotation_enabled: false,
            backup_keys_required: true,
        }
    }
}

/// Main key management service
pub struct KeyManagementService {
    current_keys: Arc<tokio::sync::RwLock<KeyPairWithMetadata>>,
    backup_keys: Arc<tokio::sync::RwLock<Vec<KeyPairWithMetadata>>>,
    rotation_policy: KeyRotationPolicy,
}

impl KeyManagementService {
    /// Create a new key management service
    #[instrument(skip(config))]
    pub async fn new(config: KeyConfig) -> Result<Self, KeyManagementError> {
        info!("Initializing key management service");

        // Validate configuration
        config.validate()?;

        // Load keys from configuration
        let key_pair = Self::load_keys_from_config(&config).await?;

        let service = Self {
            current_keys: Arc::new(tokio::sync::RwLock::new(key_pair)),
            backup_keys: Arc::new(tokio::sync::RwLock::new(Vec::new())),
            rotation_policy: KeyRotationPolicy::default(),
        };

        info!("Key management service initialized successfully");
        Ok(service)
    }

    /// Load keys from configuration
    #[instrument(skip(config))]
    async fn load_keys_from_config(
        config: &KeyConfig,
    ) -> Result<KeyPairWithMetadata, KeyManagementError> {
        info!("Loading keys from configuration");

        // Load signing key
        let signing_key = Self::load_signing_key(&config.signing_private_key).await?;

        // Load encryption key
        let encryption_key = Self::load_encryption_key(&config.encryption_private_key).await?;

        let metadata = KeyMetadata {
            key_id: config.unique_key_id.clone(),
            created_at: chrono::Utc::now(),
            expires_at: None,                  // No expiration by default
            key_type: KeyType::Ed25519Signing, // Primary type
            format: KeyFormat::Base64,
            is_active: true,
            rotation_count: 0,
        };

        Ok(KeyPairWithMetadata {
            signing_key: Some(signing_key),
            encryption_key: Some(encryption_key),
            metadata,
        })
    }

    /// Load signing key from base64 string
    #[instrument(skip(key_b64))]
    async fn load_signing_key(key_b64: &str) -> Result<Ed25519Signer, KeyManagementError> {
        let key_bytes = decode_signature(key_b64).map_err(|e| {
            KeyManagementError::ValidationFailed(format!("Invalid signing key format: {}", e))
        })?;

        if key_bytes.len() != 32 {
            return Err(KeyManagementError::ValidationFailed(format!(
                "Invalid signing key length: expected 32 bytes, got {}",
                key_bytes.len()
            )));
        }

        let signer = Ed25519Signer::new(&key_bytes).map_err(|e| KeyManagementError::Crypto(e))?;

        Ok(signer)
    }

    /// Load encryption key from base64 string
    #[instrument(skip(key_b64))]
    async fn load_encryption_key(key_b64: &str) -> Result<X25519KeyExchange, KeyManagementError> {
        let key_bytes = decode_signature(key_b64).map_err(|e| {
            KeyManagementError::ValidationFailed(format!("Invalid encryption key format: {}", e))
        })?;

        if key_bytes.len() != 32 {
            return Err(KeyManagementError::ValidationFailed(format!(
                "Invalid encryption key length: expected 32 bytes, got {}",
                key_bytes.len()
            )));
        }

        let key_exchange =
            X25519KeyExchange::new(&key_bytes).map_err(|e| KeyManagementError::Crypto(e))?;

        Ok(key_exchange)
    }

    /// Get current signing key
    #[instrument(skip(self))]
    pub async fn get_signing_key(&self) -> Result<Ed25519Signer, KeyManagementError> {
        let keys = self.current_keys.read().await;

        if let Some(ref signer) = keys.signing_key {
            Ok(signer.clone())
        } else {
            Err(KeyManagementError::KeyNotFound(
                "Signing key not available".to_string(),
            ))
        }
    }

    /// Get current encryption key
    #[instrument(skip(self))]
    pub async fn get_encryption_key(&self) -> Result<X25519KeyExchange, KeyManagementError> {
        let keys = self.current_keys.read().await;

        if let Some(ref key_exchange) = keys.encryption_key {
            Ok(key_exchange.clone())
        } else {
            Err(KeyManagementError::KeyNotFound(
                "Encryption key not available".to_string(),
            ))
        }
    }

    /// Get signing public key
    #[instrument(skip(self))]
    pub async fn get_signing_public_key(&self) -> Result<String, KeyManagementError> {
        let signer = self.get_signing_key().await?;
        let public_key = signer.public_key();

        Ok(encode_signature(&public_key))
    }

    /// Get encryption public key in DER format (Base64 encoded)
    #[instrument(skip(self))]
    pub async fn get_encryption_public_key(&self) -> Result<String, KeyManagementError> {
        let key_exchange = self.get_encryption_key().await?;
        let public_key = key_exchange.public_key();

        // Convert to DER format as required by ONDC
        let der_key = ondc_crypto_formats::key_formats::x25519_public_key_to_der(&public_key)
            .map_err(|e| KeyManagementError::ConversionError(e.to_string()))?;

        Ok(encode_signature(&der_key))
    }

    /// Get unique key ID
    #[instrument(skip(self))]
    pub async fn get_unique_key_id(&self) -> String {
        let keys = self.current_keys.read().await;
        keys.metadata.key_id.clone()
    }

    /// Validate key pairs
    #[instrument(skip(self))]
    pub async fn validate_key_pairs(&self) -> Result<(), KeyManagementError> {
        info!("Validating key pairs");

        // Test signing key
        let signer = self.get_signing_key().await?;
        let test_message = b"test_message";
        let _signature = signer
            .sign(test_message)
            .map_err(|e| KeyManagementError::Crypto(e))?;

        // Test encryption key - just verify we can get the public key
        let key_exchange = self.get_encryption_key().await?;
        let _public_key = key_exchange.public_key();

        info!("Key pairs validated successfully");
        Ok(())
    }

    /// Rotate keys
    #[instrument(skip(self))]
    pub async fn rotate_keys(&self) -> Result<(), KeyManagementError> {
        info!("Starting key rotation");

        // Generate new key pair
        let new_signing_key =
            Ed25519Signer::generate().map_err(|e| KeyManagementError::Crypto(e))?;
        let new_encryption_key =
            X25519KeyExchange::generate().map_err(|e| KeyManagementError::Crypto(e))?;

        // Create new key pair with metadata
        let new_key_pair = KeyPairWithMetadata {
            signing_key: Some(new_signing_key),
            encryption_key: Some(new_encryption_key),
            metadata: KeyMetadata {
                key_id: format!("key_{}", chrono::Utc::now().timestamp()),
                created_at: chrono::Utc::now(),
                expires_at: None,
                key_type: KeyType::Ed25519Signing,
                format: KeyFormat::Base64,
                is_active: true,
                rotation_count: 0,
            },
        };

        // Backup current keys
        {
            let mut backup_keys = self.backup_keys.write().await;
            let mut current_keys = self.current_keys.write().await;

            // Mark current keys as inactive
            current_keys.metadata.is_active = false;

            // Add to backup
            backup_keys.push(current_keys.clone());

            // Replace with new keys
            *current_keys = new_key_pair;
        }

        info!("Key rotation completed successfully");
        Ok(())
    }

    /// Check if keys need rotation
    #[instrument(skip(self))]
    pub async fn check_rotation_needed(&self) -> Result<bool, KeyManagementError> {
        let keys = self.current_keys.read().await;

        if !self.rotation_policy.auto_rotation_enabled {
            return Ok(false);
        }

        let key_age = chrono::Utc::now() - keys.metadata.created_at;
        let max_age = chrono::Duration::days(self.rotation_policy.max_key_age_days as i64);

        Ok(key_age > max_age)
    }

    /// Get key metadata
    #[instrument(skip(self))]
    pub async fn get_key_metadata(&self) -> KeyMetadata {
        let keys = self.current_keys.read().await;
        keys.metadata.clone()
    }

    /// Export keys in specified format (for backup/rotation)
    #[instrument(skip(self))]
    pub async fn export_keys(&self, format: KeyFormat) -> Result<ExportedKeys, KeyManagementError> {
        let signer = self.get_signing_key().await?;
        let key_exchange = self.get_encryption_key().await?;

        let signing_private_key = signer.private_key();
        let encryption_private_key = key_exchange.private_key();

        let signing_public_key = signer.public_key();
        let encryption_public_key = key_exchange.public_key();

        let exported_keys = match format {
            KeyFormat::Base64 => ExportedKeys {
                signing_private_key: encode_signature(signing_private_key),
                encryption_private_key: encode_signature(encryption_private_key),
                signing_public_key: encode_signature(&signing_public_key),
                encryption_public_key: encode_signature(&encryption_public_key),
                format: KeyFormat::Base64,
            },
            KeyFormat::DER => ExportedKeys {
                signing_private_key: encode_signature(signing_private_key), // TODO: Implement DER encoding
                encryption_private_key: encode_signature(encryption_private_key),
                signing_public_key: encode_signature(&signing_public_key),
                encryption_public_key: encode_signature(&encryption_public_key),
                format: KeyFormat::DER,
            },
            KeyFormat::Raw => {
                return Err(KeyManagementError::UnsupportedFormat(
                    "Raw format not supported for export".to_string(),
                ));
            }
        };

        Ok(exported_keys)
    }

    /// Set rotation policy
    #[instrument(skip(self))]
    pub fn set_rotation_policy(&mut self, policy: KeyRotationPolicy) {
        self.rotation_policy = policy;
        info!("Key rotation policy updated");
    }

    /// Get rotation policy
    #[instrument(skip(self))]
    pub fn get_rotation_policy(&self) -> &KeyRotationPolicy {
        &self.rotation_policy
    }
}

/// Exported keys structure
#[derive(Debug, Clone, Serialize)]
pub struct ExportedKeys {
    pub signing_private_key: String,
    pub encryption_private_key: String,
    pub signing_public_key: String,
    pub encryption_public_key: String,
    pub format: KeyFormat,
}

impl Clone for KeyPairWithMetadata {
    fn clone(&self) -> Self {
        Self {
            signing_key: self.signing_key.as_ref().map(|k| k.clone()),
            encryption_key: self.encryption_key.as_ref().map(|k| k.clone()),
            metadata: self.metadata.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_management_service_creation() {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        runtime.block_on(async {
            let config = KeyConfig {
                signing_private_key: "iblY/8ruRp43aGEjuCtJrs5QyAhaHroQIaUgWKNScco=".to_string(),
                encryption_private_key: "CeBWrM0FhC47Zek6QKCMopzNFC5U3JizkOuDYVqUXno=".to_string(),
                unique_key_id: "test_key_1".to_string(),
            };

            let service = KeyManagementService::new(config).await;
            assert!(service.is_ok());
        });
    }

    #[test]
    fn test_key_validation() {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        runtime.block_on(async {
            let config = KeyConfig {
                signing_private_key: "iblY/8ruRp43aGEjuCtJrs5QyAhaHroQIaUgWKNScco=".to_string(),
                encryption_private_key: "CeBWrM0FhC47Zek6QKCMopzNFC5U3JizkOuDYVqUXno=".to_string(),
                unique_key_id: "test_key_1".to_string(),
            };

            let service = KeyManagementService::new(config).await.unwrap();
            let result = service.validate_key_pairs().await;
            assert!(result.is_ok());
        });
    }

    #[test]
    fn test_public_key_export() {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        runtime.block_on(async {
            let config = KeyConfig {
                signing_private_key: "iblY/8ruRp43aGEjuCtJrs5QyAhaHroQIaUgWKNScco=".to_string(),
                encryption_private_key: "CeBWrM0FhC47Zek6QKCMopzNFC5U3JizkOuDYVqUXno=".to_string(),
                unique_key_id: "test_key_1".to_string(),
            };

            let service = KeyManagementService::new(config).await.unwrap();

            let signing_pub = service.get_signing_public_key().await;
            assert!(signing_pub.is_ok());

            let encryption_pub = service.get_encryption_public_key().await;
            assert!(encryption_pub.is_ok());
        });
    }

    #[test]
    fn test_key_rotation() {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        runtime.block_on(async {
            let config = KeyConfig {
                signing_private_key: "iblY/8ruRp43aGEjuCtJrs5QyAhaHroQIaUgWKNScco=".to_string(),
                encryption_private_key: "CeBWrM0FhC47Zek6QKCMopzNFC5U3JizkOuDYVqUXno=".to_string(),
                unique_key_id: "test_key_1".to_string(),
            };

            let service = KeyManagementService::new(config).await.unwrap();

            // Get original public keys
            let original_signing_pub = service.get_signing_public_key().await.unwrap();
            let original_encryption_pub = service.get_encryption_public_key().await.unwrap();

            // Rotate keys
            let rotation_result = service.rotate_keys().await;
            assert!(rotation_result.is_ok());

            // Get new public keys
            let new_signing_pub = service.get_signing_public_key().await.unwrap();
            let new_encryption_pub = service.get_encryption_public_key().await.unwrap();

            // Keys should be different
            assert_ne!(original_signing_pub, new_signing_pub);
            assert_ne!(original_encryption_pub, new_encryption_pub);
        });
    }
}

================
File: ondc-crypto-formats/src/lib.rs
================
//! Encoding and decoding utilities for ONDC cryptographic operations.
//!
//! This crate provides utilities for encoding and decoding cryptographic
//! data in various formats, including Base64, hex, and key format conversions.

pub mod base64;
pub mod key_formats;

pub use base64::{
    decode_signature, decode_signature_secure, decode_signature_variant, encode_signature,
    encode_signature_secure, encode_signature_variant, is_valid_base64, Base64Variant,
};
pub use key_formats::{
    ed25519_from_raw,
    ed25519_private_key_from_base64,
    ed25519_private_key_from_der,
    // Ed25519 conversions
    ed25519_private_key_to_base64,
    ed25519_private_key_to_der,
    ed25519_public_key_from_base64,
    ed25519_public_key_to_base64,
    x25519_private_key_from_base64,
    x25519_private_key_from_der,
    // X25519 conversions
    x25519_private_key_to_base64,
    x25519_private_key_to_der,
    x25519_public_key_from_base64,
    x25519_public_key_from_der,
    x25519_public_key_to_base64,
    x25519_public_key_to_der,
    x25519_to_der,
};

/// Re-export commonly used types
pub mod prelude {
    pub use super::base64::{
        decode_signature, decode_signature_secure, decode_signature_variant, encode_signature,
        encode_signature_secure, encode_signature_variant, is_valid_base64, Base64Variant,
    };
    pub use super::key_formats::{
        ed25519_from_raw,
        ed25519_private_key_from_base64,
        ed25519_private_key_from_der,
        // Ed25519 conversions
        ed25519_private_key_to_base64,
        ed25519_private_key_to_der,
        ed25519_public_key_from_base64,
        ed25519_public_key_to_base64,
        x25519_private_key_from_base64,
        x25519_private_key_from_der,
        // X25519 conversions
        x25519_private_key_to_base64,
        x25519_private_key_to_der,
        x25519_public_key_from_base64,
        x25519_public_key_from_der,
        x25519_public_key_to_base64,
        x25519_public_key_to_der,
        x25519_to_der,
    };
}

================
File: ondc-crypto-traits/src/traits.rs
================
//! Core traits for ONDC cryptographic operations.
//!
//! This module defines the foundational traits used throughout the ONDC crypto SDK.
//! All traits are designed with security, performance, and extensibility in mind.
//!
//! # Security Considerations
//!
//! - All traits that handle sensitive data should implement proper memory zeroization
//! - Signing operations must be deterministic and constant-time where possible
//! - Verification operations must use constant-time comparisons to prevent timing attacks
//! - Key material should be handled with appropriate security measures

// ONDCCryptoError is used in the documentation examples

/// Trait for signing operations.
///
/// This trait provides a generic interface for digital signature creation.
/// Implementations should ensure deterministic output and constant-time operations
/// where possible to prevent side-channel attacks.
///
/// # Safety Requirements
///
/// - Signing operations must be deterministic (same input produces same output)
/// - Implementations should use constant-time algorithms where possible
/// - Private key material must be handled securely and zeroized after use
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{Signer, ONDCCryptoError};
///
/// struct MySigner;
///
/// impl Signer for MySigner {
///     type Error = ONDCCryptoError;
///     type Signature = Vec<u8>;
///     
///     fn sign(&self, message: &[u8]) -> Result<Self::Signature, Self::Error> {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait Signer {
    /// The error type returned by signing operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// The signature type.
    type Signature: AsRef<[u8]>;

    /// Sign a message.
    ///
    /// # Arguments
    ///
    /// * `message` - The message to sign
    ///
    /// # Returns
    ///
    /// Returns a signature that can be used to verify the message authenticity.
    ///
    /// # Errors
    ///
    /// Returns an error if signing fails due to invalid key material,
    /// unsupported message format, or cryptographic failures.
    ///
    /// # Security Notes
    ///
    /// - This operation must be deterministic
    /// - Implementations should use constant-time algorithms
    /// - Private key material should be handled securely
    fn sign(&self, message: &[u8]) -> Result<Self::Signature, Self::Error>;
}

/// Trait for verification operations.
///
/// This trait provides a generic interface for digital signature verification.
/// Implementations must use constant-time comparisons to prevent timing attacks.
///
/// # Safety Requirements
///
/// - Verification must use constant-time comparisons
/// - Implementations should validate all inputs before processing
/// - Public keys should be validated for correct format and length
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{Verifier, ONDCCryptoError};
///
/// struct MyVerifier;
///
/// impl Verifier for MyVerifier {
///     type Error = ONDCCryptoError;
///     type PublicKey = [u8; 32];
///     type Signature = [u8; 64];
///     
///     fn verify(
///         &self,
///         public_key: &Self::PublicKey,
///         message: &[u8],
///         signature: &Self::Signature,
///     ) -> Result<(), Self::Error> {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait Verifier {
    /// The error type returned by verification operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// The public key type.
    type PublicKey: AsRef<[u8]>;

    /// The signature type.
    type Signature: AsRef<[u8]>;

    /// Verify a signature.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The public key to verify against
    /// * `message` - The original message that was signed
    /// * `signature` - The signature to verify
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the signature is valid, or an error if verification fails.
    ///
    /// # Errors
    ///
    /// Returns an error if verification fails due to invalid signature,
    /// malformed public key, or cryptographic failures.
    ///
    /// # Security Notes
    ///
    /// - This operation must use constant-time comparisons
    /// - All inputs should be validated before processing
    /// - Implementations should be resistant to timing attacks
    fn verify(
        &self,
        public_key: &Self::PublicKey,
        message: &[u8],
        signature: &Self::Signature,
    ) -> Result<(), Self::Error>;
}

/// Trait for hashing operations.
///
/// This trait provides a generic interface for cryptographic hashing.
/// Implementations should use secure hash functions suitable for the intended use case.
///
/// # Safety Requirements
///
/// - Hash functions should be cryptographically secure
/// - Output should be deterministic for the same input
/// - Variable-length output should be handled securely
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{Hasher, ONDCCryptoError};
///
/// struct MyHasher;
///
/// impl Hasher for MyHasher {
///     type Error = ONDCCryptoError;
///     type Output = Vec<u8>;
///     
///     fn hash(&self, data: &[u8]) -> Result<Self::Output, Self::Error> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn hash_with_length(&self, data: &[u8], length: usize) -> Result<Self::Output, Self::Error> {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait Hasher {
    /// The error type returned by hashing operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// The hash output type.
    type Output: AsRef<[u8]>;

    /// Hash data with default output length.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to hash
    ///
    /// # Returns
    ///
    /// Returns the hash of the input data using the default output length.
    ///
    /// # Errors
    ///
    /// Returns an error if hashing fails due to unsupported input or
    /// cryptographic failures.
    fn hash(&self, data: &[u8]) -> Result<Self::Output, Self::Error>;

    /// Hash data with specified output length.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to hash
    /// * `length` - The desired output length in bytes
    ///
    /// # Returns
    ///
    /// Returns the hash of the input data with the specified output length.
    ///
    /// # Errors
    ///
    /// Returns an error if the requested length is not supported or
    /// hashing fails for other reasons.
    ///
    /// # Security Notes
    ///
    /// - Output length should be validated against security requirements
    /// - Variable-length output should be handled carefully to prevent
    ///   length extension attacks where applicable
    fn hash_with_length(&self, data: &[u8], length: usize) -> Result<Self::Output, Self::Error>;
}

/// Trait for key pair operations.
///
/// This trait provides a generic interface for cryptographic key pairs.
/// Implementations should handle private key material securely.
///
/// # Safety Requirements
///
/// - Private key material must be zeroized when dropped
/// - Key generation should use cryptographically secure random number generators
/// - Key validation should be performed on creation
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{KeyPair, ONDCCryptoError};
///
/// struct MyKeyPair;
///
/// impl KeyPair for MyKeyPair {
///     type Error = ONDCCryptoError;
///     type PrivateKey = Vec<u8>;
///     type PublicKey = [u8; 32];
///     
///     fn generate() -> Result<Self, Self::Error> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn from_private_key(private_key: &[u8]) -> Result<Self, Self::Error> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn public_key(&self) -> &Self::PublicKey {
///         // Implementation here
///         todo!()
///     }
///     
///     fn private_key(&self) -> &Self::PrivateKey {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait KeyPair {
    /// The error type returned by key pair operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// The private key type.
    type PrivateKey: AsRef<[u8]> + zeroize::Zeroize;

    /// The public key type.
    type PublicKey: AsRef<[u8]>;

    /// Generate a new key pair.
    ///
    /// # Returns
    ///
    /// Returns a newly generated key pair using cryptographically secure
    /// random number generation.
    ///
    /// # Errors
    ///
    /// Returns an error if key generation fails due to insufficient entropy
    /// or cryptographic failures.
    ///
    /// # Security Notes
    ///
    /// - Key generation must use cryptographically secure RNG
    /// - Generated keys should be validated for correctness
    fn generate() -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Create a key pair from an existing private key.
    ///
    /// # Arguments
    ///
    /// * `private_key` - The private key bytes
    ///
    /// # Returns
    ///
    /// Returns a key pair derived from the provided private key.
    ///
    /// # Errors
    ///
    /// Returns an error if the private key is invalid, malformed, or
    /// unsupported.
    ///
    /// # Security Notes
    ///
    /// - Private key should be validated for correct format and length
    /// - The private key material should be handled securely
    fn from_private_key(private_key: &[u8]) -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Get the public key from this key pair.
    ///
    /// # Returns
    ///
    /// Returns a reference to the public key.
    fn public_key(&self) -> &Self::PublicKey;

    /// Get the private key from this key pair.
    ///
    /// # Returns
    ///
    /// Returns a reference to the private key.
    ///
    /// # Security Notes
    ///
    /// - This method should be used carefully as it exposes private key material
    /// - Callers should ensure the returned data is handled securely
    /// - Consider using `zeroize::Zeroizing` for temporary storage
    fn private_key(&self) -> &Self::PrivateKey;
}

/// Trait for public key operations.
///
/// This trait provides a generic interface for public key validation and
/// format conversion.
///
/// # Safety Requirements
///
/// - Public key validation should be thorough and secure
/// - Format conversions should preserve key integrity
/// - Implementations should be resistant to malformed input
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{PublicKey, ONDCCryptoError};
///
/// struct MyPublicKey([u8; 32]);
///
/// impl PublicKey for MyPublicKey {
///     type Error = ONDCCryptoError;
///     
///     fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Error> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn to_bytes(&self) -> Vec<u8> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn validate(&self) -> Result<(), Self::Error> {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait PublicKey {
    /// The error type returned by public key operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Create a public key from raw bytes.
    ///
    /// # Arguments
    ///
    /// * `bytes` - The raw public key bytes
    ///
    /// # Returns
    ///
    /// Returns a public key instance if the bytes are valid.
    ///
    /// # Errors
    ///
    /// Returns an error if the bytes are invalid, malformed, or unsupported.
    fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Convert the public key to raw bytes.
    ///
    /// # Returns
    ///
    /// Returns the public key as raw bytes.
    fn to_bytes(&self) -> Vec<u8>;

    /// Validate the public key.
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the public key is valid, or an error if validation fails.
    ///
    /// # Errors
    ///
    /// Returns an error if the public key is invalid, malformed, or corrupted.
    fn validate(&self) -> Result<(), Self::Error>;
}

/// Trait for ONDC-specific signing string operations.
///
/// This trait provides functionality for creating and validating ONDC signing strings,
/// which are used in HTTP signature generation and verification.
///
/// # ONDC Signing String Format
///
/// ONDC signing strings follow this format:
/// ```text
/// (created): {timestamp}
/// (expires): {timestamp}
/// digest: BLAKE-512={base64_digest}
/// ```
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_traits::{SigningString, ONDCCryptoError};
///
/// struct MySigningString;
///
/// impl SigningString for MySigningString {
///     type Error = ONDCCryptoError;
///     
///     fn create(
///         body: &[u8],
///         created: Option<u64>,
///         expires: Option<u64>,
///     ) -> Result<Self, Self::Error> {
///         // Implementation here
///         todo!()
///     }
///     
///     fn to_string(&self) -> String {
///         // Implementation here
///         todo!()
///     }
///     
///     fn created(&self) -> u64 {
///         // Implementation here
///         todo!()
///     }
///     
///     fn expires(&self) -> u64 {
///         // Implementation here
///         todo!()
///     }
///     
///     fn digest(&self) -> &str {
///         // Implementation here
///         todo!()
///     }
/// }
/// ```
pub trait SigningString {
    /// The error type returned by signing string operations.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Create a signing string from a request body and optional timestamps.
    ///
    /// # Arguments
    ///
    /// * `body` - The request body to create a digest from
    /// * `created` - Optional creation timestamp (uses current time if None)
    /// * `expires` - Optional expiration timestamp (uses created + 1 hour if None)
    ///
    /// # Returns
    ///
    /// Returns a signing string instance ready for signing.
    ///
    /// # Errors
    ///
    /// Returns an error if timestamp validation fails or digest creation fails.
    fn create(body: &[u8], created: Option<u64>, expires: Option<u64>) -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Convert the signing string to its string representation.
    ///
    /// # Returns
    ///
    /// Returns the signing string in the standard ONDC format.
    fn to_string(&self) -> String;

    /// Get the creation timestamp.
    fn created(&self) -> u64;

    /// Get the expiration timestamp.
    fn expires(&self) -> u64;

    /// Get the digest string.
    fn digest(&self) -> &str;
}

// Note: ONDCCryptoError already implements std::error::Error + Send + Sync
// via thiserror, so it can be automatically converted to Box<dyn std::error::Error + Send + Sync>
// using the standard library's blanket implementation.

================
File: ondc-bap/src/config/ondc_config.rs
================
//! ONDC-specific configuration

use serde::{Deserialize, Serialize};
use ondc_crypto_formats::{decode_signature, key_formats::x25519_public_key_from_der};
use crate::config::ConfigError;

/// ONDC environment types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]
pub enum Environment {
    #[serde(rename = "staging")]
    Staging,
    #[serde(rename = "preprod")]
    PreProd,
    #[serde(rename = "production")]
    Production,
}

impl Environment {
    /// Get the registry base URL for this environment
    pub fn registry_url(&self) -> &'static str {
        match self {
            Environment::Staging => "https://staging.registry.ondc.org",
            Environment::PreProd => "https://preprod.registry.ondc.org",
            Environment::Production => "https://prod.registry.ondc.org",
        }
    }

    /// Get the ONDC public key for this environment
    pub fn ondc_public_key(&self) -> &'static str {
        match self {
            Environment::Staging => "MCowBQYDK2VuAyEAduMuZgmtpjdCuxv+Nc49K0cB6tL/Dj3HZetvVN7ZekM=",
            Environment::PreProd => "MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=",
            Environment::Production => {
                "MCowBQYDK2VuAyEAvVEyZY91O2yV8w8/CAwVDAnqIZDJJUPdLUUKwLo3K0M="
            }
        }
    }
}

impl Default for Environment {
    fn default() -> Self {
        Environment::Staging
    }
}

impl std::str::FromStr for Environment {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "staging" => Ok(Environment::Staging),
            "preprod" => Ok(Environment::PreProd),
            "production" => Ok(Environment::Production),
            _ => Err(format!("Unknown environment: {}", s)),
        }
    }
}

/// GST configuration for business entity
#[derive(Debug, Clone, Deserialize)]
pub struct GstConfig {
    pub legal_entity_name: String,
    pub business_address: String,
    pub city_code: Vec<String>,
    pub gst_no: Option<String>,
}

/// PAN configuration for business entity
#[derive(Debug, Clone, Deserialize)]
pub struct PanConfig {
    pub name_as_per_pan: String,
    pub pan_no: String,
    pub date_of_incorporation: String,
}

/// Business entity configuration
#[derive(Debug, Clone, Deserialize)]
pub struct BusinessEntityConfig {
    pub gst: GstConfig,
    pub pan: PanConfig,
    pub name_of_authorised_signatory: String,
    pub address_of_authorised_signatory: String,
    pub email_id: String,
    pub mobile_no: u64,
    pub country: String,
}

/// Network participant configuration
#[derive(Debug, Clone, Deserialize)]
pub struct NetworkParticipantConfig {
    pub subscriber_url: String,
    pub domain: String,
    pub participant_type: ParticipantType,
    pub msn: bool,
    pub city_code: Vec<String>,
}

/// Participant type enumeration
#[derive(Debug, Clone, Deserialize, Serialize)]
pub enum ParticipantType {
    #[serde(rename = "buyerApp")]
    BuyerApp,
    #[serde(rename = "sellerApp")]
    SellerApp,
    #[serde(rename = "gateway")]
    Gateway,
}

/// ONDC configuration
#[derive(Debug, Clone, Deserialize)]
pub struct ONDCConfig {
    pub environment: Environment,
    pub registry_base_url: String,
    pub subscriber_id: String,
    pub callback_url: String,
    pub request_timeout_secs: u64,
    pub max_retries: usize,
    pub business_entity: BusinessEntityConfig,
    pub network_participants: Option<Vec<NetworkParticipantConfig>>,
}

impl ONDCConfig {
    /// Create ONDC config with default values for environment
    pub fn new(environment: Environment, subscriber_id: String) -> Self {
        Self {
            environment,
            registry_base_url: environment.registry_url().to_string(),
            subscriber_id,
            callback_url: "/".to_string(),
            request_timeout_secs: 30,
            max_retries: 3,
            business_entity: BusinessEntityConfig {
                gst: GstConfig {
                    legal_entity_name: "Default Entity".to_string(),
                    business_address: "Default Address".to_string(),
                    city_code: vec!["std:080".to_string()],
                    gst_no: None,
                },
                pan: PanConfig {
                    name_as_per_pan: "Default Entity".to_string(),
                    pan_no: "AAAAA0000A".to_string(),
                    date_of_incorporation: "01/01/2020".to_string(),
                },
                name_of_authorised_signatory: "Default Signatory".to_string(),
                address_of_authorised_signatory: "Default Address".to_string(),
                email_id: "default@example.com".to_string(),
                mobile_no: 9999999999,
                country: "IND".to_string(),
            },
            network_participants: None,
        }
    }

    /// Get the ONDC public key for this environment
    pub fn ondc_public_key(&self) -> &'static str {
        self.environment.ondc_public_key()
    }

    /// Get the decoded ONDC public key as raw bytes
    pub fn ondc_public_key_bytes(&self) -> Result<[u8; 32], ConfigError> {
        let public_key_b64 = self.ondc_public_key();
        let decoded = decode_signature(public_key_b64)
            .map_err(|e| ConfigError::InvalidONDCKey(format!("Failed to decode ONDC public key: {}", e)))?;
        
        // Properly decode from DER format using the key_formats module
        let key = x25519_public_key_from_der(&decoded)
            .map_err(|e| ConfigError::InvalidONDCKey(format!("Failed to decode ONDC public key from DER: {}", e)))?;
        
        Ok(key)
    }
}

impl Default for ONDCConfig {
    fn default() -> Self {
        Self {
            environment: Environment::Staging,
            registry_base_url: Environment::Staging.registry_url().to_string(),
            subscriber_id: "example.com".to_string(),
            callback_url: "/".to_string(),
            request_timeout_secs: 30,
            max_retries: 3,
            business_entity: BusinessEntityConfig {
                gst: GstConfig {
                    legal_entity_name: "Example Entity".to_string(),
                    business_address: "Example Address".to_string(),
                    city_code: vec!["std:080".to_string()],
                    gst_no: None,
                },
                pan: PanConfig {
                    name_as_per_pan: "Example Entity".to_string(),
                    pan_no: "AAAAA0000A".to_string(),
                    date_of_incorporation: "01/01/2020".to_string(),
                },
                name_of_authorised_signatory: "Example Signatory".to_string(),
                address_of_authorised_signatory: "Example Address".to_string(),
                email_id: "example@example.com".to_string(),
                mobile_no: 9999999999,
                country: "IND".to_string(),
            },
            network_participants: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_environment_parsing() {
        assert_eq!(
            "staging".parse::<Environment>().unwrap(),
            Environment::Staging
        );
        assert_eq!(
            "preprod".parse::<Environment>().unwrap(),
            Environment::PreProd
        );
        assert_eq!(
            "production".parse::<Environment>().unwrap(),
            Environment::Production
        );
        assert!("invalid".parse::<Environment>().is_err());
    }

    #[test]
    fn test_environment_urls() {
        assert_eq!(
            Environment::Staging.registry_url(),
            "https://staging.registry.ondc.org"
        );
        assert_eq!(
            Environment::PreProd.registry_url(),
            "https://preprod.registry.ondc.org"
        );
        assert_eq!(
            Environment::Production.registry_url(),
            "https://prod.registry.ondc.org"
        );
    }

    #[test]
    fn test_ondc_config_default() {
        let config = ONDCConfig::default();
        assert_eq!(config.environment, Environment::Staging);
        assert_eq!(config.subscriber_id, "example.com");
        assert_eq!(config.request_timeout_secs, 30);
        assert_eq!(config.business_entity.country, "IND");
        assert_eq!(config.network_participants.is_none(), true);
    }

    #[test]
    fn test_ondc_config_new() {
        let config = ONDCConfig::new(Environment::Production, "test.com".to_string());
        assert_eq!(config.environment, Environment::Production);
        assert_eq!(config.subscriber_id, "test.com");
        assert_eq!(
            config.registry_base_url,
            Environment::Production.registry_url()
        );
    }
}

================
File: ondc-bap/src/presentation/handlers/mod.rs
================
//! Request handlers for ONDC BAP Server

use std::sync::Arc;

use crate::config::BAPConfig;
use crate::services::{KeyManagementService, SiteVerificationService, ChallengeService, RegistryClient};

/// Application state shared across all handlers
#[derive(Clone)]
pub struct AppState {
    pub config: Arc<BAPConfig>,
    pub key_manager: Arc<KeyManagementService>,
    pub site_verification_service: Arc<SiteVerificationService>,
    pub challenge_service: Arc<ChallengeService>,
    pub registry_client: Arc<RegistryClient>,
    // TODO: Add other services as they are implemented
    // pub onboarding_service: Arc<OnboardingService>,
}

impl AppState {
    /// Create new application state
    pub fn new(
        config: Arc<BAPConfig>, 
        key_manager: Arc<KeyManagementService>,
        registry_client: Arc<RegistryClient>,
    ) -> Self {
        let site_verification_service = Arc::new(SiteVerificationService::new(
            key_manager.clone(),
            config.clone(),
        ));
        let challenge_service = Arc::new(ChallengeService::new(
            key_manager.clone(),
            config.clone(),
        ));

        Self {
            config,
            key_manager,
            site_verification_service,
            challenge_service,
            registry_client,
        }
    }
}

// Handler modules
pub mod admin;
pub mod health;
pub mod ondc;

// Re-export handler functions
pub use admin::{admin_register, admin_status, admin_health, subscribe_to_registry};
pub use health::health_check;
pub use ondc::{handle_on_subscribe, serve_site_verification};

================
File: ondc-bap/src/services/mod.rs
================
//! Services layer for ONDC BAP Server
//!
//! This module contains all the business logic services including:
//! - Key management and cryptographic operations
//! - Site verification generation
//! - Challenge processing
//! - Registry client for ONDC API interactions

pub mod challenge_service;
pub mod key_management_service;
pub mod registry_client;
pub mod site_verification_service;

pub use challenge_service::{ChallengeService, OnSubscribeRequest, OnSubscribeResponse};
pub use key_management_service::KeyManagementService;
pub use registry_client::{RegistryClient, RegistryClientError, SubscribeRequest, SubscribeResponse};
pub use site_verification_service::SiteVerificationService;

================
File: ondc-crypto-algorithms/Cargo.toml
================
[package]
name = "ondc-crypto-algorithms"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
description = "Cryptographic algorithm implementations for ONDC"
keywords.workspace = true
categories.workspace = true
readme.workspace = true

[dependencies]
# Internal crates
ondc-crypto-traits = { path = "../ondc-crypto-traits" }

# Cryptographic dependencies
ed25519-dalek = { workspace = true, features = ["rand_core"] }
blake2b_simd = { workspace = true }
x25519-dalek = { workspace = true, features = ["static_secrets"] }
aes = "0.8"
cipher = "0.4"

# Memory safety
zeroize = { workspace = true }
subtle = { workspace = true }

# Random number generation
rand = { workspace = true }

================
File: ondc-crypto-formats/src/key_formats.rs
================
//! Key format conversion utilities for ONDC cryptographic operations.
//!
//! This module provides utilities for converting cryptographic keys between
//! different formats including raw bytes, Base64 encoding, and DER encoding.
//! It supports both Ed25519 and X25519 key types with proper validation
//! and security measures.
//!
//! # Security Features
//!
//! - Automatic memory zeroization for sensitive data
//! - Input validation for all key formats
//! - Constant-time operations where applicable
//! - Comprehensive error handling with detailed messages
//! - Support for both public and private key conversions
//!
//! # Examples
//!
//! ```rust
//! use ondc_crypto_formats::key_formats;
//!
//! // Convert Ed25519 private key from raw bytes to Base64
//! let raw_key = [0u8; 32]; // Use a real private key in practice
//! let base64_key = key_formats::ed25519_private_key_to_base64(&raw_key).unwrap();
//!
//! // Convert X25519 public key to DER format
//! let public_key = [0u8; 32]; // Use a real public key in practice
//! let der_key = key_formats::x25519_public_key_to_der(&public_key).unwrap();
//! ```

use der::{asn1::OctetString, Decode, Encode};
use ondc_crypto_traits::ONDCCryptoError;
use zeroize::Zeroizing;

use crate::base64::{decode_signature, encode_signature};

// ============================================================================
// Ed25519 Key Format Conversions
// ============================================================================

/// Convert Ed25519 private key from raw bytes to Base64 encoding.
///
/// This function takes a raw 32-byte Ed25519 private key and encodes it
/// using standard Base64 encoding suitable for ONDC operations.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte Ed25519 private key
///
/// # Returns
///
/// A Base64-encoded string representation of the private key.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
///
/// # Security Notes
///
/// - The input key should be handled securely
/// - Consider using `zeroize::Zeroizing` for temporary storage
/// - The returned string contains sensitive data and should be protected
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real private key in practice
/// let base64_key = key_formats::ed25519_private_key_to_base64(&raw_key).unwrap();
/// assert_eq!(base64_key.len(), 44); // Base64 encoding of 32 bytes
/// ```
pub fn ed25519_private_key_to_base64(raw_key: &[u8]) -> Result<String, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    Ok(encode_signature(raw_key))
}

/// Convert Ed25519 private key from Base64 encoding to raw bytes.
///
/// This function takes a Base64-encoded Ed25519 private key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `base64_key` - The Base64-encoded Ed25519 private key
///
/// # Returns
///
/// The raw 32-byte Ed25519 private key in a `Zeroizing` container.
///
/// # Errors
///
/// Returns an error if:
/// - The Base64 encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Security Notes
///
/// - The returned key is automatically zeroized when dropped
/// - The input string should be handled securely
/// - Consider clearing the input string after use
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let base64_key = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
/// let raw_key = key_formats::ed25519_private_key_from_base64(base64_key).unwrap();
/// assert_eq!(raw_key.len(), 32);
/// ```
pub fn ed25519_private_key_from_base64(
    base64_key: &str,
) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
    let decoded = decode_signature(base64_key)?;

    if decoded.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: decoded.len(),
        });
    }

    Ok(Zeroizing::new(decoded))
}

/// Convert Ed25519 public key from raw bytes to Base64 encoding.
///
/// This function takes a raw 32-byte Ed25519 public key and encodes it
/// using standard Base64 encoding.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte Ed25519 public key
///
/// # Returns
///
/// A Base64-encoded string representation of the public key.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real public key in practice
/// let base64_key = key_formats::ed25519_public_key_to_base64(&raw_key).unwrap();
/// assert_eq!(base64_key.len(), 44); // Base64 encoding of 32 bytes
/// ```
pub fn ed25519_public_key_to_base64(raw_key: &[u8]) -> Result<String, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    Ok(encode_signature(raw_key))
}

/// Convert Ed25519 public key from Base64 encoding to raw bytes.
///
/// This function takes a Base64-encoded Ed25519 public key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `base64_key` - The Base64-encoded Ed25519 public key
///
/// # Returns
///
/// The raw 32-byte Ed25519 public key.
///
/// # Errors
///
/// Returns an error if:
/// - The Base64 encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let base64_key = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
/// let raw_key = key_formats::ed25519_public_key_from_base64(base64_key).unwrap();
/// assert_eq!(raw_key.len(), 32);
/// ```
pub fn ed25519_public_key_from_base64(base64_key: &str) -> Result<[u8; 32], ONDCCryptoError> {
    let decoded = decode_signature(base64_key)?;

    if decoded.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: decoded.len(),
        });
    }

    let mut key = [0u8; 32];
    key.copy_from_slice(&decoded);
    Ok(key)
}

/// Convert Ed25519 private key from raw bytes to DER format.
///
/// This function takes a raw 32-byte Ed25519 private key and encodes it
/// in DER format according to RFC 8410.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte Ed25519 private key
///
/// # Returns
///
/// The DER-encoded private key as bytes.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
/// - DER encoding fails
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real private key in practice
/// let der_key = key_formats::ed25519_private_key_to_der(&raw_key).unwrap();
/// assert!(der_key.len() > 32); // DER encoding adds structure
/// ```
pub fn ed25519_private_key_to_der(raw_key: &[u8]) -> Result<Vec<u8>, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    // Create DER structure for Ed25519 private key
    let octet_string = OctetString::new(raw_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER encoding failed: {}", e)))?;

    octet_string
        .to_der()
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER serialization failed: {}", e)))
}

/// Convert Ed25519 private key from DER format to raw bytes.
///
/// This function takes a DER-encoded Ed25519 private key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `der_key` - The DER-encoded Ed25519 private key
///
/// # Returns
///
/// The raw 32-byte Ed25519 private key in a `Zeroizing` container.
///
/// # Errors
///
/// Returns an error if:
/// - The DER encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Security Notes
///
/// - The returned key is automatically zeroized when dropped
/// - The input should be handled securely
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32];
/// let der_key = key_formats::ed25519_private_key_to_der(&raw_key).unwrap();
/// let decoded_key = key_formats::ed25519_private_key_from_der(&der_key).unwrap();
/// assert_eq!(decoded_key.as_slice(), &raw_key);
/// ```
pub fn ed25519_private_key_from_der(der_key: &[u8]) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
    let octet_string = OctetString::from_der(der_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER decoding failed: {}", e)))?;

    let key_bytes = octet_string.as_bytes();

    if key_bytes.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: key_bytes.len(),
        });
    }

    Ok(Zeroizing::new(key_bytes.to_vec()))
}

// ============================================================================
// X25519 Key Format Conversions
// ============================================================================

/// Convert X25519 private key from raw bytes to Base64 encoding.
///
/// This function takes a raw 32-byte X25519 private key and encodes it
/// using standard Base64 encoding.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte X25519 private key
///
/// # Returns
///
/// A Base64-encoded string representation of the private key.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
///
/// # Security Notes
///
/// - The input key should be handled securely
/// - Consider using `zeroize::Zeroizing` for temporary storage
/// - The returned string contains sensitive data and should be protected
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real private key in practice
/// let base64_key = key_formats::x25519_private_key_to_base64(&raw_key).unwrap();
/// assert_eq!(base64_key.len(), 44); // Base64 encoding of 32 bytes
/// ```
pub fn x25519_private_key_to_base64(raw_key: &[u8]) -> Result<String, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    Ok(encode_signature(raw_key))
}

/// Convert X25519 private key from Base64 encoding to raw bytes.
///
/// This function takes a Base64-encoded X25519 private key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `base64_key` - The Base64-encoded X25519 private key
///
/// # Returns
///
/// The raw 32-byte X25519 private key in a `Zeroizing` container.
///
/// # Errors
///
/// Returns an error if:
/// - The Base64 encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Security Notes
///
/// - The returned key is automatically zeroized when dropped
/// - The input string should be handled securely
/// - Consider clearing the input string after use
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let base64_key = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
/// let raw_key = key_formats::x25519_private_key_from_base64(base64_key).unwrap();
/// assert_eq!(raw_key.len(), 32);
/// ```
pub fn x25519_private_key_from_base64(
    base64_key: &str,
) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
    let decoded = decode_signature(base64_key)?;

    if decoded.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: decoded.len(),
        });
    }

    Ok(Zeroizing::new(decoded))
}

/// Convert X25519 public key from raw bytes to Base64 encoding.
///
/// This function takes a raw 32-byte X25519 public key and encodes it
/// using standard Base64 encoding.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte X25519 public key
///
/// # Returns
///
/// A Base64-encoded string representation of the public key.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real public key in practice
/// let base64_key = key_formats::x25519_public_key_to_base64(&raw_key).unwrap();
/// assert_eq!(base64_key.len(), 44); // Base64 encoding of 32 bytes
/// ```
pub fn x25519_public_key_to_base64(raw_key: &[u8]) -> Result<String, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    Ok(encode_signature(raw_key))
}

/// Convert X25519 public key from Base64 encoding to raw bytes.
///
/// This function takes a Base64-encoded X25519 public key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `base64_key` - The Base64-encoded X25519 public key
///
/// # Returns
///
/// The raw 32-byte X25519 public key.
///
/// # Errors
///
/// Returns an error if:
/// - The Base64 encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let base64_key = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
/// let raw_key = key_formats::x25519_public_key_from_base64(base64_key).unwrap();
/// assert_eq!(raw_key.len(), 32);
/// ```
pub fn x25519_public_key_from_base64(base64_key: &str) -> Result<[u8; 32], ONDCCryptoError> {
    let decoded = decode_signature(base64_key)?;

    if decoded.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: decoded.len(),
        });
    }

    let mut key = [0u8; 32];
    key.copy_from_slice(&decoded);
    Ok(key)
}

/// Convert X25519 public key from raw bytes to DER format.
///
/// This function takes a raw 32-byte X25519 public key and encodes it
/// in DER format according to RFC 8410 as a SubjectPublicKeyInfo structure.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte X25519 public key
///
/// # Returns
///
/// The DER-encoded public key as bytes in SubjectPublicKeyInfo format.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
/// - DER encoding fails
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real public key in practice
/// let der_key = key_formats::x25519_public_key_to_der(&raw_key).unwrap();
/// assert!(der_key.len() > 32); // DER encoding adds structure
/// ```
pub fn x25519_public_key_to_der(raw_key: &[u8]) -> Result<Vec<u8>, ONDCCryptoError> {
    use der::asn1::{BitString, ObjectIdentifier};
    use der::{Sequence, Encode};

    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    // X25519 algorithm identifier OID as per RFC 8410
    let x25519_oid = ObjectIdentifier::new("1.3.101.110")
        .map_err(|e| ONDCCryptoError::EncodingError(format!("Invalid OID: {}", e)))?;

    // Algorithm identifier structure
    #[derive(Sequence)]
    struct AlgorithmIdentifier {
        algorithm: ObjectIdentifier,
        // parameters are omitted for X25519 as per RFC 8410
    }

    // SubjectPublicKeyInfo structure
    #[derive(Sequence)]
    struct SubjectPublicKeyInfo {
        algorithm: AlgorithmIdentifier,
        subject_public_key: BitString,
    }

    let algorithm = AlgorithmIdentifier {
        algorithm: x25519_oid,
    };

    let subject_public_key = BitString::new(0, raw_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("BitString creation failed: {}", e)))?;

    let subject_public_key_info = SubjectPublicKeyInfo {
        algorithm,
        subject_public_key,
    };

    subject_public_key_info
        .to_der()
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER serialization failed: {}", e)))
}

/// Convert X25519 public key from DER format to raw bytes.
///
/// This function takes a DER-encoded X25519 public key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `der_key` - The DER-encoded X25519 public key
///
/// # Returns
///
/// The raw 32-byte X25519 public key.
///
/// # Errors
///
/// Returns an error if:
/// - The DER encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32];
/// let der_key = key_formats::x25519_public_key_to_der(&raw_key).unwrap();
/// let decoded_key = key_formats::x25519_public_key_from_der(&der_key).unwrap();
/// assert_eq!(&decoded_key, &raw_key);
/// ```
pub fn x25519_public_key_from_der(der_key: &[u8]) -> Result<[u8; 32], ONDCCryptoError> {
    use der::asn1::{BitString, ObjectIdentifier};
    use der::{Sequence, Decode};

    // X25519 algorithm identifier OID as per RFC 8410
    let x25519_oid = ObjectIdentifier::new("1.3.101.110")
        .map_err(|e| ONDCCryptoError::EncodingError(format!("Invalid OID: {}", e)))?;

    // Algorithm identifier structure
    #[derive(Sequence)]
    struct AlgorithmIdentifier {
        algorithm: ObjectIdentifier,
        // parameters are omitted for X25519 as per RFC 8410
    }

    // SubjectPublicKeyInfo structure
    #[derive(Sequence)]
    struct SubjectPublicKeyInfo {
        algorithm: AlgorithmIdentifier,
        subject_public_key: BitString,
    }

    let subject_public_key_info = SubjectPublicKeyInfo::from_der(der_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER decoding failed: {}", e)))?;

    // Verify this is an X25519 key
    if subject_public_key_info.algorithm.algorithm != x25519_oid {
        return Err(ONDCCryptoError::EncodingError(
            "Invalid algorithm identifier: expected X25519".to_string(),
        ));
    }

    // Extract the public key bytes
    let key_bytes = subject_public_key_info.subject_public_key.as_bytes()
        .ok_or_else(|| ONDCCryptoError::EncodingError("Invalid bit string".to_string()))?;

    if key_bytes.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: key_bytes.len(),
        });
    }

    let mut key = [0u8; 32];
    key.copy_from_slice(key_bytes);
    Ok(key)
}

/// Convert X25519 private key from raw bytes to DER format.
///
/// This function takes a raw 32-byte X25519 private key and encodes it
/// in DER format according to RFC 8410.
///
/// # Arguments
///
/// * `raw_key` - The 32-byte X25519 private key
///
/// # Returns
///
/// The DER-encoded private key as bytes.
///
/// # Errors
///
/// Returns an error if:
/// - The key length is not 32 bytes
/// - The key is invalid or malformed
/// - DER encoding fails
///
/// # Security Notes
///
/// - The input key should be handled securely
/// - Consider using `zeroize::Zeroizing` for temporary storage
/// - The returned DER data contains sensitive information
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32]; // Use a real private key in practice
/// let der_key = key_formats::x25519_private_key_to_der(&raw_key).unwrap();
/// assert!(der_key.len() > 32); // DER encoding adds structure
/// ```
pub fn x25519_private_key_to_der(raw_key: &[u8]) -> Result<Vec<u8>, ONDCCryptoError> {
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }

    // Create DER structure for X25519 private key
    let octet_string = OctetString::new(raw_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER encoding failed: {}", e)))?;

    octet_string
        .to_der()
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER serialization failed: {}", e)))
}

/// Convert X25519 private key from DER format to raw bytes.
///
/// This function takes a DER-encoded X25519 private key and decodes it
/// to raw bytes for cryptographic operations.
///
/// # Arguments
///
/// * `der_key` - The DER-encoded X25519 private key
///
/// # Returns
///
/// The raw 32-byte X25519 private key in a `Zeroizing` container.
///
/// # Errors
///
/// Returns an error if:
/// - The DER encoding is invalid
/// - The decoded key length is not 32 bytes
/// - The key is malformed
///
/// # Security Notes
///
/// - The returned key is automatically zeroized when dropped
/// - The input should be handled securely
///
/// # Examples
///
/// ```rust
/// use ondc_crypto_formats::key_formats;
///
/// let raw_key = [0u8; 32];
/// let der_key = key_formats::x25519_private_key_to_der(&raw_key).unwrap();
/// let decoded_key = key_formats::x25519_private_key_from_der(&der_key).unwrap();
/// assert_eq!(decoded_key.as_slice(), &raw_key);
/// ```
pub fn x25519_private_key_from_der(der_key: &[u8]) -> Result<Zeroizing<Vec<u8>>, ONDCCryptoError> {
    let octet_string = OctetString::from_der(der_key)
        .map_err(|e| ONDCCryptoError::EncodingError(format!("DER decoding failed: {}", e)))?;

    let key_bytes = octet_string.as_bytes();

    if key_bytes.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: key_bytes.len(),
        });
    }

    Ok(Zeroizing::new(key_bytes.to_vec()))
}

// ============================================================================
// Legacy Functions (for backward compatibility)
// ============================================================================

/// Convert Ed25519 private key from raw bytes.
///
/// This is a legacy function that maintains backward compatibility.
/// Consider using `ed25519_private_key_to_base64` for new code.
///
/// # Arguments
///
/// * `raw_key` - The raw Ed25519 private key bytes
///
/// # Returns
///
/// The private key in a standardized format.
///
/// # Errors
///
/// Returns an error if the key is invalid.
pub fn ed25519_from_raw(raw_key: &[u8]) -> Result<Vec<u8>, ONDCCryptoError> {
    // For backward compatibility, return the raw key as-is
    // but validate the length
    if raw_key.len() != 32 {
        return Err(ONDCCryptoError::InvalidKeyLength {
            expected: 32,
            got: raw_key.len(),
        });
    }
    Ok(raw_key.to_vec())
}

/// Convert X25519 public key to DER format.
///
/// This is a legacy function that maintains backward compatibility.
/// Consider using `x25519_public_key_to_der` for new code.
///
/// # Arguments
///
/// * `public_key` - The X25519 public key bytes
///
/// # Returns
///
/// The public key in DER format.
///
/// # Errors
///
/// Returns an error if the key is invalid.
pub fn x25519_to_der(public_key: &[u8]) -> Result<Vec<u8>, ONDCCryptoError> {
    x25519_public_key_to_der(public_key)
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test data for Ed25519 keys
    const TEST_ED25519_PRIVATE_KEY: [u8; 32] = [
        0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b, 0x5c,
        0x6d, 0x7e, 0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d, 0x9e, 0x0f,
        0x1a, 0x2b,
    ];

    const TEST_ED25519_PUBLIC_KEY: [u8; 32] = [
        0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b, 0x5c, 0x6d, 0x7e,
        0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d, 0x9e, 0x0f, 0x1a, 0x2b,
        0x3c, 0x4d,
    ];

    // Test data for X25519 keys
    const TEST_X25519_PRIVATE_KEY: [u8; 32] = [
        0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b, 0x5c, 0x6d,
        0x7e, 0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d, 0x9e, 0x0f, 0x1a,
        0x2b, 0x3c,
    ];

    const TEST_X25519_PUBLIC_KEY: [u8; 32] = [
        0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b, 0x5c, 0x6d, 0x7e, 0x8f,
        0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d, 0x9e, 0x0f, 0x1a, 0x2b, 0x3c,
        0x4d, 0x5e,
    ];

    #[test]
    fn test_ed25519_private_key_base64_roundtrip() {
        let base64_key = ed25519_private_key_to_base64(&TEST_ED25519_PRIVATE_KEY).unwrap();
        let decoded_key = ed25519_private_key_from_base64(&base64_key).unwrap();
        assert_eq!(decoded_key.as_slice(), &TEST_ED25519_PRIVATE_KEY);
    }

    #[test]
    fn test_ed25519_public_key_base64_roundtrip() {
        let base64_key = ed25519_public_key_to_base64(&TEST_ED25519_PUBLIC_KEY).unwrap();
        let decoded_key = ed25519_public_key_from_base64(&base64_key).unwrap();
        assert_eq!(&decoded_key, &TEST_ED25519_PUBLIC_KEY);
    }

    #[test]
    fn test_ed25519_private_key_der_roundtrip() {
        let der_key = ed25519_private_key_to_der(&TEST_ED25519_PRIVATE_KEY).unwrap();
        let decoded_key = ed25519_private_key_from_der(&der_key).unwrap();
        assert_eq!(decoded_key.as_slice(), &TEST_ED25519_PRIVATE_KEY);
    }

    #[test]
    fn test_x25519_private_key_base64_roundtrip() {
        let base64_key = x25519_private_key_to_base64(&TEST_X25519_PRIVATE_KEY).unwrap();
        let decoded_key = x25519_private_key_from_base64(&base64_key).unwrap();
        assert_eq!(decoded_key.as_slice(), &TEST_X25519_PRIVATE_KEY);
    }

    #[test]
    fn test_x25519_public_key_base64_roundtrip() {
        let base64_key = x25519_public_key_to_base64(&TEST_X25519_PUBLIC_KEY).unwrap();
        let decoded_key = x25519_public_key_from_base64(&base64_key).unwrap();
        assert_eq!(&decoded_key, &TEST_X25519_PUBLIC_KEY);
    }

    #[test]
    fn test_x25519_public_key_der_roundtrip() {
        let der_key = x25519_public_key_to_der(&TEST_X25519_PUBLIC_KEY).unwrap();
        let decoded_key = x25519_public_key_from_der(&der_key).unwrap();
        assert_eq!(&decoded_key, &TEST_X25519_PUBLIC_KEY);
    }

    #[test]
    fn test_x25519_private_key_der_roundtrip() {
        let der_key = x25519_private_key_to_der(&TEST_X25519_PRIVATE_KEY).unwrap();
        let decoded_key = x25519_private_key_from_der(&der_key).unwrap();
        assert_eq!(decoded_key.as_slice(), &TEST_X25519_PRIVATE_KEY);
    }

    #[test]
    fn test_invalid_key_lengths() {
        // Test Ed25519 private key with wrong length
        let short_key = [0u8; 16];
        assert!(ed25519_private_key_to_base64(&short_key).is_err());
        assert!(ed25519_private_key_to_der(&short_key).is_err());

        // Test X25519 public key with wrong length
        let long_key = [0u8; 64];
        assert!(x25519_public_key_to_base64(&long_key).is_err());
        assert!(x25519_public_key_to_der(&long_key).is_err());
    }

    #[test]
    fn test_invalid_base64_encoding() {
        let invalid_base64 = "invalid!";
        assert!(ed25519_private_key_from_base64(invalid_base64).is_err());
        assert!(ed25519_public_key_from_base64(invalid_base64).is_err());
        assert!(x25519_private_key_from_base64(invalid_base64).is_err());
        assert!(x25519_public_key_from_base64(invalid_base64).is_err());
    }

    #[test]
    fn test_invalid_der_encoding() {
        let invalid_der = b"invalid DER data";
        assert!(ed25519_private_key_from_der(invalid_der).is_err());
        assert!(x25519_public_key_from_der(invalid_der).is_err());
        assert!(x25519_private_key_from_der(invalid_der).is_err());
    }

    #[test]
    fn test_legacy_functions() {
        // Test legacy ed25519_from_raw function
        let result = ed25519_from_raw(&TEST_ED25519_PRIVATE_KEY).unwrap();
        assert_eq!(result, TEST_ED25519_PRIVATE_KEY);

        // Test legacy x25519_to_der function
        let result = x25519_to_der(&TEST_X25519_PUBLIC_KEY).unwrap();
        let decoded = x25519_public_key_from_der(&result).unwrap();
        assert_eq!(&decoded, &TEST_X25519_PUBLIC_KEY);
    }

    #[test]
    fn test_zeroization() {
        let base64_key = ed25519_private_key_to_base64(&TEST_ED25519_PRIVATE_KEY).unwrap();
        let decoded_key = ed25519_private_key_from_base64(&base64_key).unwrap();

        // Verify the key is in a Zeroizing container
        assert_eq!(decoded_key.as_slice(), &TEST_ED25519_PRIVATE_KEY);

        // The key will be automatically zeroized when dropped
        drop(decoded_key);
    }

    #[test]
    fn test_ondc_compatibility() {
        // Test with data that matches ONDC key patterns
        let test_key = [
            0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b,
            0x5c, 0x6d, 0x7e, 0x8f, 0x9a, 0x0b, 0x1c, 0x2d, 0x3e, 0x4f, 0x5a, 0x6b, 0x7c, 0x8d,
            0x9e, 0x0f, 0x1a, 0x2b,
        ];

        let base64_key = ed25519_private_key_to_base64(&test_key).unwrap();
        let decoded_key = ed25519_private_key_from_base64(&base64_key).unwrap();
        assert_eq!(decoded_key.as_slice(), &test_key);

        // Verify the encoded string is valid for ONDC operations
        assert!(!base64_key.contains('+') || !base64_key.contains('/')); // Should be URL-safe if needed
    }
}

================
File: .gitignore
================
/target

.cursor/*

docs/example-node-implementation.xml

*.keys.json
keys.json

logs/*

================
File: ondc-bap/src/services/registry_client.rs
================
//! Registry Client Service for ONDC BAP Server
//!
//! This service provides HTTP client capabilities for interacting with the ONDC registry APIs.
//! It handles subscription requests, participant lookups, and implements proper error handling
//! with retry logic and rate limiting compliance.

use std::sync::Arc;
use std::time::Duration;
use chrono::Utc;
use reqwest::{Client, ClientBuilder};
use serde::{Deserialize, Serialize};
use tracing::{info, warn, error, instrument};

use crate::config::{ONDCConfig, ondc_config::ParticipantType};
use crate::services::KeyManagementService;

/// Registry client error types
#[derive(Debug, thiserror::Error)]
pub enum RegistryClientError {
    #[error("HTTP client creation failed: {0}")]
    ClientCreationFailed(String),

    #[error("HTTP request failed: {0}")]
    RequestFailed(String),

    #[error("Serialization failed: {0}")]
    SerializationFailed(String),

    #[error("Deserialization failed: {0}")]
    DeserializationFailed(String),

    #[error("Subscription failed: {0}")]
    SubscriptionFailed(String),

    #[error("Lookup failed: {0}")]
    LookupFailed(String),

    #[error("Rate limit exceeded")]
    RateLimitExceeded,

    #[error("Key management error: {0}")]
    KeyManagerError(String),

    #[error("Configuration error: {0}")]
    ConfigError(String),

    #[error("Invalid response: {0}")]
    InvalidResponse(String),
}

/// ONDC subscribe request payload
#[derive(Debug, Serialize)]
pub struct SubscribeRequest {
    pub context: SubscribeContext,
    pub message: SubscribeMessage,
}

/// Subscribe context with operation details
#[derive(Debug, Serialize)]
pub struct SubscribeContext {
    pub operation: SubscribeOperation,
}

/// Subscribe operation details
#[derive(Debug, Serialize)]
pub struct SubscribeOperation {
    pub ops_no: u32,
}

/// Subscribe message containing entity and participant information
#[derive(Debug, Serialize)]
pub struct SubscribeMessage {
    pub request_id: String,
    pub timestamp: String,
    pub entity: SubscribeEntity,
    pub network_participant: Vec<NetworkParticipant>,
}

/// Subscribe entity with business and key information
#[derive(Debug, Serialize)]
pub struct SubscribeEntity {
    pub gst: GstInfo,
    pub pan: PanInfo,
    pub name_of_authorised_signatory: String,
    pub address_of_authorised_signatory: String,
    pub email_id: String,
    pub mobile_no: u64,
    pub country: String,
    pub subscriber_id: String,
    pub unique_key_id: String,
    pub callback_url: String,
    pub key_pair: KeyPairInfo,
}

/// GST information
#[derive(Debug, Serialize)]
pub struct GstInfo {
    pub legal_entity_name: String,
    pub business_address: String,
    pub city_code: Vec<String>,
    pub gst_no: Option<String>,
}

/// PAN information
#[derive(Debug, Serialize)]
pub struct PanInfo {
    pub name_as_per_pan: String,
    pub pan_no: String,
    pub date_of_incorporation: String,
}

/// Key pair information
#[derive(Debug, Serialize)]
pub struct KeyPairInfo {
    pub signing_public_key: String,
    pub encryption_public_key: String,
    pub valid_from: String,
    pub valid_until: String,
}

/// Network participant information
#[derive(Debug, Serialize)]
pub struct NetworkParticipant {
    pub subscriber_url: String,
    pub domain: String,
    #[serde(rename = "type")]
    pub participant_type: ParticipantType,
    pub msn: bool,
    pub city_code: Vec<String>,
}

/// ONDC subscribe response
#[derive(Debug, Deserialize)]
pub struct SubscribeResponse {
    pub message: SubscribeResponseMessage,
    pub error: SubscribeResponseError,
}

/// Subscribe response message
#[derive(Debug, Deserialize)]
pub struct SubscribeResponseMessage {
    pub ack: SubscribeAck,
}

/// Subscribe acknowledgment
#[derive(Debug, Deserialize)]
pub struct SubscribeAck {
    pub status: String,
}

/// Subscribe response error
#[derive(Debug, Deserialize)]
pub struct SubscribeResponseError {
    #[serde(rename = "type")]
    pub error_type: Option<String>,
    pub code: Option<String>,
    pub path: Option<String>,
    pub message: Option<String>,
}

/// Registry client for ONDC API interactions
pub struct RegistryClient {
    client: Client,
    base_url: String,
    key_manager: Arc<KeyManagementService>,
    config: ONDCConfig,
}

impl RegistryClient {
    /// Create a new registry client
    pub fn new(
        key_manager: Arc<KeyManagementService>,
        config: ONDCConfig,
    ) -> Result<Self, RegistryClientError> {
        info!("Initializing registry client for {}", config.registry_base_url);

        let client = ClientBuilder::new()
            .timeout(Duration::from_secs(config.request_timeout_secs))
            .build()
            .map_err(|e| RegistryClientError::ClientCreationFailed(e.to_string()))?;

        Ok(Self {
            client,
            base_url: config.registry_base_url.clone(),
            key_manager,
            config,
        })
    }

    /// Subscribe to ONDC registry
    ///
    /// This method sends a subscription request to the ONDC registry with the provided
    /// operation number and generates all required fields from configuration.
    #[instrument(skip(self), fields(subscriber_id = %self.config.subscriber_id, ops_no = ops_no))]
    pub async fn subscribe(
        &self,
        ops_no: u32,
    ) -> Result<SubscribeResponse, RegistryClientError> {
        let request_id = uuid::Uuid::new_v4().to_string();
        self.subscribe_with_request_id(ops_no, request_id).await
    }

    /// Subscribe to ONDC registry with optional request_id
    ///
    /// This method sends a subscription request to the ONDC registry with the provided
    /// operation number and optionally uses a specific request_id (for domain verification).
    #[instrument(skip(self), fields(subscriber_id = %self.config.subscriber_id, ops_no = ops_no))]
    pub async fn subscribe_with_request_id(
        &self,
        ops_no: u32,
        request_id: String,
    ) -> Result<SubscribeResponse, RegistryClientError> {
        info!("Sending subscription request to registry (ops_no: {})", ops_no);

        // Use provided request_id
        info!("Using provided request_id: {}", request_id);
        
        let timestamp = Utc::now().format("%Y-%m-%dT%H:%M:%S.%3fZ").to_string();
        
        // Set key validity period - valid for 1 week from now
        let now = Utc::now();
        // Format timestamps to match ONDC expected format (Z instead of +00:00, millisecond precision)
        let valid_from = now.format("%Y-%m-%dT%H:%M:%S.%3fZ").to_string();
        let valid_until = (now + chrono::Duration::weeks(1)).format("%Y-%m-%dT%H:%M:%S.%3fZ").to_string();
        

        // Get public keys from key manager
        let signing_public_key = self.key_manager.get_signing_public_key().await
            .map_err(|e| RegistryClientError::KeyManagerError(e.to_string()))?;
        let encryption_public_key = self.key_manager.get_encryption_public_key().await
            .map_err(|e| RegistryClientError::KeyManagerError(e.to_string()))?;
        let unique_key_id = self.key_manager.get_unique_key_id().await;

        // Build the subscription request
        let request = SubscribeRequest {
            context: SubscribeContext {
                operation: SubscribeOperation { ops_no },
            },
            message: SubscribeMessage {
                request_id: request_id.clone(),
                timestamp: timestamp.clone(),
                entity: SubscribeEntity {
                    gst: GstInfo {
                        legal_entity_name: self.config.business_entity.gst.legal_entity_name.clone(),
                        business_address: self.config.business_entity.gst.business_address.clone(),
                        city_code: self.config.business_entity.gst.city_code.clone(),
                        gst_no: self.config.business_entity.gst.gst_no.clone(),
                    },
                    pan: PanInfo {
                        name_as_per_pan: self.config.business_entity.pan.name_as_per_pan.clone(),
                        pan_no: self.config.business_entity.pan.pan_no.clone(),
                        date_of_incorporation: self.config.business_entity.pan.date_of_incorporation.clone(),
                    },
                    name_of_authorised_signatory: self.config.business_entity.name_of_authorised_signatory.clone(),
                    address_of_authorised_signatory: self.config.business_entity.address_of_authorised_signatory.clone(),
                    email_id: self.config.business_entity.email_id.clone(),
                    mobile_no: self.config.business_entity.mobile_no,
                    country: self.config.business_entity.country.clone(),
                    subscriber_id: self.config.subscriber_id.clone(),
                    unique_key_id: unique_key_id.clone(),
                    callback_url: self.config.callback_url.clone(),
                    key_pair: KeyPairInfo {
                        signing_public_key,
                        encryption_public_key,
                        valid_from,
                        valid_until,
                    },
                },
                network_participant: vec![
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "nic2004:60232".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET10".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET11".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET12".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET13".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET14".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET15".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET16".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET18".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET1A".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET1B".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET1C".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:RET1D".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:AGR10".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:AGR11".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:SRV10".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:SRV11".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                    NetworkParticipant {
                        subscriber_url: "/".to_string(),
                        domain: "ONDC:SRV12".to_string(),
                        participant_type: ParticipantType::BuyerApp,
                        msn: false,
                        city_code: vec!["std:080".to_string()],
                    },
                ],
            },
        };

        // Send the request
        let url = format!("{}/subscribe", self.base_url);

        let response = self.client
            .post(&url)
            .header("Content-Type", "application/json")
            .json(&request)
            .send()
            .await
            .map_err(|e| RegistryClientError::RequestFailed(e.to_string()))?;

        info!("Registry response status: {}", response.status());

        if response.status().is_success() {
            let subscription_response: SubscribeResponse = response
                .json()
                .await
                .map_err(|e| RegistryClientError::DeserializationFailed(e.to_string()))?;

            info!("Subscription request successful for request_id: {}", request_id);
            Ok(subscription_response)
        } else if response.status() == 429 {
            warn!("Rate limit exceeded for subscription request");
            Err(RegistryClientError::RateLimitExceeded)
        } else {
            let error_text = response
                .text()
                .await
                .unwrap_or_else(|_| "Unknown error".to_string());

            error!("Subscription request failed: {}", error_text);
            Err(RegistryClientError::SubscriptionFailed(error_text))
        }
    }

    /// Subscribe with retry logic
    ///
    /// This method implements exponential backoff retry logic for subscription requests,
    /// specifically handling rate limiting (429) responses.
    #[instrument(skip(self), fields(subscriber_id = %self.config.subscriber_id, ops_no = ops_no))]
    pub async fn subscribe_with_retry(
        &self,
        ops_no: u32,
    ) -> Result<SubscribeResponse, RegistryClientError> {
        let mut attempts = 0;
        let max_attempts = self.config.max_retries;

        loop {
            match self.subscribe(ops_no).await {
                Ok(response) => return Ok(response),
                Err(RegistryClientError::RateLimitExceeded) if attempts < max_attempts => {
                    let delay = Duration::from_millis(1000 * 2_u64.pow(attempts as u32));
                    warn!("Rate limited, retrying in {:?} (attempt {}/{})", delay, attempts + 1, max_attempts);
                    tokio::time::sleep(delay).await;
                    attempts += 1;
                }
                Err(e) => return Err(e),
            }
        }
    }

    /// Validate subscription response
    ///
    /// This method validates that the subscription response indicates success.
    pub fn validate_subscription_response(
        &self,
        response: &SubscribeResponse,
    ) -> Result<(), RegistryClientError> {
        // Print response message
        if response.message.ack.status == "ACK" {
            if let (None, None, None, None) = (
                &response.error.error_type,
                &response.error.code,
                &response.error.path,
                &response.error.message,
            ) {
                Ok(())
            } else {
                Err(RegistryClientError::InvalidResponse(
                    "Subscription response contains error information".to_string(),
                ))
            }
        } else {
            error!("Subscription failed with error code: {:?}", response.error.code);
            error!("Subscription failed with error message: {:?}", response.error.message);
            Err(RegistryClientError::InvalidResponse(format!(
                "Subscription failed with status: {}",
                response.message.ack.status
            )))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_subscribe_request_serialization() {
        let request = SubscribeRequest {
            context: SubscribeContext {
                operation: SubscribeOperation { ops_no: 1 },
            },
            message: SubscribeMessage {
                request_id: "test-request-id".to_string(),
                timestamp: "2022-07-08T13:44:54.101Z".to_string(),
                entity: SubscribeEntity {
                    gst: GstInfo {
                        legal_entity_name: "Test Entity".to_string(),
                        business_address: "Test Address".to_string(),
                        city_code: vec!["std:080".to_string()],
                        gst_no: Some("00AAAAA0000A1Z5".to_string()),
                    },
                    pan: PanInfo {
                        name_as_per_pan: "Test Entity".to_string(),
                        pan_no: "AAAAA0000A".to_string(),
                        date_of_incorporation: "01/01/2020".to_string(),
                    },
                    name_of_authorised_signatory: "Test Signatory".to_string(),
                    address_of_authorised_signatory: "Test Address".to_string(),
                    email_id: "test@example.com".to_string(),
                    mobile_no: 9999999999,
                    country: "IND".to_string(),
                    subscriber_id: "test.example.com".to_string(),
                    unique_key_id: "test-key-1".to_string(),
                    callback_url: "/".to_string(),
                    key_pair: KeyPairInfo {
                        signing_public_key: "test-signing-key".to_string(),
                        encryption_public_key: "test-encryption-key".to_string(),
                        valid_from: "2022-07-08T13:44:54.101Z".to_string(),
                        valid_until: "2022-07-08T13:44:54.101Z".to_string(),
                    },
                },
                network_participant: vec![NetworkParticipant {
                    subscriber_url: "/bapl".to_string(),
                    domain: "nic2004:52110".to_string(),
                    participant_type: ParticipantType::BuyerApp,
                    msn: false,
                    city_code: vec!["std:080".to_string()],
                }],
            },
        };

        let json = serde_json::to_string(&request).unwrap();
        assert!(json.contains("test-request-id"));
        assert!(json.contains("ops_no"));
        assert!(json.contains("buyerApp"));
    }
}

================
File: ondc-bap/src/presentation/server.rs
================
//! Main server implementation for ONDC BAP

use std::net::SocketAddr;
use std::sync::Arc;
use tokio::signal;
use tracing::{error, info, warn};
use axum_server::tls_rustls::RustlsConfig;

use super::routes::create_router;
use crate::config::load_config;
use crate::services::{KeyManagementService, RegistryClient};
use crate::{BAPConfig, Result};

/// Main BAP server implementation
pub struct BAPServer {
    config: Arc<BAPConfig>,
    key_manager: Arc<KeyManagementService>,
    registry_client: Arc<RegistryClient>,
}

impl BAPServer {
    /// Create a new BAP server instance
    pub async fn new() -> Result<Self> {
        let config = Arc::new(load_config()?);
        info!("BAP Server configuration loaded successfully");

        let key_manager = Arc::new(
            KeyManagementService::new(config.keys.clone())
                .await
                .map_err(|e| crate::error::AppError::Internal(e.to_string()))?,
        );
        info!("Key management service initialized successfully");

        let registry_client = Arc::new(RegistryClient::new(key_manager.clone(), config.ondc.clone())?);
        info!("Registry client initialized successfully");

        Ok(Self {
            config,
            key_manager,
            registry_client,
        })
    }

    /// Run the server
    pub async fn run(&self) -> Result<()> {
        let addr = SocketAddr::from((
            self.config
                .server
                .host
                .parse::<std::net::IpAddr>()
                .unwrap_or_else(|_| [0, 0, 0, 0].into()),
            self.config.server.port,
        ));

        info!("Starting BAP Server on {}", addr);

        // Create router
        let app = create_router(self.config.clone(), self.key_manager.clone(), self.registry_client.clone());

        // Check if TLS certificates are available
        let cert_path = "/opt/ssl-certs/fullchain.pem";
        let key_path = "/opt/ssl-certs/privkey.pem";
        
        if std::path::Path::new(cert_path).exists() && std::path::Path::new(key_path).exists() {
            info!("TLS certificates found, starting HTTPS server");
            self.run_https_server(addr, app, cert_path, key_path).await
        } else {
            warn!("TLS certificates not found, starting HTTP server");
            self.run_http_server(addr, app).await
        }
    }

    /// Run HTTP server (fallback when TLS certificates are not available)
    async fn run_http_server(&self, addr: SocketAddr, app: axum::Router) -> Result<()> {
        let listener = tokio::net::TcpListener::bind(addr)
            .await
            .map_err(|e| crate::error::AppError::Internal(e.to_string()))?;

        info!("HTTP Server listening on {}", addr);

        let graceful = axum::serve(listener, app).with_graceful_shutdown(shutdown_signal());

        if let Err(e) = graceful.await {
            error!("Server error: {}", e);
            return Err(crate::error::AppError::Internal(e.to_string()));
        }

        info!("Server shutdown complete");
        Ok(())
    }

    /// Run HTTPS server with TLS support
    async fn run_https_server(&self, addr: SocketAddr, app: axum::Router, cert_path: &str, key_path: &str) -> Result<()> {
        let tls_config = self.load_rustls_config(cert_path, key_path).await?;

        info!("HTTPS Server listening on {}", addr);

        let server = axum_server::bind_rustls(addr, tls_config);
        let graceful = server.serve(app.into_make_service());
        
        tokio::select! {
            result = graceful => {
                if let Err(e) = result {
                    error!("Server error: {}", e);
                    return Err(crate::error::AppError::Internal(e.to_string()));
                }
            }
            _ = shutdown_signal() => {
                info!("Shutdown signal received, server shutting down gracefully");
            }
        }

        info!("Server shutdown complete");
        Ok(())
    }

    /// Load TLS configuration from certificate and key files
    async fn load_rustls_config(&self, cert_path: &str, key_path: &str) -> Result<RustlsConfig> {
        // Read certificate and key files as bytes
        let cert_pem = std::fs::read(cert_path)
            .map_err(|e| crate::error::AppError::Internal(format!("Failed to read certificate file: {}", e)))?;
        let key_pem = std::fs::read(key_path)
            .map_err(|e| crate::error::AppError::Internal(format!("Failed to read private key file: {}", e)))?;

        // Create TLS configuration using axum-server's RustlsConfig
        let config = RustlsConfig::from_pem(cert_pem, key_pem)
            .await
            .map_err(|e| crate::error::AppError::Internal(format!("Failed to create TLS config: {}", e)))?;

        Ok(config)
    }

    /// Get server configuration
    pub fn config(&self) -> &BAPConfig {
        &self.config
    }

    /// Get key manager
    pub fn key_manager(&self) -> &KeyManagementService {
        &self.key_manager
    }
}

/// Handle graceful shutdown signals
async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("Received Ctrl+C, shutting down gracefully");
        },
        _ = terminate => {
            info!("Received SIGTERM, shutting down gracefully");
        },
    }

    info!("Shutdown signal received, starting graceful shutdown");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_server_creation() {
        // This test will need proper configuration setup
        // For now, just verify the struct can be created with test config
        let test_config = crate::config::environment::create_test_config();
        let key_manager = KeyManagementService::new(test_config.keys.clone())
            .await
            .unwrap();
        let key_manager_arc = Arc::new(key_manager);
        let registry_client = RegistryClient::new(key_manager_arc.clone(), test_config.ondc.clone())
            .unwrap();

        let _server = BAPServer {
            config: Arc::new(test_config),
            key_manager: key_manager_arc,
            registry_client: Arc::new(registry_client),
        };
    }
}

================
File: Cargo.toml
================
[workspace]
members = [
    "ondc-bap",
    "ondc-crypto-traits",
    "ondc-crypto-algorithms", 
    "ondc-crypto-formats",
    "ondc-crypto-cli",
]

resolver = "2"

[workspace.dependencies]
# Core cryptographic dependencies
ed25519-dalek = "2.0"
blake2b_simd = "1.0"
x25519-dalek = "2.0"
rand = "0.8"

# Memory safety and security
zeroize = "1.7"
subtle = "2.5"

# Encoding and formatting
base64 = "0.21"
hex = "0.4"

# Time handling
chrono = { version = "0.4", features = ["serde"] }

# Error handling
thiserror = "1.0"

# Async support
tokio = { version = "1.0", features = ["full"] }

# HTTP and networking
reqwest = { version = "0.11", features = ["json", "native-tls"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# Testing and development
proptest = "1.3"
criterion = "0.5"

# Web framework dependencies
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
hyper = "1.0"

# Configuration
config = "0.14"
figment = { version = "0.10", features = ["toml", "env"] }

# Logging and tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-opentelemetry = "0.21"

# Error handling
anyhow = "1.0"

# Security
rustls = "0.22"
rustls-pemfile = "2.0"

# UUID generation
uuid = "1.0"

# URL parsing
url = "2.4"

# Regex for validation
regex = "1.0"

# AES encryption
aes = "0.8"
block-modes = "0.9"

# Documentation
mdbook = "0.4"

# Development tools
rustfmt = "0.1"
clippy = "0.1"

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Airesh Bhat(nelliairesh@gmail.com)"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/ondc/ondc-crypto-rs"
description = "ONDC cryptographic utilities for Rust"
keywords = ["ondc", "crypto", "signing", "ed25519", "blake2"]
categories = ["cryptography", "api-bindings"]
readme = "README.md"

[workspace.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

================
File: ondc-bap/config/staging.toml
================
# ONDC BAP Server - Staging Configuration

[server]
host = "0.0.0.0"
port = 8443
request_timeout_secs = 30
max_connections = 1000

# TLS configuration (optional for staging)
# [server.tls]
# cert_path = "certs/server.crt"
# key_path = "certs/server.key"

[ondc]
environment = "staging"
registry_base_url = "https://staging.registry.ondc.org"
subscriber_id = "network.lootai.co"
callback_url = "/"
request_timeout_secs = 30
max_retries = 3

# Business entity configuration
[ondc.business_entity]
name_of_authorised_signatory = "Test Signatory"
address_of_authorised_signatory = "Test Address, Test City, Test State 123456"
email_id = "mrunalpendem123@gmail.com"
mobile_no = 8309084438
country = "IND"

[ondc.business_entity.gst]
legal_entity_name = "LootAI"
business_address = "Test Business Address, Test City, Test State 123456"
city_code = ["std:080"]
gst_no = "00AAAAA0000A1Z5"

[ondc.business_entity.pan]
name_as_per_pan = "PENDEM SAI SIVA SURYA MRUNAL"
pan_no = "GONPM8506J"
date_of_incorporation = "01/01/2025"

# Network participant configuration
[[ondc.network_participants]]
subscriber_url = "/"
domain = "nic2004:52110"
participant_type = "buyerApp"
msn = false
city_code = ["std:080"]

[keys]
# These should be replaced with actual keys in production
signing_private_key = "iblY/8ruRp43aGEjuCtJrs5QyAhaHroQIaUgWKNScco="
encryption_private_key = "zBxXRXJu+ny+1Ux5bjbp5AFoiYae9STWl10zIR/DRKU="
unique_key_id = "key_1"

[security]
enable_rate_limiting = true
max_requests_per_minute = 100
enable_cors = true
allowed_origins = ["*"]

================
File: docs/status.md
================
# ONDC BAP Server: Complete Project Breakdown

## Project Overview

Implement a production-ready ONDC BAP (Beckn Application Platform) server in Rust with crypto utilities, comprehensive testing, and professional documentation. The server must handle ONDC network participant onboarding and provide required endpoints for registry integration.

## Current Status

**Phase 2 - Crypto Foundation COMPLETED** âœ…

All foundational cryptographic components have been successfully implemented:
- âœ… Ed25519 signing and verification with ONDC compliance
- âœ… X25519 key exchange with secure key handling
- âœ… Base64 encoding utilities with multiple variants support
- âœ… Key format conversions (Base64/DER) for Ed25519/X25519
- âœ… Comprehensive error handling and type safety
- âœ… Memory-safe operations with automatic zeroization

**Phase 3 - BAP Server Core Implementation IN PROGRESS** ðŸš§

**Task 3.3.1 COMPLETED** âœ… - Axum web server setup with production-ready middleware stack

**Key Accomplishments:**
- âœ… **Layered Router Architecture**: Complete Axum router with all required endpoints
- âœ… **Middleware Stack**: Logging, CORS, error handling, security headers, rate limiting
- âœ… **Per-IP Rate Limiting**: Adaptive rate limiting with comprehensive IP extraction
- âœ… **Graceful Shutdown**: Signal handling for clean server termination
- âœ… **Health & Metrics**: Prometheus-style metrics and health check endpoints
- âœ… **Service Integration**: KeyManager service integrated into application state
- âœ… **Production Ready**: Security headers, request validation, comprehensive error handling

**Task 4.2.1 COMPLETED** âœ… - Site verification endpoint implementation

**Key Accomplishments:**
- âœ… **Site Verification Service**: Complete service with UUID generation and Ed25519 signing
- âœ… **Request ID Storage**: In-memory storage with TTL for request ID tracking
- âœ… **HTML Template Generation**: ONDC-compliant HTML with proper meta tags
- âœ… **Error Handling**: Comprehensive error handling and logging
- âœ… **Testing**: Unit tests and integration tests for all functionality
- âœ… **ONDC Compliance**: Ed25519 signing without hashing as per ONDC requirements

**Task 4.3.1 COMPLETED** âœ… - Challenge processing and on_subscribe endpoint implementation

**Key Accomplishments:**
- âœ… **AES-256-ECB Implementation**: Modern RustCrypto-based AES decryption
- âœ… **Challenge Service**: Complete challenge processing with X25519 key exchange
- âœ… **ONDC Public Key Management**: Environment-specific public keys (staging/preprod/prod)
- âœ… **Request Validation**: Comprehensive validation of on_subscribe requests
- âœ… **Error Handling**: Specific error types for challenge processing failures
- âœ… **Integration**: Full integration with existing key management and configuration systems
- âœ… **ONDC Compliance**: Exact implementation of ONDC challenge-response protocol

**CRITICAL GAP IDENTIFIED**: Registry client implementation still needed

**Next Phase**: Implement Registry Client (Task 4.4.1) and Onboarding Service (Task 5.1.1)

## Phase 1: Project Foundation & Setup (Week 1) âœ…

### 1.1 Workspace Setup âœ…
- [x] **Task 1.1.1**: Initialize cargo workspace
- [x] **Task 1.1.2**: Configure development environment

### 1.2 Documentation Framework âœ…
- [x] **Task 1.2.1**: Set up documentation structure

## Phase 2: Core Crypto Implementation (Weeks 2-4) âœ…

### 2.1 ondc-crypto-traits Crate âœ…
- [x] **Task 2.1.1**: Define core traits
- [x] **Task 2.1.2**: Error handling system  
- [x] **Task 2.1.3**: Core types and constants

### 2.2 ondc-crypto-algorithms Crate âœ…
- [x] **Task 2.2.1**: Ed25519 implementation
- [x] **Task 2.2.2**: Ed25519 verification
- [x] **Task 2.2.3**: X25519 key exchange
- [x] **Task 2.2.4**: AES-256-ECB decryption (NEW)

### 2.3 ondc-crypto-formats Crate âœ…
- [x] **Task 2.3.1**: Base64 encoding utilities
- [x] **Task 2.3.2**: Key format conversions

## Phase 3: BAP Server Core Implementation (Weeks 5-6)

### 3.1 Workspace Restructuring âœ…
- [x] **Task 3.1.1**: Rename and restructure main crate âœ…
  ```toml
  # Priority: High | Estimated: 0.5 days
  [package]
  name = "ondc-bap"
  description = "ONDC BAP (Beckn Application Platform) server implementation"
  ```
  - [x] Rename `ondc-crypto` to `ondc-bap` âœ…
  - [x] Update workspace dependencies and references âœ…
  - [x] Restructure directory layout for web server architecture âœ…
  - [x] Update documentation and README files âœ…

- [x] **Task 3.1.2**: Add web server dependencies âœ…
  ```toml
  # Priority: High | Estimated: 0.5 days
  [dependencies]
  axum = "0.7"
  tokio = { version = "1.0", features = ["full"] }
  tower = "0.4"
  tower-http = { version = "0.5", features = ["cors", "trace"] }
  ```
  - [x] Add Axum web framework dependencies
  - [x] Add HTTP client dependencies (reqwest)
  - [x] Add configuration management (config, figment)
  - [x] Add logging and tracing dependencies
  - [x] Add serialization dependencies (serde_json, toml)

### 3.2 Configuration Management âœ…
- [x] **Task 3.2.1**: Environment configuration system âœ…
  ```rust
  // Priority: High | Estimated: 1 day
  #[derive(Debug, Clone, Deserialize)]
  pub struct BAPConfig {
      pub server: ServerConfig,
      pub ondc: ONDCConfig,
      pub keys: KeyConfig,
  }
  ```
  - [x] Create hierarchical configuration structure
  - [x] Support environment-specific configs (staging, pre-prod, prod)
  - [x] Add validation for required configuration fields
  - [x] Support environment variable overrides
  - [x] Add configuration documentation and examples

- [x] **Task 3.2.2**: Key management system âœ…
  ```rust
  // Priority: High | Estimated: 1 day
  pub struct KeyManager {
      signing_key: Ed25519Signer,
      encryption_key: X25519KeyExchange,
  }
  ```
  - [x] Secure key loading from configuration
  - [x] Key validation and format verification
  - [x] Support for multiple key formats (base64, DER)
  - [x] Key rotation capabilities

### 3.3 Core BAP Server Implementation
- [x] **Task 3.3.1**: Axum web server setup âœ…
  ```rust
  // Priority: High | Estimated: 1.5 days
  pub struct BAPServer {
      config: BAPConfig,
      key_manager: KeyManager,
      registry_client: RegistryClient,
  }
  ```
  - [x] Basic `BAPServer` struct created
  - [x] Configuration loading implemented
  - [x] Create Axum router with layered architecture
  - [x] Implement middleware for logging, CORS, error handling
  - [x] Add graceful shutdown handling
  - [x] Configure SSL/TLS for HTTPS (optional for development)
  - [x] Add health check and metrics endpoints
  - [x] **Enhanced**: Per-IP rate limiting with adaptive limits
  - [x] **Enhanced**: Comprehensive IP extraction (X-Forwarded-For, X-Real-IP, CF-Connecting-IP)
  - [x] **Enhanced**: Production-ready middleware stack with security headers

- [ ] **Task 3.3.2**: Domain layer implementation (DEFERRED - Phase 5)
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub struct SubscriberInfo {
      pub subscriber_id: String,
      pub signing_public_key: String,
      pub encryption_public_key: String,
      pub unique_key_id: String,
  }
  ```
  - [ ] Define core domain entities (Subscriber, Challenge, etc.)
  - [ ] Implement business rules validation
  - [ ] Add domain services for key operations
  - [ ] Create value objects with validation
  - [ ] Document domain boundaries and invariants

## Phase 4: ONDC Protocol Implementation (Week 7) - UPDATED PRIORITY

### 4.1 ONDC Configuration Enhancement (CRITICAL) âœ…
- [x] **Task 4.1.1**: Add ONDC-specific configuration âœ…
  ```rust
  // Priority: Critical | Estimated: 0.5 days
  #[derive(Debug, Clone, Deserialize)]
  pub struct ONDCConfig {
      pub environment: Environment,
      pub registry_base_url: String,
      pub subscriber_id: String,
      pub callback_url: String,
      pub request_timeout_secs: u64,
      pub max_retries: usize,
  }
  
  #[derive(Debug, Clone, Deserialize, PartialEq)]
  pub enum Environment {
      Staging,
      PreProd,
      Production,
  }
  ```
  - [x] Add environment-specific registry URLs
  - [x] Add ONDC public keys for each environment
  - [x] Add subscriber ID and callback URL configuration
  - [x] Add request timeout and retry configuration
  - [x] Update configuration validation

### 4.2 Site Verification Implementation (CRITICAL) âœ…
- [x] **Task 4.2.1**: Implement actual site verification endpoint âœ…
  ```rust
  // Priority: Critical | Estimated: 1 day
  pub async fn serve_site_verification(
      State(state): State<AppState>,
  ) -> Result<Html<String>, AppError> {
      // Generate unique request_id
      let request_id = uuid::Uuid::new_v4().to_string();
      
      // Sign request_id using Ed25519 (without hashing)
      let signed_content = key_manager.sign_request_id(&request_id).await?;
      
      // Generate HTML content with signed verification
      let html_content = generate_verification_html(&signed_content);
      
      Ok(Html(html_content))
  }
  ```
  - [x] Generate unique request_id (UUID format) âœ…
  - [x] Sign request_id using Ed25519 without hashing âœ…
  - [x] Template HTML content generation with proper meta tag âœ…
  - [x] Add proper content-type headers âœ…
  - [x] Validate signature generation process âœ…
  - [x] Store request_id for later verification âœ…

### 4.3 Challenge Processing Implementation (CRITICAL) âœ…
- [x] **Task 4.3.1**: Implement actual on-subscribe endpoint âœ…
  ```rust
  // Priority: Critical | Estimated: 1.5 days
  pub async fn handle_on_subscribe(
      State(state): State<AppState>,
      Json(request): Json<OnSubscribeRequest>,
  ) -> Result<JsonResponse<OnSubscribeResponse>, AppError> {
      // Decode base64 encrypted challenge
      let encrypted_challenge = decode_signature(&request.challenge)?;
      
      // Generate X25519 shared secret with ONDC public key
      let shared_secret = key_manager.generate_shared_secret(ondc_public_key).await?;
      
      // Decrypt challenge using AES-256-ECB
      let decrypted_answer = aes_decrypt(&encrypted_challenge, &shared_secret)?;
      
      Ok(JsonResponse(OnSubscribeResponse {
          answer: decrypted_answer,
      }))
  }
  ```
  - [x] Implement X25519 shared secret generation with ONDC public key âœ…
  - [x] Implement AES-256-ECB challenge decryption âœ…
  - [x] Add proper error handling for crypto failures âœ…
  - [x] Add comprehensive logging for debugging âœ…
  - [x] Validate challenge format and length âœ…
  - [x] Add timeout handling for crypto operations âœ…

### 4.4 Registry Client Implementation (CRITICAL)
- [ ] **Task 4.4.1**: Create registry HTTP client
  ```rust
  // Priority: Critical | Estimated: 1.5 days
  pub struct RegistryClient {
      client: reqwest::Client,
      base_url: String,
      key_manager: Arc<KeyManagementService>,
      config: Arc<ONDCConfig>,
  }
  ```
  - [ ] Implement HTTP client for registry APIs
  - [ ] Add request/response serialization
  - [ ] Implement retry logic with exponential backoff
  - [ ] Add request signing for authenticated endpoints
  - [ ] Handle rate limiting (429 responses)
  - [ ] Add timeout and connection pooling

- [ ] **Task 4.4.2**: Implement subscribe API
  ```rust
  // Priority: Critical | Estimated: 1 day
  pub async fn subscribe(
      &self,
      payload: SubscriptionPayload,
  ) -> Result<SubscriptionResponse, RegistryError> {
      // POST to /subscribe endpoint
      // Handle different ops_no values (1, 2, 4)
      // Add payload validation and serialization
      // Handle various error responses
  }
  ```

  - [x] Support different ops_no values (1, 2, 4)
  - [x] Add payload validation and serialization
  - [x] Handle various error responses
  - [x] Add environment-specific URL handling
  - [x] Implement proper error mapping

- [ ] **Task 4.4.3**: Implement lookup API
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub async fn lookup(
      &self,
      criteria: LookupCriteria,
  ) -> Result<Vec<Participant>, RegistryError> {
      // POST to /v2.0/lookup with authorization
      // Support legacy /lookup endpoint
      // Add request signing with HTTP signatures
  }
  ```
  - [ ] Implement `/v2.0/lookup` with authorization
  - [ ] Support legacy `/lookup` endpoint
  - [ ] Add request signing with HTTP signatures
  - [ ] Handle paginated responses
  - [ ] Cache lookup results appropriately

## Phase 5: Onboarding Service Implementation (Week 8) - NEW PRIORITY

### 5.1 Onboarding Service (CRITICAL)
- [ ] **Task 5.1.1**: Create onboarding orchestration service
  ```rust
  // Priority: Critical | Estimated: 2 days
  pub struct OnboardingService {
      registry_client: Arc<RegistryClient>,
      key_manager: Arc<KeyManagementService>,
      config: Arc<ONDCConfig>,
  }
  ```
  - [ ] Orchestrate complete onboarding flow
  - [ ] Validate prerequisites (domain, SSL, whitelisting)
  - [ ] Handle onboarding state management
  - [ ] Add retry mechanisms for failed steps
  - [ ] Provide detailed progress reporting
  - [ ] Implement proper error handling and recovery

- [ ] **Task 5.1.2**: Implement registration status tracking
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub async fn check_registration_status(
      &self,
  ) -> Result<RegistrationStatus, ServiceError> {
      // Check current registration status
      // Add lookup verification
      // Track registration across environments
  }
  ```
  - [ ] Implement registration status checking
  - [ ] Add lookup verification
  - [ ] Track registration across environments
  - [ ] Provide registration health monitoring
  - [ ] Add alerts for registration issues

### 5.2 Domain Layer Implementation (DEFERRED FROM PHASE 3)
- [ ] **Task 5.2.1**: Define core domain entities
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub struct SubscriberInfo {
      pub subscriber_id: String,
      pub signing_public_key: String,
      pub encryption_public_key: String,
      pub unique_key_id: String,
      pub status: RegistrationStatus,
  }
  
  pub struct Challenge {
      pub encrypted_data: Vec<u8>,
      pub subscriber_id: String,
      pub timestamp: DateTime<Utc>,
  }
  
  pub struct Registration {
      pub subscriber_info: SubscriberInfo,
      pub request_id: String,
      pub status: RegistrationStatus,
      pub created_at: DateTime<Utc>,
  }
  ```
  - [ ] Define core domain entities (Subscriber, Challenge, Registration)
  - [ ] Implement business rules validation
  - [ ] Add domain services for key operations
  - [ ] Create value objects with validation
  - [ ] Document domain boundaries and invariants

## Phase 6: Administrative API Implementation (Week 9)

### 6.1 Administrative Endpoints
- [ ] **Task 6.1.1**: Implement admin registration endpoint
  ```rust
  // Priority: High | Estimated: 1.5 days
  pub async fn admin_register(
      State(app_state): State<AppState>,
      Json(request): Json<RegisterRequest>,
  ) -> Result<Json<RegisterResponse>, AppError> {
      // Administrative registration endpoint
      // Validate admin request
      // Process registration through onboarding service
      // Return registration status
  }
  ```
  - [ ] Implement administrative registration endpoint
  - [ ] Add configuration update endpoints
  - [ ] Implement key rotation endpoints
  - [ ] Add status and health monitoring APIs
  - [ ] Secure admin endpoints with authentication
  - [ ] Add request validation and error handling

- [ ] **Task 6.1.2**: Implement public API endpoints
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub async fn get_participant_info(
      State(app_state): State<AppState>,
  ) -> Result<Json<ParticipantInfo>, AppError> {
      // Public participant information
      // Return current registration status
      // Include public keys and metadata
  }
  ```
  - [ ] Implement public participant info endpoint
  - [ ] Add registry lookup proxy endpoints
  - [ ] Implement status check endpoints
  - [ ] Add CORS support for web clients
  - [ ] Document API specifications

### 6.2 Error Handling and Middleware Enhancement
- [ ] **Task 6.2.1**: Enhance error handling system
  ```rust
  // Priority: High | Estimated: 1 day
  #[derive(Error, Debug)]
  pub enum AppError {
      #[error("Registry error: {0}")]
      Registry(#[from] RegistryError),
      #[error("Crypto error: {0}")]
      Crypto(#[from] ONDCCryptoError),
      #[error("Onboarding error: {0}")]
      Onboarding(#[from] OnboardingError),
      #[error("Validation error: {0}")]
      Validation(String),
      #[error("Configuration error: {0}")]
      Config(#[from] ConfigError),
  }
  ```
  - [ ] Implement comprehensive error handling
  - [ ] Add structured error responses
  - [ ] Implement error logging and monitoring
  - [ ] Add user-friendly error messages
  - [ ] Handle different error types appropriately

## Phase 7: Testing and Quality (Week 10)

### 7.1 Integration Testing
- [ ] **Task 7.1.1**: ONDC protocol integration tests
  ```rust
  // Priority: High | Estimated: 2 days
  #[tokio::test]
  async fn test_ondc_onboarding_flow() {
      // Test complete onboarding workflow
      // Test site verification generation
      // Test challenge processing
      // Test registry API interactions
  }
  ```
  - [ ] Test complete onboarding workflow
  - [ ] Test site verification generation and signing
  - [ ] Test challenge decryption with X25519 + AES-256-ECB
  - [ ] Test registry API interactions
  - [ ] Test key management operations
  - [ ] Test error handling scenarios

- [ ] **Task 7.1.2**: Mock registry testing
  ```rust
  // Priority: Medium | Estimated: 1 day
  pub struct MockRegistryServer {
      // Mock server for testing
      // Simulate ONDC registry responses
      // Test error scenarios
  }
  ```
  - [ ] Implement mock registry server
  - [ ] Test against mock registry responses
  - [ ] Add chaos testing for resilience
  - [ ] Test network failure scenarios
  - [ ] Validate retry and recovery mechanisms

### 7.2 Security Testing
- [ ] **Task 7.2.1**: ONDC-specific security validation
  ```rust
  // Priority: High | Estimated: 1 day
  #[test]
  fn test_ondc_crypto_security() {
      // Validate Ed25519 signing without hashing
      // Test X25519 key exchange security
      // Validate AES-256-ECB decryption
      // Test against timing attacks
  }
  ```
  - [ ] Test Ed25519 signing without hashing (ONDC requirement)
  - [ ] Validate X25519 key exchange security
  - [ ] Test AES-256-ECB challenge decryption
  - [ ] Test against timing attacks
  - [ ] Add TLS/SSL configuration testing
  - [ ] Perform security audit

## Phase 8: Documentation and Deployment (Week 11)

### 8.1 ONDC-Specific Documentation
- [ ] **Task 8.1.1**: ONDC integration documentation
  - [ ] Create ONDC onboarding tutorial
  - [ ] Document environment setup for staging/preprod/prod
  - [ ] Add key generation and configuration guides
  - [ ] Document error handling and troubleshooting
  - [ ] Create API specifications for ONDC endpoints

- [ ] **Task 8.1.2**: Deployment guides
  - [ ] Create Docker containers for ONDC environments
  - [ ] Add Kubernetes deployment manifests
  - [ ] Configure monitoring and alerting
  - [ ] Add log aggregation
  - [ ] Create operational runbooks

### 8.2 Production Readiness
- [ ] **Task 8.2.1**: Production deployment preparation
  ```dockerfile
  # Priority: Medium | Estimated: 1 day
  FROM rust:1.70 as builder
  WORKDIR /app
  COPY . .
  RUN cargo build --release
  ```
  - [ ] Create production-ready Docker containers
  - [ ] Add Kubernetes deployment manifests
  - [ ] Configure monitoring and alerting
  - [ ] Add log aggregation
  - [ ] Create operational runbooks

## Updated Timeline and Critical Path

**Total Duration**: 11 weeks (unchanged)
**Critical Path Dependencies**: Updated for ONDC compliance

### Critical Path Dependencies (Updated)
1. **Phase 4.4** â†’ **Phase 5.1** (Registry client â†’ Onboarding service)
2. **Phase 5.1** â†’ **Phase 6.1** (Onboarding service â†’ Admin API)
3. **Phase 6.1** â†’ **Phase 7.1** (Admin API â†’ Testing)
4. **Phase 7.1** â†’ **Phase 8.1** (Testing â†’ Documentation)

### Risk Mitigation (Updated)
- **ONDC Protocol Compliance**: Regular validation against official specifications
- **Crypto Implementation**: Comprehensive testing of Ed25519/X25519/AES operations
- **Registry Integration**: Mock testing and error handling for all scenarios
- **Security Vulnerabilities**: Regular security audits focusing on ONDC requirements
- **Performance Issues**: Load testing with ONDC rate limits in mind
- **Deployment Complexity**: Containerization and automation for multiple environments

### Success Criteria (Updated)
- âœ… **ONDC Onboarding Compliance**: Server can successfully onboard as Network Participant
- âœ… **Protocol Implementation**: All required ONDC endpoints implemented correctly
- âœ… **Crypto Security**: Ed25519/X25519/AES operations meet ONDC standards
- âœ… **Registry Integration**: Full compliance with ONDC registry APIs
- âœ… **Production Ready**: Secure, scalable, and maintainable implementation

This updated breakdown ensures the server will be fully compliant with ONDC onboarding requirements and can successfully register as a Network Participant in all environments (staging, pre-prod, production).




================================================================
End of Codebase
================================================================
